package org.modelix.model.mpsadapters.mps

import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SReference
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.ILanguageRepository.Companion.resolveConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.api.key
import org.modelix.model.api.resolveChildLink
import org.modelix.model.api.resolveIn
import org.modelix.model.api.resolveProperty
import org.modelix.model.api.resolveReferenceLink
import org.modelix.model.area.ContextArea
import org.modelix.model.area.IArea
import org.modelix.model.lazy.unwrap
import java.util.Objects

/*Generated by MPS */
class SNodeToNodeAdapter private constructor(val node: SNode) : INode {

    init {
        notifyModelContentDependency()
    }

    protected fun notifyModelContentDependency() {
        val model: SModel? = node.model
        if (model == null) {
            return
        }
        // TODO
    }

    override fun getArea(): IArea {
        return MPSArea()
    }

    override val isValid: Boolean
        get() {
            return true
        }

    fun getWrapped(): SNode {
        return node
    }

    override val concept: IConcept
        get() {
            val sconcept: SConcept = node.concept
            val concept: IConcept? = BootstrapConceptMappings.Companion.INSTANCE.getConcept(sconcept)
            if (concept != null) {
                return concept
            }
            return SConceptAdapter(sconcept)
        }

    override fun getConceptReference(): IConceptReference {
        return concept.getReference()
    }

    override val roleInParent: String?
        get() {
            val link: IChildLink? = getContainmentLink()
            if (link == null) {
                return null
            }
            return link.key(this)
        }

    override val parent: INode?
        get() {
            notifyModelContentDependency()
            val parent: SNode? = node.parent
            if (parent != null) {
                return wrap(parent)
            }
            val model: SModel? = node.model
            if (model != null) {
                return SModelAsNode(model)
            }
            return null
        }

    override val reference: INodeReference
        get() {
            return SNodeReferenceAdapter(node.reference)
        }

    override fun getChildren(role: String?): Iterable<INode> {
        notifyModelContentDependency()
        return getChildren(this.resolveChildLink((role)!!))
    }

    override val allChildren: Iterable<INode>
        get() {
            notifyModelContentDependency()
            val children: Iterable<SNode> = node.children
            return Sequence.fromIterable(children).select(object : ISelector<SNode, INode>() {
                override fun select(it: SNode): INode {
                    val n: INode = SNodeToNodeAdapter(it)
                    return n
                }
            })
        }

    override fun moveChild(role: String?, index: Int, child: INode) {
        val link: IChildLink = this.resolveChildLink((role)!!)
        moveChild(link, index, child)
    }

    override fun addNewChild(role: String?, index: Int, concept_: IConcept?): INode {
        val links: Iterable<SContainmentLink> = node.concept.containmentLinks
        val link: SContainmentLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SContainmentLink>() {
            override fun accept(it: SContainmentLink): Boolean {
                return Objects.equals(it.name, role)
            }
        })
        if (link == null) {
            throw RuntimeException(node.concept.toString() + " has no containment link '" + role + "'")
        }
        return addNewChild(SContainmentLinkAdapter(link), index, concept_)
    }

    override fun addNewChild(role: String?, index: Int, conceptRef: IConceptReference?): INode {
        val concept: IConcept? = (if (conceptRef == null) null else resolveConcept(conceptRef))
        return addNewChild(role, index, concept)
    }

    override fun removeChild(child: INode) {
        node.removeChild(((child as SNodeToNodeAdapter).node))
    }

    override fun getReferenceTarget(role: String): INode? {
        val link: IReferenceLink = this.resolveReferenceLink(role)
        return getReferenceTarget(link)
    }

    override fun getReferenceTargetRef(role: String): INodeReference? {
        return check_8812ym_a0a14(getReferenceTarget(role), this)
    }

    override fun setReferenceTarget(role: String, target: INode?) {
        setReferenceTarget(this.resolveReferenceLink(role), target)
    }

    override fun setReferenceTarget(role: String, target: INodeReference?) {
        val targetNode: INode? = (if (target == null) null else target.resolveIn(ContextArea.getArea()!!))
        setReferenceTarget(role, targetNode)
    }

    override fun getPropertyValue(role: String): String? {
        notifyModelContentDependency()
        val properties: Iterable<SProperty> = node.properties
        val property: SProperty? = Sequence.fromIterable(properties).findFirst(object : IWhereFilter<SProperty>() {
            override fun accept(it: SProperty): Boolean {
                return Objects.equals(it.name, role)
            }
        })
        if (property == null) {
            return null
        }
        return getPropertyValue(SPropertyAdapter(property))
    }

    override fun setPropertyValue(role: String, value: String?) {
        setPropertyValue(this.resolveProperty(role), value)
    }

    override fun getPropertyRoles(): List<String> {
        val properties: Iterable<SProperty> = node.properties
        return Sequence.fromIterable(properties).select(object : ISelector<SProperty, String>() {
            override fun select(it: SProperty): String {
                return it.name
            }
        }).toListSequence()
    }

    override fun getReferenceRoles(): List<String> {
        val references: Iterable<SReference> = node.references
        return Sequence.fromIterable(references).select(object : ISelector<SReference, String>() {
            override fun select(it: SReference): String {
                return it.link.name
            }
        }).toListSequence()
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: SNodeToNodeAdapter = o as SNodeToNodeAdapter
        return !(if (node != null) !((node == that.node)) else that.node != null)
    }

    override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (node != null) (node as Any).hashCode() else 0))
        return result
    }

    override fun toString(): String {
        return "" + node
    }

    override fun usesRoleIds(): Boolean {
        return false
    }

    override fun addNewChild(role: IChildLink, index: Int, concept_: IConcept?): INode {
        val link: SContainmentLink? = (role as SContainmentLinkAdapter).getLink()
        val children_: Iterable<SNode> = node.getChildren(link)
        val children: List<SNode> = Sequence.fromIterable(children_).toListSequence()
        if (index > ListSequence.fromList(children).count()) {
            throw IndexOutOfBoundsException(index.toString() + " > " + Sequence.fromIterable(children_).count())
        }
        var concept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(concept_)
        if (concept == null) {
            concept = link!!.targetConcept
        }
        val instantiatableConcept: SConcept = MetaAdapterByDeclaration.asInstanceConcept(concept)
        val model: SModel? = node.model
        val newChild: SNode =
            (
                if (model == null) {
                    jetbrains.mps.smodel.SNode(instantiatableConcept)
                } else {
                    model.createNode(
                        instantiatableConcept,
                    )
                }
                )
        if (index == -1 || index == ListSequence.fromList(children).count()) {
            node.addChild((link)!!, newChild)
        } else {
            node.insertChildBefore((link)!!, newChild, ListSequence.fromList(children).getElement(index))
        }
        return (wrap(newChild))!!
    }

    override fun addNewChild(role: IChildLink, index: Int, conceptRef: IConceptReference?): INode {
        val concept: IConcept? = (if (conceptRef == null) null else resolveConcept(conceptRef))
        return addNewChild(role, index, concept)
    }

    override fun getChildren(link: IChildLink): Iterable<INode> {
        return Sequence.fromIterable(allChildren).where(object : IWhereFilter<INode>() {
            override fun accept(it: INode): Boolean {
                return Objects.equals(it.getContainmentLink(), link)
            }
        })
    }

    override fun getContainmentLink(): IChildLink? {
        var link: SContainmentLink? = null
        val parent: SNode? = node.parent
        if (parent != null) {
            link = node.containmentLink
        } else {
            val model: SModel? = node.model
            if (model != null) {
                link = LINKS.`rootNodes$jxXY`
            }
        }
        return (if (link == null) null else SContainmentLinkAdapter(link))
    }

    override fun getPropertyValue(property: IProperty): String? {
        return node.getProperty((property as SPropertyAdapter).property)
    }

    override fun getReferenceTarget(link: IReferenceLink): INode? {
        return wrap(node.getReferenceTarget(((link as SReferenceLinkAdapter).getLink())!!))
    }

    override fun getReferenceTargetRef(role: IReferenceLink): INodeReference? {
        return check_8812ym_a0a76(getReferenceTarget(role), this)
    }

    override fun moveChild(role: IChildLink, index: Int, child: INode) {
        val link: SContainmentLink? = (role as SContainmentLinkAdapter).getLink()
        val children_: Iterable<SNode> = node.getChildren(link)
        val children: List<SNode> = Sequence.fromIterable(children_).toListSequence()
        if (index > ListSequence.fromList(children).count()) {
            throw IndexOutOfBoundsException(index.toString() + " > " + Sequence.fromIterable(children_).count())
        }
        val schild: SNode = NodeToSNodeAdapter.wrap(child)
        if (SNodeOperations.getParent(schild) != null) {
            SNodeOperations.deleteNode(schild)
        }
        if (index == -1 || index == ListSequence.fromList(children).count()) {
            node.addChild((link)!!, (schild)!!)
        } else {
            node.insertChildBefore((link)!!, (schild)!!, ListSequence.fromList(children).getElement(index))
        }
    }

    override fun setPropertyValue(property: IProperty, value: String?) {
        node.setProperty((property as SPropertyAdapter).property, value)
    }

    override fun setReferenceTarget(link: IReferenceLink, target: INode?) {
        val snodeTarget: SNode? = NodeToSNodeAdapter.wrap(target)
        node.setReferenceTarget(((link as SReferenceLinkAdapter).getLink())!!, snodeTarget)
    }

    override fun setReferenceTarget(role: IReferenceLink, target: INodeReference?) {
        val targetNode: INode? = (if (target == null) null else target.resolveIn(ContextArea.getArea()!!))
        setReferenceTarget(role, targetNode)
    }

    private object LINKS {
        /*package*/
        val `rootNodes$jxXY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x69652614fd1c514L,
            "rootNodes",
        )
    }

    companion object {
        fun wrap(nodeToWrap: SNode?): INode? {
            if (nodeToWrap == null) {
                return null
            }
            if (nodeToWrap is NodeToSNodeAdapter) {
                return nodeToWrap.getWrapped()
            }
            return SNodeToNodeAdapter(nodeToWrap)
        }

        fun wrap(nodeToWrap: INode?): INode? {
            // Makes code generation easier. wrap can always be applied to ensure a value is an INode.
            return nodeToWrap
        }

        private fun check_8812ym_a0a14(
            checkedDotOperand: INode?,
            checkedDotThisExpression: SNodeToNodeAdapter,
        ): INodeReference? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.reference
            }
            return null
        }

        private fun check_8812ym_a0a76(
            checkedDotOperand: INode?,
            checkedDotThisExpression: SNodeToNodeAdapter,
        ): INodeReference? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.reference
            }
            return null
        }
    }
}
