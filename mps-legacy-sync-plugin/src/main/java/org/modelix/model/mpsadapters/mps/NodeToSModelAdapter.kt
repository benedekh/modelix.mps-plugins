package org.modelix.model.mpsadapters.mps

import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelId
import org.jetbrains.mps.openapi.model.SModelListener
import org.jetbrains.mps.openapi.model.SModelName
import org.jetbrains.mps.openapi.model.SModelReference
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SNodeAccessListener
import org.jetbrains.mps.openapi.model.SNodeChangeListener
import org.jetbrains.mps.openapi.model.SNodeId
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SRepository
import org.jetbrains.mps.openapi.persistence.DataSource
import org.jetbrains.mps.openapi.persistence.ModelRoot
import org.modelix.model.api.INode
import org.modelix.model.api.PNodeAdapter.Companion.wrap

/*Generated by MPS */
class NodeToSModelAdapter protected constructor(node: INode, repository: SRepository?) : SModel {
    private val node: INode?
    private val repository: SRepository?

    init {
        this.node = node
        this.repository = repository
        if (!(node.concept!!.isSubConceptOf(SConceptAdapter.Companion.wrap(CONCEPTS.`Model$2P`)))) {
            throw RuntimeException("Not a model: " + node.concept)
        }
    }

    public override fun addAccessListener(listener: SNodeAccessListener) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun addChangeListener(listener: SNodeChangeListener) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun addModelListener(listener: SModelListener) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun addRootNode(node: SNode) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun createNode(concept: SConcept): SNode {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun createNode(concept: SConcept, id: SNodeId?): SNode {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun getModelId(): SModelId {
        throw UnsupportedOperationException("Not implemented")
    }

    @Deprecated("")
    public override fun getModelName(): String {
        return getName().getValue()
    }

    public override fun getModelRoot(): ModelRoot {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun getModule(): SModule {
        return (NodeToSModuleAdapter.Companion.wrap(node!!.parent, repository))!!
    }

    public override fun getName(): SModelName {
        return SModelName((node!!.getPropertyValue(PROPS.`name$MnvL`.getName()))!!)
    }

    public override fun getNode(id: SNodeId): SNode {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun getProblems(): Iterable<SModel.Problem> {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun getReference(): SModelReference {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun getRepository(): SRepository {
        return (if (repository != null) repository else MPSModuleRepository.getInstance())
    }

    public override fun getRootNodes(): Iterable<SNode> {
        return node!!.getChildren(LINKS.`rootNodes$jxXY`.getName()).map {
            val adapter = NodeToSNodeAdapter.wrap(it)
            (adapter as? NodeToSNodeAdapter)?.setModelMode(EModelMode.ADAPTER)
            adapter
        }
    }

    public override fun getSource(): DataSource {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun isLoaded(): Boolean {
        return true
    }

    public override fun isReadOnly(): Boolean {
        return true
    }

    public override fun load() {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun removeAccessListener(listener: SNodeAccessListener) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun removeChangeListener(listener: SNodeChangeListener) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun removeModelListener(listener: SModelListener) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun removeRootNode(node: SNode) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun unload() {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: NodeToSModelAdapter = o as NodeToSModelAdapter
        if ((if (node != null) !((node == that.node)) else that.node != null)) {
            return false
        }
        return true
    }

    public override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (node != null) (node as Any).hashCode() else 0))
        return result
    }

    private object CONCEPTS {
        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model"
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name"
        )
    }

    private object LINKS {
        /*package*/
        val `rootNodes$jxXY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x69652614fd1c514L,
            "rootNodes"
        )
    }

    companion object {
        fun wrap(node: INode?, repository: SRepository?): SModel? {
            if (node == null) {
                return null
            }
            return NodeToSModelAdapter(node, repository)
        }
    }
}
