package org.modelix.model.mpsadapters.mps

import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelReference
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.area.IArea

/*Generated by MPS */
class ModelImportAsNode(importedModel: SModel, private val importingModel: SModel) :
    TreeElementAsNode<SModel>(importedModel) {
    override val concept: IConcept
        get() {
            return (SConceptAdapter.Companion.wrap(CONCEPTS.`ModelReference$sV`))!!
        }

    override fun getChildAccessor(role: String?): IChildAccessor<SModel>? {
        return super.getChildAccessor(role)
    }

    override fun getPropertyAccessor(role: String): IPropertyAccessor<SModel>? {
        return super.getPropertyAccessor(role)
    }

    override fun getReferenceAccessor(role: String): IReferenceAccessor<SModel>? {
        if ((role == LINKS.`model$GJHn`.getName())) {
            return modelAccessor
        }
        return super.getReferenceAccessor(role)
    }

    override val parent: INode
        get() {
            return SModelAsNode(importingModel)
        }
    override val roleInParent: String
        get() {
            return LINKS.`modelImports$8DOI`.getName()
        }
    override val reference: INodeReference
        get() {
            return NodeReference(element.getReference(), importingModel.getReference())
        }

    class NodeReference(val importedModelRef: SModelReference, val importingModelRef: SModelReference) :
        INodeReference {

        public override fun resolveNode(area: IArea?): INode? {
            val importedModel: SModel? = check_c5rr7l_a0a0f61(
                SModelAsNode.NodeReference(
                    importedModelRef,
                ).resolveNode(area),
            )
            if (importedModel == null) {
                return null
            }
            val importingModel: SModel? = check_c5rr7l_a0c0f61(
                SModelAsNode.NodeReference(
                    importingModelRef,
                ).resolveNode(area),
            )
            if (importingModel == null) {
                return null
            }
            return ModelImportAsNode(importedModel, importingModel)
        }

        public override fun equals(o: Any?): Boolean {
            if (this === o) {
                return true
            }
            if (o == null || this.javaClass != o.javaClass) {
                return false
            }
            val that: NodeReference = o as NodeReference
            if ((if (importedModelRef != null) !((importedModelRef == that.importedModelRef)) else that.importedModelRef != null)) {
                return false
            }
            if ((if (importingModelRef != null) !((importingModelRef == that.importingModelRef)) else that.importingModelRef != null)) {
                return false
            }
            return true
        }

        public override fun hashCode(): Int {
            var result: Int = 0
            result = 31 * result + ((if (importedModelRef != null) (importedModelRef as Any).hashCode() else 0))
            result = 31 * result + ((if (importingModelRef != null) (importingModelRef as Any).hashCode() else 0))
            return result
        }

        companion object {
            private fun check_c5rr7l_a0a0f61(checkedDotOperand: SModelAsNode?): SModel? {
                if (null != checkedDotOperand) {
                    return checkedDotOperand.element
                }
                return null
            }

            private fun check_c5rr7l_a0c0f61(checkedDotOperand: SModelAsNode?): SModel? {
                if (null != checkedDotOperand) {
                    return checkedDotOperand.element
                }
                return null
            }
        }
    }

    private object CONCEPTS {
        /*package*/
        val `ModelReference$sV`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x58dbe6e4d4f332a3L,
            "org.modelix.model.repositoryconcepts.structure.ModelReference",
        )
    }

    private object LINKS {
        /*package*/
        val `model$GJHn`: SReferenceLink = MetaAdapterFactory.getReferenceLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x58dbe6e4d4f332a3L,
            0x58dbe6e4d4f332a4L,
            "model",
        )

        /*package*/
        val `modelImports$8DOI`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x58dbe6e4d4f32eb8L,
            "modelImports",
        )
    }

    companion object {
        private val modelAccessor: IReferenceAccessor<SModel> = object : IReferenceAccessor<SModel> {
            public override fun get(element: SModel): INode? {
                return SModelAsNode.wrap(element)
            }

            public override fun set(element: SModel, target: INode?): INode? {
                throw UnsupportedOperationException("Read only")
            }
        }
    }
}
