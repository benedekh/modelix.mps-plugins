package org.modelix.model.mpsadapters.mps

import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.ILanguageRepository.Companion.resolveConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.area.IArea

/*Generated by MPS */
abstract class TreeElementAsNode<E : Any>(val element: E) : INode {

    override fun getConceptReference(): IConceptReference? {
        return concept.getReference()
    }

    abstract override val concept: IConcept
    override fun getArea(): IArea {
        return MPSArea()
    }

    override val isValid: Boolean
        get() {
            return true
        }

    protected open fun getPropertyAccessor(role: String): IPropertyAccessor<E>? {
        if ((role == PROPS.`shortDescription$Yd4v`.name)) {
            return dummyPropertyAccessor as IPropertyAccessor<E>
        }
        if ((role == PROPS.`virtualPackage$EkXl`.name)) {
            return dummyPropertyAccessor as IPropertyAccessor<E>
        }
        return null
    }

    protected open fun getChildAccessor(role: String?): IChildAccessor<E>? {
        if ((role == LINKS.`smodelAttribute$KJ43`.name)) {
            return dummyChildAccessor as IChildAccessor<E>
        }
        return null
    }

    protected open fun getReferenceAccessor(role: String): IReferenceAccessor<E>? {
        return null
    }

    override fun moveChild(role: String?, index: Int, node: INode) {
        throw UnsupportedOperationException()
    }

    override fun addNewChild(role: String?, index: Int, concept: IConcept?): INode {
        val accessor = getChildAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for child '" + role + "' in " + this.javaClass.getCanonicalName())
        }
        return accessor.add(element, (role)!!, index, concept)
    }

    override fun addNewChild(role: String?, index: Int, conceptRef: IConceptReference?): INode {
        val concept: IConcept? = (if (conceptRef == null) null else resolveConcept(conceptRef))
        return addNewChild(role, index, concept)
    }

    override fun removeChild(child: INode) {
        val role: String? = child.roleInParent
        val accessor = getChildAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for child '" + role + "' in " + this.javaClass.getCanonicalName())
        }
        accessor.remove(element, child)
    }

    override val allChildren: Iterable<INode>
        get() {
            val concept: IConcept = concept
            if (concept == null) {
                return emptyList()
            }
            val links: Iterable<IChildLink> = concept.getAllChildLinks()
            return Sequence.fromIterable(links).select(object : ISelector<IChildLink, IChildAccessor<E>?>() {
                override fun select(it: IChildLink): IChildAccessor<E>? {
                    return getChildAccessor(it.name)
                }
            }).translate(object : ITranslator2<IChildAccessor<E>, INode>() {
                override fun translate(it: IChildAccessor<E>): Iterable<INode> {
                    return it.get(element)
                }
            })
        }

    override fun getChildren(role: String?): Iterable<INode> {
        val accessor = getChildAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for child '" + role + "' in " + this.javaClass.getCanonicalName())
        }
        return accessor.get(element)
    }

    override fun getPropertyValue(role: String): String? {
        val accessor = getPropertyAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for property '" + role + "'")
        }
        return accessor.get(element)
    }

    override fun getReferenceTarget(role: String): INode? {
        val accessor = getReferenceAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for reference '" + role + "'")
        }
        return accessor.get(element)
    }

    override fun getReferenceTargetRef(role: String): INodeReference? {
        return getReferenceTarget(role)?.reference
    }

    override fun setPropertyValue(role: String, value: String?) {
        val accessor = getPropertyAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for property '" + role + "'")
        }
        accessor.set(element, value)
    }

    override fun setReferenceTarget(role: String, target: INode?) {
        throw UnsupportedOperationException()
    }

    override fun setReferenceTarget(role: String, target: INodeReference?) {
        throw UnsupportedOperationException()
    }

    override fun getPropertyRoles(): List<String> {
        val concept: IConcept = concept
        if (concept == null) {
            return emptyList()
        }
        val allProperties: List<IProperty> = concept.getAllProperties()
        return ListSequence.fromList(allProperties).select(object : ISelector<IProperty, String>() {
            override fun select(it: IProperty): String {
                return it.name
            }
        }).toListSequence()
    }

    override fun getReferenceRoles(): List<String> {
        val concept: IConcept = concept
        if (concept == null) {
            return emptyList()
        }
        val allReferenceLinks: List<IReferenceLink> = concept.getAllReferenceLinks()
        return ListSequence.fromList(allReferenceLinks).select(object : ISelector<IReferenceLink, String>() {
            override fun select(it: IReferenceLink): String {
                return it.name
            }
        }).toListSequence()
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: TreeElementAsNode<*> = o as TreeElementAsNode<*>
        return !(if (element != null) !(((element as Any) == that.element)) else that.element != null)
    }

    override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (element != null) (element as Any).hashCode() else 0))
        return result
    }

    open interface IPropertyAccessor<E> {
        operator fun get(element: E): String?
        operator fun set(element: E, value: String?): String?
    }

    open interface IChildAccessor<E> {
        operator fun get(element: E): Iterable<INode>
        fun add(element: E, role: String, index: Int, concept: IConcept?): INode {
            throw UnsupportedOperationException("Cannot add child in role " + role)
        }

        fun remove(element: E, childToRemove: INode) {
            throw UnsupportedOperationException("Cannot remove child " + childToRemove)
        }
    }

    open interface IReferenceAccessor<E> {
        operator fun get(element: E): INode?
        operator fun set(element: E, target: INode?): INode?
    }

    override fun toString(): String {
        return javaClass.getSimpleName() + "[" + element + "]"
    }

    private object PROPS {
        /*package*/
        val `shortDescription$Yd4v`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x10d34f97574L,
            "shortDescription",
        )

        /*package*/
        val `virtualPackage$EkXl`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x115eca8579fL,
            "virtualPackage",
        )
    }

    private object LINKS {
        /*package*/
        val `smodelAttribute$KJ43`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x47bf8397520e5942L,
            "smodelAttribute",
        )
    }

    companion object {
        protected var dummyPropertyAccessor: IPropertyAccessor<*> = object : IPropertyAccessor<Any?> {
            override fun get(element: Any?): String? {
                return null
            }

            override fun set(element: Any?, value: String?): String? {
                throw UnsupportedOperationException()
            }
        }
        protected var dummyChildAccessor: IChildAccessor<*> = object : IChildAccessor<Any?> {
            override fun get(element: Any?): Iterable<INode> {
                return Sequence.fromIterable(emptyList())
            }
        }
    }
}
