package org.modelix.model.mpsadapters.mps

import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.ILanguageRepository.Companion.resolveConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.area.IArea

/*Generated by MPS */
abstract class TreeElementAsNode<E : Any>(val element: E) : INode {

    public override fun getConceptReference(): IConceptReference? {
        return concept.getReference()
    }

    abstract override val concept: IConcept
    public override fun getArea(): IArea {
        return MPSArea()
    }

    override val isValid: Boolean
        get() {
            return true
        }

    protected open fun getPropertyAccessor(role: String): IPropertyAccessor<E>? {
        if ((role == PROPS.`shortDescription$Yd4v`.getName())) {
            return dummyPropertyAccessor as IPropertyAccessor<E>
        }
        if ((role == PROPS.`virtualPackage$EkXl`.getName())) {
            return dummyPropertyAccessor as IPropertyAccessor<E>
        }
        return null
    }

    protected open fun getChildAccessor(role: String?): IChildAccessor<E>? {
        if ((role == LINKS.`smodelAttribute$KJ43`.getName())) {
            return dummyChildAccessor as IChildAccessor<E>
        }
        return null
    }

    protected open fun getReferenceAccessor(role: String): IReferenceAccessor<E>? {
        return null
    }

    public override fun moveChild(role: String?, index: Int, node: INode) {
        throw UnsupportedOperationException()
    }

    public override fun addNewChild(role: String?, index: Int, concept: IConcept?): INode {
        val accessor = getChildAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for child '" + role + "' in " + this.javaClass.getCanonicalName())
        }
        return accessor.add(element, (role)!!, index, concept)
    }

    public override fun addNewChild(role: String?, index: Int, conceptRef: IConceptReference?): INode {
        val concept: IConcept? = (if (conceptRef == null) null else resolveConcept(conceptRef))
        return addNewChild(role, index, concept)
    }

    public override fun removeChild(child: INode) {
        val role: String? = child.roleInParent
        val accessor = getChildAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for child '" + role + "' in " + this.javaClass.getCanonicalName())
        }
        accessor.remove(element, child)
    }

    override val allChildren: Iterable<INode>
        get() {
            val concept: IConcept? = concept
            if (concept == null) {
                return emptyList()
            }
            val links: Iterable<IChildLink> = concept.getAllChildLinks()
            return Sequence.fromIterable(links).select(object : ISelector<IChildLink, IChildAccessor<E>?>() {
                public override fun select(it: IChildLink): IChildAccessor<E>? {
                    return getChildAccessor(it.name)
                }
            }).translate(object : ITranslator2<IChildAccessor<E>, INode>() {
                public override fun translate(it: IChildAccessor<E>): Iterable<INode> {
                    return it.get(element)
                }
            })
        }

    public override fun getChildren(role: String?): Iterable<INode> {
        val accessor = getChildAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for child '" + role + "' in " + this.javaClass.getCanonicalName())
        }
        return accessor.get(element)
    }

    public override fun getPropertyValue(role: String): String? {
        val accessor = getPropertyAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for property '" + role + "'")
        }
        return accessor.get(element)
    }

    public override fun getReferenceTarget(role: String): INode? {
        val accessor = getReferenceAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for reference '" + role + "'")
        }
        return accessor.get(element)
    }

    public override fun getReferenceTargetRef(role: String): INodeReference? {
        return getReferenceTarget(role)?.reference
    }

    public override fun setPropertyValue(role: String, value: String?) {
        val accessor = getPropertyAccessor(role)
        if (accessor == null) {
            throw RuntimeException("No accessor defined for property '" + role + "'")
        }
        accessor.set(element, value)
    }

    public override fun setReferenceTarget(role: String, target: INode?) {
        throw UnsupportedOperationException()
    }

    public override fun setReferenceTarget(role: String, target: INodeReference?) {
        throw UnsupportedOperationException()
    }

    public override fun getPropertyRoles(): List<String> {
        val concept: IConcept? = concept
        if (concept == null) {
            return emptyList()
        }
        val allProperties: List<IProperty> = concept.getAllProperties()
        return ListSequence.fromList(allProperties).select(object : ISelector<IProperty, String>() {
            public override fun select(it: IProperty): String {
                return it.name
            }
        }).toListSequence()
    }

    public override fun getReferenceRoles(): List<String> {
        val concept: IConcept? = concept
        if (concept == null) {
            return emptyList()
        }
        val allReferenceLinks: List<IReferenceLink> = concept.getAllReferenceLinks()
        return ListSequence.fromList(allReferenceLinks).select(object : ISelector<IReferenceLink, String>() {
            public override fun select(it: IReferenceLink): String {
                return it.name
            }
        }).toListSequence()
    }

    public override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: TreeElementAsNode<*> = o as TreeElementAsNode<*>
        if ((if (element != null) !(((element as Any) == that.element)) else that.element != null)) {
            return false
        }
        return true
    }

    public override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (element != null) (element as Any).hashCode() else 0))
        return result
    }

    open interface IPropertyAccessor<E> {
        operator fun get(element: E): String?
        operator fun set(element: E, value: String?): String?
    }

    open interface IChildAccessor<E> {
        operator fun get(element: E): Iterable<INode>
        fun add(element: E, role: String, index: Int, concept: IConcept?): INode {
            throw UnsupportedOperationException("Cannot add child in role " + role)
        }

        fun remove(element: E, childToRemove: INode) {
            throw UnsupportedOperationException("Cannot remove child " + childToRemove)
        }
    }

    open interface IReferenceAccessor<E> {
        operator fun get(element: E): INode?
        operator fun set(element: E, target: INode?): INode?
    }

    public override fun toString(): String {
        return javaClass.getSimpleName() + "[" + element + "]"
    }

    private object PROPS {
        /*package*/
        val `shortDescription$Yd4v`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x10d34f97574L,
            "shortDescription"
        )

        /*package*/
        val `virtualPackage$EkXl`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x115eca8579fL,
            "virtualPackage"
        )
    }

    private object LINKS {
        /*package*/
        val `smodelAttribute$KJ43`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x47bf8397520e5942L,
            "smodelAttribute"
        )
    }

    companion object {
        protected var dummyPropertyAccessor: IPropertyAccessor<*> = object : IPropertyAccessor<Any?> {
            public override fun get(element: Any?): String? {
                return null
            }

            public override fun set(element: Any?, value: String?): String? {
                throw UnsupportedOperationException()
            }
        }
        protected var dummyChildAccessor: IChildAccessor<*> = object : IChildAccessor<Any?> {
            public override fun get(element: Any?): Iterable<INode> {
                return Sequence.fromIterable(emptyList())
            }
        }
    }
}
