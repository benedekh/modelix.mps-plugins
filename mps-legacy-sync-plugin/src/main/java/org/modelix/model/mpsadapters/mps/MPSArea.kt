package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.smodel.GlobalModelAccess
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.ids.SConceptId
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.smodel.language.ConceptRegistry
import jetbrains.mps.smodel.runtime.ConceptDescriptor
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.module.ModelAccess
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.ConceptReference
import org.modelix.model.api.IBranch
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.IArea
import org.modelix.model.area.IAreaListener
import org.modelix.model.area.IAreaReference
import java.util.Objects

/*Generated by MPS */
class MPSArea @JvmOverloads constructor(repository: SRepository? = MPSModuleRepository.getInstance()) :
    IArea,
    IAreaReference {
    val repository: SRepository = repository ?: MPSModuleRepository.getInstance()

    override fun getLockOrderingPriority(): Long {
        return 100L shl 32
    }

    override fun getReference(): IAreaReference {
        return this
    }

    override fun resolveConcept(reference: IConceptReference): IConcept? {
        if (!(reference is ConceptReference)) {
            return null
        }
        var uid: String = reference.uid
        if (uid.startsWith("mps:")) {
            uid = uid.substring(4)
        }
        val conceptId: SConceptId?
        try {
            conceptId = SConceptId.deserialize(uid)
        } catch (ex: Exception) {
            return null
        }
        if (conceptId == null) {
            return null
        }
        val conceptDescriptor: ConceptDescriptor = ConceptRegistry.getInstance().getConceptDescriptor(conceptId)
        if (conceptDescriptor is IllegalConceptDescriptor) {
            return null
        }
        return SConceptAdapter.Companion.wrap(MetaAdapterFactory.getAbstractConcept(conceptDescriptor))
    }

    override fun resolveArea(reference: IAreaReference): IArea? {
        return (if (Objects.equals(reference, this)) this else null)
    }

    override fun canRead(): Boolean {
        return repository.modelAccess.canRead()
    }

    override fun canWrite(): Boolean {
        return repository.modelAccess.canWrite()
    }

    override fun <T> executeRead(f: () -> T): T {
        val result: _T<T> = _T()
        repository.modelAccess.runReadAction(object : Runnable {
            override fun run() {
                result.value = f.invoke()
            }
        })
        return result.value
    }

    override fun <T> executeWrite(f: () -> T): T {
        val result: _T<T> = _T()
        val modelAccess: ModelAccess = repository.modelAccess
        if (modelAccess is GlobalModelAccess) {
            modelAccess.runWriteAction(object : Runnable {
                override fun run() {
                    result.value = f.invoke()
                }
            })
        } else {
            modelAccess.executeCommand(object : Runnable {
                override fun run() {
                    result.value = f.invoke()
                }
            })
        }
        return result.value
    }

    override fun getRoot(): INode {
        return SRepositoryAsNode(repository)
    }

    override fun addListener(listener: IAreaListener) {
        throw UnsupportedOperationException("Not implemented yet")
    }

    override fun removeListener(listener: IAreaListener) {
        throw UnsupportedOperationException("Not implemented yet")
    }

    override fun resolveNode(reference: INodeReference): INode? {
        return resolveOriginalNode(reference)
    }

    override fun resolveOriginalNode(reference: INodeReference): INode? {
        if (reference is SNodeReferenceAdapter) {
            val mpsNode: SNode? = reference.getReference()!!
                .resolve(
                    repository,
                )
            return SNodeToNodeAdapter.Companion.wrap(mpsNode)
        }
        return null
    }

    override fun resolveBranch(id: String): IBranch? {
        return null
    }

    override fun collectAreas(): List<IArea> {
        return listOf<IArea>(this)
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: MPSArea = o as MPSArea
        return !(if (repository != null) !((repository == that.repository)) else that.repository != null)
    }

    override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (repository != null) (repository as Any).hashCode() else 0))
        return result
    }
}
