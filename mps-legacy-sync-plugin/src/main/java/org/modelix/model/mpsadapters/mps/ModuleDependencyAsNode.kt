package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P1_E0
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.LinkedListSequence
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.module.SDependencyScope
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleId
import org.jetbrains.mps.openapi.module.SModuleReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.IArea
import java.util.LinkedList
import java.util.Objects

/*Generated by MPS */
class ModuleDependencyAsNode(
    private val moduleReference: SModuleReference,
    private val moduleVersion: Int,
    private val explicit: Boolean,
    private val reexport: Boolean,
    private val importer: SModule?,
    private val dependencyScope: SDependencyScope?
) : INode {
    public override fun getConceptReference(): IConceptReference? {
        return concept!!.getReference()
    }

    public override fun getArea(): IArea {
        return MPSArea()
    }

    public override val isValid: Boolean
        get() {
            return true
        }

    public override val reference: INodeReference
        get() {
            return NodeReference(importer!!.getModuleReference(), moduleReference.getModuleId())
        }

    public override val concept: IConcept?
        get() {
            return SConceptAdapter.Companion.wrap(CONCEPTS.`ModuleDependency$kc`)
        }

    public override val roleInParent: String?
        get() {
            return LINKS.`dependencies$vC8r`.getName()
        }

    public override val parent: INode?
        get() {
            return SModuleAsNode.Companion.wrap(importer)
        }

    public override fun getChildren(role: String?): Iterable<INode> {
        return LinkedListSequence.fromLinkedListNew(LinkedList())
    }

    public override val allChildren: Iterable<INode>
        get() {
            val concept: IConcept? = concept
            if (concept == null) {
                return emptyList()
            }
            val links: Iterable<IChildLink> = concept.getAllChildLinks()
            return Sequence.fromIterable(links).select(object : ISelector<IChildLink, Iterable<INode>>() {
                public override fun select(it: IChildLink): Iterable<INode> {
                    return getChildren(it.name)
                }
            }).translate(object : ITranslator2<Iterable<INode>, INode>() {
                public override fun translate(it: Iterable<INode>): Iterable<INode> {
                    return it
                }
            })
        }

    public override fun moveChild(string: String?, i: Int, node: INode) {
        throw UnsupportedOperationException()
    }

    public override fun addNewChild(string: String?, i: Int, concept: IConcept?): INode {
        throw UnsupportedOperationException()
    }

    public override fun addNewChild(string: String?, i: Int, reference: IConceptReference?): INode {
        throw UnsupportedOperationException()
    }

    public override fun removeChild(node: INode) {
        throw UnsupportedOperationException()
    }

    public override fun getReferenceTarget(role: String): INode? {
        return null
    }

    public override fun getReferenceTargetRef(string: String): INodeReference? {
        return null
    }

    public override fun setReferenceTarget(string: String, node: INode?) {
        throw UnsupportedOperationException()
    }

    public override fun setReferenceTarget(string: String, reference: INodeReference?) {
        throw UnsupportedOperationException()
    }

    public override fun getPropertyValue(propertyName: String): String? {
        if (Objects.equals(PROPS.`explicit$yR_K`.getName(), propertyName)) {
            return explicit.toString()
        } else if (Objects.equals(PROPS.`name$Ahsh`.getName(), propertyName)) {
            return moduleReference.getModuleName()
        } else if (Objects.equals(PROPS.`reexport$AblR`.getName(), propertyName)) {
            return reexport.toString()
        } else if (Objects.equals(PROPS.`uuid$AbNT`.getName(), propertyName)) {
            return moduleReference.getModuleId().toString()
        } else if (Objects.equals(PROPS.`version$yXGa`.getName(), propertyName)) {
            return moduleVersion.toString()
        } else if (Objects.equals(PROPS.`scope$mJmq`.getName(), propertyName)) {
            if (dependencyScope == null) {
                return "UNSPECIFIED"
            }
            return dependencyScope.toString()
        } else {
            return null
        }
    }

    public override fun setPropertyValue(string: String, string1: String?) {
        throw UnsupportedOperationException()
    }

    public override fun getPropertyRoles(): List<String> {
        val concept: IConcept? = concept
        if (concept == null) {
            return emptyList()
        }
        val allProperties: List<IProperty> = concept.getAllProperties()
        return ListSequence.fromList(allProperties).select(object : ISelector<IProperty, String>() {
            public override fun select(it: IProperty): String {
                return it.name
            }
        }).toListSequence()
    }

    public override fun getReferenceRoles(): List<String> {
        val concept: IConcept? = concept
        if (concept == null) {
            return emptyList()
        }
        val allReferenceLinks: List<IReferenceLink> = concept.getAllReferenceLinks()
        return ListSequence.fromList(allReferenceLinks).select(object : ISelector<IReferenceLink, String>() {
            public override fun select(it: IReferenceLink): String {
                return it.name
            }
        }).toListSequence()
    }

    class NodeReference(private val userModuleReference: SModuleReference?, private val usedModuleId: SModuleId?) :
        INodeReference {
        public override fun serialize(): String {
            return "mps-module-dep:" + usedModuleId + "#IN#" + userModuleReference
        }

        public override fun resolveNode(area: IArea?): INode? {
            var repo: SRepository? = null
            if (area != null) {
                val areas: List<IArea> = area.collectAreas()
                repo = areas.filterIsInstance<MPSArea>().map { it.repository }.filterNotNull().firstOrNull()
            }
            if (repo == null) {
                repo = MPSModuleRepository.getInstance()
            }
            val user: SModule? = userModuleReference!!.resolve((repo)!!)
            if (user == null) {
                return null
            }
            return SModuleAsNode(user).findDependency(usedModuleId)
        }

        public override fun equals(o: Any?): Boolean {
            if (this === o) {
                return true
            }
            if (o == null || this.javaClass != o.javaClass) {
                return false
            }
            val that: NodeReference = o as NodeReference
            if (Objects.equals(userModuleReference, that.userModuleReference)) {
                return false
            }
            if (Objects.equals(usedModuleId, that.usedModuleId)) {
                return false
            }
            return true
        }

        public override fun hashCode(): Int {
            var result: Int = 0
            result = 31 * result + ((if (userModuleReference != null) (userModuleReference as Any).hashCode() else 0))
            result = 11 * result + ((if (usedModuleId != null) (usedModuleId as Any).hashCode() else 0))
            return result
        }
    }

    private object CONCEPTS {
        /*package*/
        val `ModuleDependency$kc`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            "org.modelix.model.repositoryconcepts.structure.ModuleDependency"
        )
    }

    private object LINKS {
        /*package*/
        val `dependencies$vC8r`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299179L,
            "dependencies"
        )
    }

    private object PROPS {
        /*package*/
        val `explicit$yR_K`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535315265L,
            "explicit"
        )

        /*package*/
        val `name$Ahsh`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535299175L,
            "name"
        )

        /*package*/
        val `reexport$AblR`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535299170L,
            "reexport"
        )

        /*package*/
        val `uuid$AbNT`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535299172L,
            "uuid"
        )

        /*package*/
        val `version$yXGa`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde953531526aL,
            "version"
        )

        /*package*/
        val `scope$mJmq`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x751b3543f508b8f9L,
            "scope"
        )
    }
}
