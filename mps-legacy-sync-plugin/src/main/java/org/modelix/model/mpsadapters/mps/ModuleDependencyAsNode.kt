package org.modelix.model.mpsadapters.mps

import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.LinkedListSequence
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.module.SDependencyScope
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleId
import org.jetbrains.mps.openapi.module.SModuleReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.IArea
import java.util.LinkedList
import java.util.Objects

/*Generated by MPS */
class ModuleDependencyAsNode(
    private val moduleReference: SModuleReference,
    private val moduleVersion: Int,
    private val explicit: Boolean,
    private val reexport: Boolean,
    private val importer: SModule?,
    private val dependencyScope: SDependencyScope?,
) : INode {
    override fun getConceptReference(): IConceptReference {
        return concept!!.getReference()
    }

    override fun getArea(): IArea {
        return MPSArea()
    }

    override val isValid: Boolean
        get() {
            return true
        }

    override val reference: INodeReference
        get() {
            return NodeReference(importer!!.moduleReference, moduleReference.moduleId)
        }

    override val concept: IConcept
        get() {
            return SConceptAdapter.Companion.wrap(CONCEPTS.`ModuleDependency$kc`)
        }

    override val roleInParent: String
        get() {
            return LINKS.`dependencies$vC8r`.name
        }

    override val parent: INode?
        get() {
            return SModuleAsNode.Companion.wrap(importer)
        }

    override fun getChildren(role: String?): Iterable<INode> {
        return LinkedListSequence.fromLinkedListNew(LinkedList())
    }

    override val allChildren: Iterable<INode>
        get() {
            val concept: IConcept? = concept
            if (concept == null) {
                return emptyList()
            }
            val links: Iterable<IChildLink> = concept.getAllChildLinks()
            return Sequence.fromIterable(links).select(object : ISelector<IChildLink, Iterable<INode>>() {
                override fun select(it: IChildLink): Iterable<INode> {
                    return getChildren(it.name)
                }
            }).translate(object : ITranslator2<Iterable<INode>, INode>() {
                override fun translate(it: Iterable<INode>): Iterable<INode> {
                    return it
                }
            })
        }

    override fun moveChild(string: String?, i: Int, node: INode) {
        throw UnsupportedOperationException()
    }

    override fun addNewChild(string: String?, i: Int, concept: IConcept?): INode {
        throw UnsupportedOperationException()
    }

    override fun addNewChild(string: String?, i: Int, reference: IConceptReference?): INode {
        throw UnsupportedOperationException()
    }

    override fun removeChild(node: INode) {
        throw UnsupportedOperationException()
    }

    override fun getReferenceTarget(role: String): INode? {
        return null
    }

    override fun getReferenceTargetRef(string: String): INodeReference? {
        return null
    }

    override fun setReferenceTarget(string: String, node: INode?) {
        throw UnsupportedOperationException()
    }

    override fun setReferenceTarget(string: String, reference: INodeReference?) {
        throw UnsupportedOperationException()
    }

    override fun getPropertyValue(propertyName: String): String? {
        if (Objects.equals(PROPS.`explicit$yR_K`.name, propertyName)) {
            return explicit.toString()
        } else if (Objects.equals(PROPS.`name$Ahsh`.name, propertyName)) {
            return moduleReference.moduleName
        } else if (Objects.equals(PROPS.`reexport$AblR`.name, propertyName)) {
            return reexport.toString()
        } else if (Objects.equals(PROPS.`uuid$AbNT`.name, propertyName)) {
            return moduleReference.moduleId.toString()
        } else if (Objects.equals(PROPS.`version$yXGa`.name, propertyName)) {
            return moduleVersion.toString()
        } else if (Objects.equals(PROPS.`scope$mJmq`.name, propertyName)) {
            if (dependencyScope == null) {
                return "UNSPECIFIED"
            }
            return dependencyScope.toString()
        } else {
            return null
        }
    }

    override fun setPropertyValue(string: String, string1: String?) {
        throw UnsupportedOperationException()
    }

    override fun getPropertyRoles(): List<String> {
        val concept: IConcept? = concept
        if (concept == null) {
            return emptyList()
        }
        val allProperties: List<IProperty> = concept.getAllProperties()
        return ListSequence.fromList(allProperties).select(object : ISelector<IProperty, String>() {
            override fun select(it: IProperty): String {
                return it.name
            }
        }).toListSequence()
    }

    override fun getReferenceRoles(): List<String> {
        val concept: IConcept? = concept
        if (concept == null) {
            return emptyList()
        }
        val allReferenceLinks: List<IReferenceLink> = concept.getAllReferenceLinks()
        return ListSequence.fromList(allReferenceLinks).select(object : ISelector<IReferenceLink, String>() {
            override fun select(it: IReferenceLink): String {
                return it.name
            }
        }).toListSequence()
    }

    class NodeReference(private val userModuleReference: SModuleReference?, private val usedModuleId: SModuleId?) :
        INodeReference {
        override fun serialize(): String {
            return "mps-module-dep:" + usedModuleId + "#IN#" + userModuleReference
        }

        override fun resolveNode(area: IArea?): INode? {
            var repo: SRepository? = null
            if (area != null) {
                val areas: List<IArea> = area.collectAreas()
                repo = areas.filterIsInstance<MPSArea>().map { it.repository }.filterNotNull().firstOrNull()
            }
            if (repo == null) {
                repo = MPSModuleRepository.getInstance()
            }
            val user: SModule? = userModuleReference!!.resolve((repo)!!)
            if (user == null) {
                return null
            }
            return SModuleAsNode(user).findDependency(usedModuleId)
        }

        override fun equals(o: Any?): Boolean {
            if (this === o) {
                return true
            }
            if (o == null || this.javaClass != o.javaClass) {
                return false
            }
            val that: NodeReference = o as NodeReference
            if (Objects.equals(userModuleReference, that.userModuleReference)) {
                return false
            }
            if (Objects.equals(usedModuleId, that.usedModuleId)) {
                return false
            }
            return true
        }

        override fun hashCode(): Int {
            var result: Int = 0
            result = 31 * result + ((if (userModuleReference != null) (userModuleReference as Any).hashCode() else 0))
            result = 11 * result + ((if (usedModuleId != null) (usedModuleId as Any).hashCode() else 0))
            return result
        }
    }

    private object CONCEPTS {
        /*package*/
        val `ModuleDependency$kc`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            "org.modelix.model.repositoryconcepts.structure.ModuleDependency",
        )
    }

    private object LINKS {
        /*package*/
        val `dependencies$vC8r`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299179L,
            "dependencies",
        )
    }

    private object PROPS {
        /*package*/
        val `explicit$yR_K`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535315265L,
            "explicit",
        )

        /*package*/
        val `name$Ahsh`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535299175L,
            "name",
        )

        /*package*/
        val `reexport$AblR`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535299170L,
            "reexport",
        )

        /*package*/
        val `uuid$AbNT`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde9535299172L,
            "uuid",
        )

        /*package*/
        val `version$yXGa`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x1e9fde953531526aL,
            "version",
        )

        /*package*/
        val `scope$mJmq`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x1e9fde953529916fL,
            0x751b3543f508b8f9L,
            "scope",
        )
    }
}
