package org.modelix.model.mpsadapters.mps

import com.google.common.collect.MapMaker
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.util.Computable
import jetbrains.mps.util.IterableUtil
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SInterfaceConcept
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.ResolveInfo
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelReference
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SNodeId
import org.jetbrains.mps.openapi.model.SNodeReference
import org.jetbrains.mps.openapi.model.SReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.ContextValue
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.api.getAncestor
import org.modelix.model.lazy.unwrap
import java.util.Objects

/*Generated by MPS */
class NodeToSNodeAdapter protected constructor(val node: INode, repository: SRepository?) : SNode {
    class InstancesCache() {
        val instances: MutableMap<Tuples._2<INode, SRepository?>, NodeToSNodeAdapter> =
            MapMaker().weakValues().makeMap()
    }

    private val repository: SRepository?
    private var userObjects: Array<Any?>? = null
    private val nodeReference: NodeReference = NodeReference()
    private val nodeId: NodeId = NodeId()
    private var modelMode: EModelMode = EModelMode.NULL

    init {
        requireNotNull(node.concept) { "Node has no concept: " + node }
        this.repository = repository
    }

    fun setModelMode(mode: EModelMode) {
        modelMode = mode
    }

    protected fun wrap_(nodeToWrap: INode?): SNode {
        val wrapped: SNode? = wrap(nodeToWrap, repository)
        if (wrapped is NodeToSNodeAdapter) {
            wrapped.setModelMode(modelMode)
        }
        return (wrapped)!!
    }

    fun getWrapped(): INode? {
        return node
    }

    public override fun getModel(): SModel? {
        when (modelMode) {
            EModelMode.NULL -> return null
            EModelMode.ADAPTER -> {
                val modelNode: INode? = node.getAncestor(SConceptAdapter.Companion.wrap(CONCEPTS.`Model$2P`), false)
                if (modelNode == null) {
                    return null
                }
                return NodeToSModelAdapter.Companion.wrap(modelNode, repository)
            }

            else -> throw RuntimeException("Unknown mode: " + modelMode)
        }
    }

    public override fun getNodeId(): SNodeId {
        return nodeId
    }

    public override fun getReference(): SNodeReference {
        return nodeReference
    }

    public override fun getConcept(): SConcept {
        val concept: IConcept? = node!!.concept
        if (concept is SConceptAdapter) {
            return concept.adapted as SConcept
        }
        val sConcept: SAbstractConcept? = BootstrapConceptMappings.Companion.INSTANCE.getSConcept(concept)
        if (sConcept is SConcept) {
            return sConcept
        }
        return CONCEPTS.`BaseConcept$gP`
    }

    public override fun isInstanceOfConcept(concept: SAbstractConcept): Boolean {
        return getConcept().isSubConceptOf(concept)
    }

    public override fun getPresentation(): String {
        val snode: SNode = this
        var presentation: String? = null
        try {
            presentation = node.toString() // BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(snode);
        } catch (ex: Exception) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("", ex)
            }
        }
        try {
            if (presentation == null && isInstanceOfConcept(CONCEPTS.`INamedConcept$Kd`)) {
                presentation = getProperty(PROPS.`name$MnvL`)
            }
        } catch (ex: Exception) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("", ex)
            }
        }
        if (presentation == null) {
            presentation = toString()
        }
        return presentation
    }

    public override fun getName(): String? {
        return node!!.getPropertyValue("name")
    }

    public override fun addChild(link: SContainmentLink, child: SNode) {
        node!!.moveChild(SContainmentLinkAdapter(link), -1, (SNodeToNodeAdapter.Companion.wrap(child))!!)
    }

    public override fun insertChildBefore(link: SContainmentLink, child: SNode, anchor: SNode?) {
        if (anchor == null) {
            addChild(link, child)
            return
        }
        val index: Int = Sequence.fromIterable(getChildren(link)).indexOf(anchor)
        node!!.moveChild(SContainmentLinkAdapter(link), index, (SNodeToNodeAdapter.Companion.wrap(child))!!)
    }

    public override fun insertChildAfter(link: SContainmentLink, child: SNode, anchor: SNode?) {
        if (anchor == null) {
            addChild(link, child)
            return
        }
        val index: Int = Sequence.fromIterable(getChildren(link)).indexOf(anchor)
        node!!.moveChild(SContainmentLinkAdapter(link), index + 1, (SNodeToNodeAdapter.Companion.wrap(child))!!)
    }

    public override fun removeChild(node: SNode) {
        this.node!!.removeChild((SNodeToNodeAdapter.Companion.wrap(node))!!)
    }

    public override fun delete() {
        node!!.parent!!.removeChild((node))
    }

    public override fun getParent(): SNode? {
        val parent: INode? = node!!.parent
        if (parent == null) {
            return null
        }
        if (parent.concept == null) {
            return null
        }
        val result: SNode = wrap_(parent)
        return result
    }

    public override fun getContainingRoot(): SNode {
        var n1: INode?
        var n2: INode? = node
        do {
            n1 = n2
            n2 = n1!!.parent
        } while (n2 != null)
        return wrap_(n1)
    }

    public override fun getContainmentLink(): SContainmentLink? {
        val link: SContainmentLinkAdapter? = as_r4r1yj_a0a0a84(
            node!!.getContainmentLink(),
            SContainmentLinkAdapter::class.java,
        )
        return (if (link == null) null else link.getLink())
    }

    public override fun getFirstChild(): SNode? {
        val allChildren: Iterable<INode> = node!!.allChildren
        return wrap_(Sequence.fromIterable(allChildren).first())
    }

    public override fun getLastChild(): SNode? {
        val allChildren: Iterable<INode> = node!!.allChildren
        return wrap_(Sequence.fromIterable(allChildren).last())
    }

    public override fun getPrevSibling(): SNode? {
        val parent: INode? = node!!.parent
        if (parent == null) {
            return null
        }
        var sibling1: INode? = null
        var sibling2: INode? = null
        for (sibling: INode? in Sequence.fromIterable<INode>(parent.allChildren)) {
            sibling1 = sibling2
            sibling2 = sibling
            if ((node == sibling2)) {
                val result: SNode = wrap_(sibling1)
                return result
            }
        }
        return null
    }

    public override fun getNextSibling(): SNode? {
        val parent: INode? = node!!.parent
        if (parent == null) {
            return null
        }
        var sibling1: INode? = null
        var sibling2: INode? = null
        for (sibling: INode? in Sequence.fromIterable<INode>(parent.allChildren)) {
            sibling1 = sibling2
            sibling2 = sibling
            if ((node == sibling1)) {
                val result: SNode = wrap_(sibling2)
                return result
            }
        }
        return null
    }

    public override fun getChildren(link: SContainmentLink): Iterable<SNode> {
        val children: Iterable<INode> = node!!.getChildren(SContainmentLinkAdapter(link))
        return Sequence.fromIterable(children).select(object : ISelector<INode?, SNode>() {
            public override fun select(it: INode?): SNode {
                return wrap_(it)
            }
        })
    }

    public override fun getChildren(): Iterable<SNode> {
        val allChildren: Iterable<INode> = node!!.allChildren
        return Sequence.fromIterable(allChildren).select(object : ISelector<INode?, SNode>() {
            public override fun select(it: INode?): SNode {
                return wrap_(it)
            }
        })
    }

    public override fun setReferenceTarget(link: SReferenceLink, target: SNode?) {
        node!!.setReferenceTarget(SReferenceLinkAdapter(link), SNodeToNodeAdapter.Companion.wrap(target))
    }

    public override fun getReferenceTarget(link: SReferenceLink): SNode? {
        return wrap_(node!!.getReferenceTarget(SReferenceLinkAdapter(link)))
    }

    public override fun getReference(link: SReferenceLink): SReference? {
        return Reference(link)
    }

    public override fun setReference(link: SReferenceLink, reference: SReference?) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun setReference(link: SReferenceLink, info: ResolveInfo) {
        throw UnsupportedOperationException("Not implemented")
    }

    //  @Override
    public override fun setReference(link: SReferenceLink, reference: SNodeReference) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun dropReference(link: SReferenceLink) {
        throw UnsupportedOperationException("Not implemented")
    }

    public override fun getReferences(): Iterable<SReference> {
        return SConceptAdapter.unwrap(node.concept)!!.referenceLinks
            .filter { getReferenceTarget(it) != null }
            .map { Reference(it) }
    }

    public override fun getProperties(): Iterable<SProperty> {
        val allProperties: Iterable<SProperty> = SConceptAdapter.Companion.unwrap(
            node!!.concept,
        )!!.getProperties()
        return Sequence.fromIterable(allProperties).where(object : IWhereFilter<SProperty>() {
            public override fun accept(it: SProperty): Boolean {
                return getProperty(it) != null
            }
        })
    }

    public override fun hasProperty(property: SProperty): Boolean {
        return getProperty(property) != null
    }

    public override fun getProperty(property: SProperty): String? {
        return node!!.getPropertyValue(SPropertyAdapter(property))
    }

    public override fun setProperty(property: SProperty, value: String?) {
        node!!.setPropertyValue(SPropertyAdapter(property), value)
    }

    public override fun getUserObject(key: Any): Any? {
        if (userObjects != null) {
            var i: Int = 0
            while (i < userObjects!!.size) {
                if (Objects.equals(userObjects!!.get(i), key)) {
                    return userObjects!!.get(i + 1)
                }
                i += 2
            }
        }
        return null
    }

    public override fun putUserObject(key: Any, value: Any?) {
        if (userObjects != null) {
            var i: Int = 0
            while (i < userObjects!!.size) {
                if (Objects.equals(userObjects!!.get(i), key)) {
                    userObjects!![i + 1] = (value)!!
                    return
                }
                i += 2
            }
            userObjects = userObjects!! + key + value
        } else {
            userObjects = arrayOf(key, value)
        }
    }

    public override fun getUserObjectKeys(): Iterable<Any> {
        if (userObjects == null) {
            return emptyList()
        }
        val result: List<Any> = ListSequence.fromList(
            ArrayList(
                userObjects!!.size / 2,
            ),
        )
        var i: Int = 0
        while (i < userObjects!!.size) {
            ListSequence.fromList(result).addElement(userObjects!!.get(i))
            i += 2
        }
        return result
    }

    @Deprecated("")
    public override fun getRoleInParent(): String {
        return (check_r4r1yj_a0a96(getContainmentLink(), this))!!
    }

    @Deprecated("")
    public override fun hasProperty(name: String): Boolean {
        return hasProperty(findProperty(name))
    }

    @Deprecated("")
    public override fun getProperty(string: String): String {
        return (getProperty(findProperty(string)))!!
    }

    @Deprecated("")
    public override fun setProperty(string: String, string1: String) {
        setProperty(findProperty(string), string1)
    }

    @Deprecated("")
    public override fun getPropertyNames(): Iterable<String> {
        val properties: Iterable<SProperty> = getProperties()
        return Sequence.fromIterable(properties).select(object : ISelector<SProperty, String>() {
            public override fun select(it: SProperty): String {
                return it.getName()
            }
        })
    }

    @Deprecated("")
    public override fun setReferenceTarget(string: String, node: SNode?) {
        setReferenceTarget(findReferenceLink(string), node)
    }

    @Deprecated("")
    public override fun getReferenceTarget(role: String): SNode {
        return (getReferenceTarget(findReferenceLink(role)))!!
    }

    protected fun findReferenceLink(name: String): SReferenceLink {
        val links: Iterable<SReferenceLink> = getConcept().getReferenceLinks()
        val link: SReferenceLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SReferenceLink>() {
            public override fun accept(it: SReferenceLink): Boolean {
                return Objects.equals(it.getName(), name)
            }
        })
        if (link == null) {
            throw RuntimeException(getConcept().getName() + " doesn't have a reference link '" + name + "'")
        }
        return link
    }

    protected fun findChildLink(name: String): SContainmentLink {
        val links: Iterable<SContainmentLink> = getConcept().getContainmentLinks()
        val link: SContainmentLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SContainmentLink>() {
            public override fun accept(it: SContainmentLink): Boolean {
                return Objects.equals(it.getName(), name)
            }
        })
        if (link == null) {
            throw RuntimeException(getConcept().getName() + " doesn't have a child link '" + name + "'")
        }
        return link
    }

    protected fun findProperty(name: String): SProperty {
        val properties: Iterable<SProperty> = getConcept().getProperties()
        val property: SProperty? = Sequence.fromIterable(properties).findFirst(object : IWhereFilter<SProperty>() {
            public override fun accept(it: SProperty): Boolean {
                return Objects.equals(it.getName(), name)
            }
        })
        if (property == null) {
            throw RuntimeException(getConcept().getName() + " doesn't have a property '" + name + "'")
        }
        return property
    }

    @Deprecated("")
    public override fun getReference(role: String): SReference {
        return (getReference(findReferenceLink(role)))!!
    }

    @Deprecated("")
    public override fun setReference(string: String, reference: SReference?) {
        setReference(findReferenceLink(string), reference)
    }

    @Deprecated("")
    public override fun insertChildBefore(role: String, newChild: SNode, anchor: SNode?) {
        val link: SContainmentLink = findChildLink(role)
        val children: Iterable<INode> = IterableUtil.asIterable(
            node!!.getChildren(role).iterator(),
        )
        var index: Int = -1
        if (anchor != null) {
            index = Sequence.fromIterable<INode?>(children).indexOf(SNodeToNodeAdapter.Companion.wrap(anchor))
            if (index == -1) {
                throw RuntimeException(anchor.toString() + " is not a child of " + node)
            }
        }
        node.addNewChild(SContainmentLinkAdapter(link), index, SConceptAdapter.Companion.wrap(newChild.getConcept()))
    }

    @Deprecated("")
    public override fun addChild(string: String, node: SNode) {
        addChild(findChildLink(string), node)
    }

    @Deprecated("")
    public override fun getChildren(string: String): List<jetbrains.mps.smodel.SNode> {
        val children: Iterable<jetbrains.mps.smodel.SNode> =
            getChildren(findChildLink(string)) as Iterable<jetbrains.mps.smodel.SNode>
        return Sequence.fromIterable(children).toListSequence()
    }

    public override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: NodeToSNodeAdapter = o as NodeToSNodeAdapter
        if ((if (node != null) !((node == that.node)) else that.node != null)) {
            return false
        }
        return true
    }

    public override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (node != null) (node as Any).hashCode() else 0))
        return result
    }

    public override fun toString(): String {
        return "NodeToSNodeAdapter[" + node + "]"
    }

    inner class NodeReference() : SNodeReference {
        public override fun resolve(repository: SRepository): SNode? {
            return this@NodeToSNodeAdapter
        }

        public override fun getModelReference(): SModelReference? {
            return null
        }

        public override fun getNodeId(): SNodeId? {
            return nodeId
        }

        public override fun toString(): String {
            return ":" + node!!.reference.toString()
        }

        public override fun hashCode(): Int {
            return this@NodeToSNodeAdapter.hashCode()
        }

        public override fun equals(otherObject: Any?): Boolean {
            if (otherObject is NodeReference) {
                return (getNode() == otherObject.getNode())
            } else {
                return false
            }
        }

        fun getNode(): NodeToSNodeAdapter {
            return this@NodeToSNodeAdapter
        }
    }

    inner class NodeId() : SNodeId {
        public override fun getType(): String {
            return "shadowmodelsAdapter"
        }

        public override fun toString(): String {
            return ":" + node!!.reference.toString()
        }
    }

    inner class Reference(private val link: SReferenceLink) : SReference {
        @Deprecated("")
        public override fun getRole(): String {
            return getLink().getName()
        }

        public override fun getLink(): SReferenceLink {
            return link
        }

        public override fun getSourceNode(): SNode {
            return this@NodeToSNodeAdapter
        }

        public override fun getTargetNode(): SNode {
            return (getReferenceTarget(link))!!
        }

        public override fun getTargetNodeReference(): SNodeReference {
            val targetNode: SNode = getTargetNode()
            return (check_r4r1yj_a1a6rd(targetNode))!!
        }

        public override fun getTargetSModelReference(): SModelReference? {
            val targetNode: SNode = getTargetNode()
            val model: SModel? = check_r4r1yj_a0b0h59(targetNode)
            return (if (model == null) null else model.getReference())
        }

        public override fun getTargetNodeId(): SNodeId? {
            return getTargetNode().getNodeId()
        }
    }

    private object CONCEPTS {
        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model",
        )

        /*package*/
        val `BaseConcept$gP`: SConcept = MetaAdapterFactory.getConcept(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            "jetbrains.mps.lang.core.structure.BaseConcept",
        )

        /*package*/
        val `INamedConcept$Kd`: SInterfaceConcept = MetaAdapterFactory.getInterfaceConcept(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            "jetbrains.mps.lang.core.structure.INamedConcept",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(NodeToSNodeAdapter::class.java)
        private val currentCache: ContextValue<InstancesCache> = ContextValue()
        fun runWithCache(cache: InstancesCache, runnable: Runnable) {
            currentCache.computeWith(cache, {
                runnable.run()
                Unit
            })
        }

        fun <T> computeWithCache(cache: InstancesCache, computable: Computable<T>): T {
            return currentCache.computeWith(cache, { computable.compute() })
        }

        private fun getInstance(node: INode, repository: SRepository?): NodeToSNodeAdapter {
            val cache: InstancesCache? = currentCache.getValue()
            if (cache == null) {
                return NodeToSNodeAdapter(node, repository)
            }
            val key: Tuples._2<INode, SRepository?> = MultiTuple.from(node, repository)
            var instance: NodeToSNodeAdapter? = cache.instances.get(key)
            if (instance == null) {
                instance = NodeToSNodeAdapter(node, repository)
                cache.instances.put(key, instance)
            }
            return instance
        }

        fun clearInstancesCache() {
            val cache: InstancesCache? = currentCache.getValue()
            if (cache != null) {
                cache.instances.clear()
            }
        }

        @JvmName("wrap_nullable")
        fun wrap(nodeToWrap: INode?, repository: SRepository? = null): SNode? {
            return nodeToWrap?.let { wrap(it, repository) }
        }
        fun wrap(nodeToWrap: INode, repository: SRepository? = null): SNode {
            if (nodeToWrap is SNodeToNodeAdapter) {
                return nodeToWrap.getWrapped()
            }
            return getInstance(nodeToWrap, repository)
        }

        fun wrap(nodeToWrap: SNode): SNode {
            // Makes code generation easier. wrap can always be applied to ensure a value is an SNode.
            return nodeToWrap
        }

        private fun check_r4r1yj_a0a96(
            checkedDotOperand: SContainmentLink?,
            checkedDotThisExpression: NodeToSNodeAdapter,
        ): String? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getName()
            }
            return null
        }

        private fun check_r4r1yj_a1a6rd(checkedDotOperand: SNode?): SNodeReference? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getReference()
            }
            return null
        }

        private fun check_r4r1yj_a0b0h59(checkedDotOperand: SNode?): SModel? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getModel()
            }
            return null
        }

        private fun <T> as_r4r1yj_a0a0a84(o: Any?, type: Class<T>): T? {
            return (if (type.isInstance(o)) o as T? else null)
        }
    }
}
