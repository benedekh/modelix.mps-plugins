package org.modelix.model.mpsadapters.mps

import com.google.common.collect.MapMaker
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.util.Computable
import jetbrains.mps.util.IterableUtil
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SInterfaceConcept
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.ResolveInfo
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelReference
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SNodeId
import org.jetbrains.mps.openapi.model.SNodeReference
import org.jetbrains.mps.openapi.model.SReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.ContextValue
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.api.getAncestor
import org.modelix.model.lazy.unwrap
import java.util.Objects

/*Generated by MPS */
class NodeToSNodeAdapter protected constructor(val node: INode, repository: SRepository?) : SNode {
    class InstancesCache {
        val instances: MutableMap<Tuples._2<INode, SRepository?>, NodeToSNodeAdapter> =
            MapMaker().weakValues().makeMap()
    }

    private val repository: SRepository?
    private var userObjects: Array<Any?>? = null
    private val nodeReference: NodeReference = NodeReference()
    private val nodeId: NodeId = NodeId()
    private var modelMode: EModelMode = EModelMode.NULL

    init {
        requireNotNull(node.concept) { "Node has no concept: " + node }
        this.repository = repository
    }

    fun setModelMode(mode: EModelMode) {
        modelMode = mode
    }

    protected fun wrap_(nodeToWrap: INode?): SNode {
        val wrapped: SNode? = wrap(nodeToWrap, repository)
        if (wrapped is NodeToSNodeAdapter) {
            wrapped.setModelMode(modelMode)
        }
        return (wrapped)!!
    }

    fun getWrapped(): INode {
        return node
    }

    override fun getModel(): SModel? {
        when (modelMode) {
            EModelMode.NULL -> return null
            EModelMode.ADAPTER -> {
                val modelNode: INode? = node.getAncestor(SConceptAdapter.Companion.wrap(CONCEPTS.`Model$2P`), false)
                if (modelNode == null) {
                    return null
                }
                return NodeToSModelAdapter.Companion.wrap(modelNode, repository)
            }

            else -> throw RuntimeException("Unknown mode: " + modelMode)
        }
    }

    override fun getNodeId(): SNodeId {
        return nodeId
    }

    override fun getReference(): SNodeReference {
        return nodeReference
    }

    override fun getConcept(): SConcept {
        val concept: IConcept? = node.concept
        if (concept is SConceptAdapter) {
            return concept.adapted as SConcept
        }
        val sConcept: SAbstractConcept? = BootstrapConceptMappings.Companion.INSTANCE.getSConcept(concept)
        if (sConcept is SConcept) {
            return sConcept
        }
        return CONCEPTS.`BaseConcept$gP`
    }

    override fun isInstanceOfConcept(concept: SAbstractConcept): Boolean {
        return getConcept().isSubConceptOf(concept)
    }

    override fun getPresentation(): String {
        val snode: SNode = this
        var presentation: String? = null
        try {
            presentation = node.toString() // BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(snode);
        } catch (ex: Exception) {
            if (LOG.isDebugEnabled) {
                LOG.debug("", ex)
            }
        }
        try {
            if (presentation == null && isInstanceOfConcept(CONCEPTS.`INamedConcept$Kd`)) {
                presentation = getProperty(PROPS.`name$MnvL`)
            }
        } catch (ex: Exception) {
            if (LOG.isDebugEnabled) {
                LOG.debug("", ex)
            }
        }
        if (presentation == null) {
            presentation = toString()
        }
        return presentation
    }

    override fun getName(): String? {
        return node.getPropertyValue("name")
    }

    override fun addChild(link: SContainmentLink, child: SNode) {
        node.moveChild(SContainmentLinkAdapter(link), -1, (SNodeToNodeAdapter.Companion.wrap(child))!!)
    }

    override fun insertChildBefore(link: SContainmentLink, child: SNode, anchor: SNode?) {
        if (anchor == null) {
            addChild(link, child)
            return
        }
        val index: Int = Sequence.fromIterable(getChildren(link)).indexOf(anchor)
        node.moveChild(SContainmentLinkAdapter(link), index, (SNodeToNodeAdapter.Companion.wrap(child))!!)
    }

    override fun insertChildAfter(link: SContainmentLink, child: SNode, anchor: SNode?) {
        if (anchor == null) {
            addChild(link, child)
            return
        }
        val index: Int = Sequence.fromIterable(getChildren(link)).indexOf(anchor)
        node.moveChild(SContainmentLinkAdapter(link), index + 1, (SNodeToNodeAdapter.Companion.wrap(child))!!)
    }

    override fun removeChild(node: SNode) {
        this.node.removeChild((SNodeToNodeAdapter.Companion.wrap(node))!!)
    }

    override fun delete() {
        node.parent!!.removeChild((node))
    }

    override fun getParent(): SNode? {
        val parent: INode? = node.parent
        if (parent == null) {
            return null
        }
        if (parent.concept == null) {
            return null
        }
        val result: SNode = wrap_(parent)
        return result
    }

    override fun getContainingRoot(): SNode {
        var n1: INode?
        var n2: INode? = node
        do {
            n1 = n2
            n2 = n1!!.parent
        } while (n2 != null)
        return wrap_(n1)
    }

    override fun getContainmentLink(): SContainmentLink? {
        val link: SContainmentLinkAdapter? = as_r4r1yj_a0a0a84(
            node.getContainmentLink(),
            SContainmentLinkAdapter::class.java,
        )
        return (if (link == null) null else link.getLink())
    }

    override fun getFirstChild(): SNode {
        val allChildren: Iterable<INode> = node.allChildren
        return wrap_(Sequence.fromIterable(allChildren).first())
    }

    override fun getLastChild(): SNode {
        val allChildren: Iterable<INode> = node.allChildren
        return wrap_(Sequence.fromIterable(allChildren).last())
    }

    override fun getPrevSibling(): SNode? {
        val parent: INode? = node.parent
        if (parent == null) {
            return null
        }
        var sibling1: INode? = null
        var sibling2: INode? = null
        for (sibling: INode? in Sequence.fromIterable<INode>(parent.allChildren)) {
            sibling1 = sibling2
            sibling2 = sibling
            if ((node == sibling2)) {
                val result: SNode = wrap_(sibling1)
                return result
            }
        }
        return null
    }

    override fun getNextSibling(): SNode? {
        val parent: INode? = node.parent
        if (parent == null) {
            return null
        }
        var sibling1: INode? = null
        var sibling2: INode? = null
        for (sibling: INode? in Sequence.fromIterable<INode>(parent.allChildren)) {
            sibling1 = sibling2
            sibling2 = sibling
            if ((node == sibling1)) {
                val result: SNode = wrap_(sibling2)
                return result
            }
        }
        return null
    }

    override fun getChildren(link: SContainmentLink): Iterable<SNode> {
        val children: Iterable<INode> = node.getChildren(SContainmentLinkAdapter(link))
        return Sequence.fromIterable(children).select(object : ISelector<INode?, SNode>() {
            override fun select(it: INode?): SNode {
                return wrap_(it)
            }
        })
    }

    override fun getChildren(): Iterable<SNode> {
        val allChildren: Iterable<INode> = node.allChildren
        return Sequence.fromIterable(allChildren).select(object : ISelector<INode?, SNode>() {
            override fun select(it: INode?): SNode {
                return wrap_(it)
            }
        })
    }

    override fun setReferenceTarget(link: SReferenceLink, target: SNode?) {
        node.setReferenceTarget(SReferenceLinkAdapter(link), SNodeToNodeAdapter.Companion.wrap(target))
    }

    override fun getReferenceTarget(link: SReferenceLink): SNode {
        return wrap_(node.getReferenceTarget(SReferenceLinkAdapter(link)))
    }

    override fun getReference(link: SReferenceLink): SReference {
        return Reference(link)
    }

    override fun setReference(link: SReferenceLink, reference: SReference?) {
        throw UnsupportedOperationException("Not implemented")
    }

    override fun setReference(link: SReferenceLink, info: ResolveInfo) {
        throw UnsupportedOperationException("Not implemented")
    }

    //  @Override
    override fun setReference(link: SReferenceLink, reference: SNodeReference) {
        throw UnsupportedOperationException("Not implemented")
    }

    override fun dropReference(link: SReferenceLink) {
        throw UnsupportedOperationException("Not implemented")
    }

    override fun getReferences(): Iterable<SReference> {
        return SConceptAdapter.unwrap(node.concept)!!.referenceLinks
            .filter { getReferenceTarget(it) != null }
            .map { Reference(it) }
    }

    override fun getProperties(): Iterable<SProperty> {
        val allProperties: Iterable<SProperty> = SConceptAdapter.Companion.unwrap(
            node.concept,
        )!!.properties
        return Sequence.fromIterable(allProperties).where(object : IWhereFilter<SProperty>() {
            override fun accept(it: SProperty): Boolean {
                return getProperty(it) != null
            }
        })
    }

    override fun hasProperty(property: SProperty): Boolean {
        return getProperty(property) != null
    }

    override fun getProperty(property: SProperty): String? {
        return node.getPropertyValue(SPropertyAdapter(property))
    }

    override fun setProperty(property: SProperty, value: String?) {
        node.setPropertyValue(SPropertyAdapter(property), value)
    }

    override fun getUserObject(key: Any): Any? {
        if (userObjects != null) {
            var i: Int = 0
            while (i < userObjects!!.size) {
                if (Objects.equals(userObjects!!.get(i), key)) {
                    return userObjects!!.get(i + 1)
                }
                i += 2
            }
        }
        return null
    }

    override fun putUserObject(key: Any, value: Any?) {
        if (userObjects != null) {
            var i: Int = 0
            while (i < userObjects!!.size) {
                if (Objects.equals(userObjects!!.get(i), key)) {
                    userObjects!![i + 1] = (value)!!
                    return
                }
                i += 2
            }
            userObjects = userObjects!! + key + value
        } else {
            userObjects = arrayOf(key, value)
        }
    }

    override fun getUserObjectKeys(): Iterable<Any> {
        if (userObjects == null) {
            return emptyList()
        }
        val result: List<Any> = ListSequence.fromList(
            ArrayList(
                userObjects!!.size / 2,
            ),
        )
        var i: Int = 0
        while (i < userObjects!!.size) {
            ListSequence.fromList(result).addElement(userObjects!!.get(i))
            i += 2
        }
        return result
    }

    @Deprecated("")
    override fun getRoleInParent(): String {
        return (check_r4r1yj_a0a96(getContainmentLink(), this))!!
    }

    @Deprecated("")
    override fun hasProperty(name: String): Boolean {
        return hasProperty(findProperty(name))
    }

    @Deprecated("")
    override fun getProperty(string: String): String {
        return (getProperty(findProperty(string)))!!
    }

    @Deprecated("")
    override fun setProperty(string: String, string1: String) {
        setProperty(findProperty(string), string1)
    }

    @Deprecated("")
    override fun getPropertyNames(): Iterable<String> {
        val properties: Iterable<SProperty> = getProperties()
        return Sequence.fromIterable(properties).select(object : ISelector<SProperty, String>() {
            override fun select(it: SProperty): String {
                return it.name
            }
        })
    }

    @Deprecated("")
    override fun setReferenceTarget(string: String, node: SNode?) {
        setReferenceTarget(findReferenceLink(string), node)
    }

    @Deprecated("")
    override fun getReferenceTarget(role: String): SNode {
        return (getReferenceTarget(findReferenceLink(role)))!!
    }

    protected fun findReferenceLink(name: String): SReferenceLink {
        val links: Iterable<SReferenceLink> = getConcept().referenceLinks
        val link: SReferenceLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SReferenceLink>() {
            override fun accept(it: SReferenceLink): Boolean {
                return Objects.equals(it.name, name)
            }
        })
        if (link == null) {
            throw RuntimeException(getConcept().name + " doesn't have a reference link '" + name + "'")
        }
        return link
    }

    protected fun findChildLink(name: String): SContainmentLink {
        val links: Iterable<SContainmentLink> = getConcept().containmentLinks
        val link: SContainmentLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SContainmentLink>() {
            override fun accept(it: SContainmentLink): Boolean {
                return Objects.equals(it.name, name)
            }
        })
        if (link == null) {
            throw RuntimeException(getConcept().name + " doesn't have a child link '" + name + "'")
        }
        return link
    }

    protected fun findProperty(name: String): SProperty {
        val properties: Iterable<SProperty> = getConcept().properties
        val property: SProperty? = Sequence.fromIterable(properties).findFirst(object : IWhereFilter<SProperty>() {
            override fun accept(it: SProperty): Boolean {
                return Objects.equals(it.name, name)
            }
        })
        if (property == null) {
            throw RuntimeException(getConcept().name + " doesn't have a property '" + name + "'")
        }
        return property
    }

    @Deprecated("")
    override fun getReference(role: String): SReference {
        return (getReference(findReferenceLink(role)))!!
    }

    @Deprecated("")
    override fun setReference(string: String, reference: SReference?) {
        setReference(findReferenceLink(string), reference)
    }

    @Deprecated("")
    override fun insertChildBefore(role: String, newChild: SNode, anchor: SNode?) {
        val link: SContainmentLink = findChildLink(role)
        val children: Iterable<INode> = IterableUtil.asIterable(
            node.getChildren(role).iterator(),
        )
        var index: Int = -1
        if (anchor != null) {
            index = Sequence.fromIterable<INode?>(children).indexOf(SNodeToNodeAdapter.Companion.wrap(anchor))
            if (index == -1) {
                throw RuntimeException(anchor.toString() + " is not a child of " + node)
            }
        }
        node.addNewChild(SContainmentLinkAdapter(link), index, SConceptAdapter.Companion.wrap(newChild.concept))
    }

    @Deprecated("")
    override fun addChild(string: String, node: SNode) {
        addChild(findChildLink(string), node)
    }

    @Deprecated("")
    override fun getChildren(string: String): List<jetbrains.mps.smodel.SNode> {
        val children: Iterable<jetbrains.mps.smodel.SNode> =
            getChildren(findChildLink(string)) as Iterable<jetbrains.mps.smodel.SNode>
        return Sequence.fromIterable(children).toListSequence()
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || this.javaClass != o.javaClass) {
            return false
        }
        val that: NodeToSNodeAdapter = o as NodeToSNodeAdapter
        return !(if (node != null) !((node == that.node)) else that.node != null)
    }

    override fun hashCode(): Int {
        var result: Int = 0
        result = 31 * result + ((if (node != null) (node as Any).hashCode() else 0))
        return result
    }

    override fun toString(): String {
        return "NodeToSNodeAdapter[" + node + "]"
    }

    inner class NodeReference : SNodeReference {
        override fun resolve(repository: SRepository): SNode {
            return this@NodeToSNodeAdapter
        }

        override fun getModelReference(): SModelReference? {
            return null
        }

        override fun getNodeId(): SNodeId? {
            return nodeId
        }

        override fun toString(): String {
            return ":" + node.reference.toString()
        }

        override fun hashCode(): Int {
            return this@NodeToSNodeAdapter.hashCode()
        }

        override fun equals(otherObject: Any?): Boolean {
            if (otherObject is NodeReference) {
                return (getNode() == otherObject.getNode())
            } else {
                return false
            }
        }

        fun getNode(): NodeToSNodeAdapter {
            return this@NodeToSNodeAdapter
        }
    }

    inner class NodeId : SNodeId {
        override fun getType(): String {
            return "shadowmodelsAdapter"
        }

        override fun toString(): String {
            return ":" + node.reference.toString()
        }
    }

    inner class Reference(private val link: SReferenceLink) : SReference {
        @Deprecated("")
        override fun getRole(): String {
            return getLink().name
        }

        override fun getLink(): SReferenceLink {
            return link
        }

        override fun getSourceNode(): SNode {
            return this@NodeToSNodeAdapter
        }

        override fun getTargetNode(): SNode {
            return (getReferenceTarget(link))!!
        }

        override fun getTargetNodeReference(): SNodeReference {
            val targetNode: SNode = targetNode
            return (check_r4r1yj_a1a6rd(targetNode))!!
        }

        override fun getTargetSModelReference(): SModelReference? {
            val targetNode: SNode = targetNode
            val model: SModel? = check_r4r1yj_a0b0h59(targetNode)
            return (if (model == null) null else model.reference)
        }

        override fun getTargetNodeId(): SNodeId? {
            return targetNode.nodeId
        }
    }

    private object CONCEPTS {
        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model",
        )

        /*package*/
        val `BaseConcept$gP`: SConcept = MetaAdapterFactory.getConcept(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            "jetbrains.mps.lang.core.structure.BaseConcept",
        )

        /*package*/
        val `INamedConcept$Kd`: SInterfaceConcept = MetaAdapterFactory.getInterfaceConcept(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            "jetbrains.mps.lang.core.structure.INamedConcept",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(NodeToSNodeAdapter::class.java)
        private val currentCache: ContextValue<InstancesCache> = ContextValue()
        fun runWithCache(cache: InstancesCache, runnable: Runnable) {
            currentCache.computeWith(cache, {
                runnable.run()
            })
        }

        fun <T> computeWithCache(cache: InstancesCache, computable: Computable<T>): T {
            return currentCache.computeWith(cache, { computable.compute() })
        }

        private fun getInstance(node: INode, repository: SRepository?): NodeToSNodeAdapter {
            val cache: InstancesCache? = currentCache.getValue()
            if (cache == null) {
                return NodeToSNodeAdapter(node, repository)
            }
            val key: Tuples._2<INode, SRepository?> = MultiTuple.from(node, repository)
            var instance: NodeToSNodeAdapter? = cache.instances.get(key)
            if (instance == null) {
                instance = NodeToSNodeAdapter(node, repository)
                cache.instances.put(key, instance)
            }
            return instance
        }

        fun clearInstancesCache() {
            val cache: InstancesCache? = currentCache.getValue()
            if (cache != null) {
                cache.instances.clear()
            }
        }

        @JvmName("wrap_nullable")
        fun wrap(nodeToWrap: INode?, repository: SRepository? = null): SNode? {
            return nodeToWrap?.let { wrap(it, repository) }
        }
        fun wrap(nodeToWrap: INode, repository: SRepository? = null): SNode {
            if (nodeToWrap is SNodeToNodeAdapter) {
                return nodeToWrap.getWrapped()
            }
            return getInstance(nodeToWrap, repository)
        }

        fun wrap(nodeToWrap: SNode): SNode {
            // Makes code generation easier. wrap can always be applied to ensure a value is an SNode.
            return nodeToWrap
        }

        private fun check_r4r1yj_a0a96(
            checkedDotOperand: SContainmentLink?,
            checkedDotThisExpression: NodeToSNodeAdapter,
        ): String? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.name
            }
            return null
        }

        private fun check_r4r1yj_a1a6rd(checkedDotOperand: SNode?): SNodeReference? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.reference
            }
            return null
        }

        private fun check_r4r1yj_a0b0h59(checkedDotOperand: SNode?): SModel? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.model
            }
            return null
        }

        private fun <T> as_r4r1yj_a0a0a84(o: Any?, type: Class<T>): T? {
            return (if (type.isInstance(o)) o as T? else null)
        }
    }
}
