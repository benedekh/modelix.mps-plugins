package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P1_E0
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.area.IArea

/*Generated by MPS */
class SRepositoryAsNode(repository: SRepository) : TreeElementAsNode<SRepository>(repository) {
    override fun getArea(): IArea {
        return MPSArea(element)
    }

    override val concept: IConcept
        get() {
            return (SConceptAdapter.Companion.wrap(CONCEPTS.`Repository$db`))
        }

    override fun getChildAccessor(role: String?): IChildAccessor<SRepository>? {
        if ((role == LINKS.`modules$jBPn`.name)) {
            return modulesAccessor
        }
        if ((role == LINKS.`tempModules$Zqoa`.name)) {
            return tempModulesAccessor
        }
        if ((role == LINKS.`projects$NW07`.name)) {
            return projectsAccessor
        }
        return super.getChildAccessor(role)
    }

    override val parent: INode?
        get() {
            return null
        }
    override val roleInParent: String?
        get() {
            return null
        }

    override fun toString(): String {
        return "repository"
    }

    override val reference: INodeReference
        get() {
            return NodeReference.INSTANCE
        }

    class NodeReference private constructor() : INodeReference {
        override fun resolveNode(area: IArea?): INode {
            var repo: SRepository? = null
            if (area != null) {
                val areas: List<IArea> = area.collectAreas()
                repo = ListSequence.fromList(areas).ofType(MPSArea::class.java)
                    .select(object : ISelector<MPSArea, SRepository?>() {
                        override fun select(it: MPSArea): SRepository {
                            return it.repository
                        }
                    }).filterNotNull().firstOrNull()
            }
            if (repo == null) {
                repo = MPSModuleRepository.getInstance()
            }
            return SRepositoryAsNode(repo!!)
        }

        companion object {
            var INSTANCE: NodeReference = NodeReference()
        }
    }

    private object CONCEPTS {
        /*package*/
        val `Repository$db`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            "org.modelix.model.repositoryconcepts.structure.Repository",
        )
    }

    private object LINKS {
        /*package*/
        val `modules$jBPn`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x69652614fd1c517L,
            "modules",
        )

        /*package*/
        val `tempModules$Zqoa`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x72291b7f31486ecaL,
            "tempModules",
        )

        /*package*/
        val `projects$NW07`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x620a8558361d3e0cL,
            "projects",
        )
    }

    companion object {
        fun isVisible(module: SModule?): Boolean {
            return true
        }

        private val modulesAccessor: IChildAccessor<SRepository> = object : IChildAccessor<SRepository> {
            override fun get(repository: SRepository): Iterable<INode> {
                val modules: Iterable<SModule> = repository.modules
                return Sequence.fromIterable<SModule>(modules).where(object : IWhereFilter<SModule?>() {
                    override fun accept(it: SModule?): Boolean {
                        return isVisible(it)
                    }
                }).where(object : IWhereFilter<SModule?>() {
                    override fun accept(it: SModule?): Boolean {
                        return !(SModuleAsNode.Companion.isTempModule(it))
                    }
                }).select<INode>(object : ISelector<SModule, SModuleAsNode>() {
                    override fun select(it: SModule): SModuleAsNode {
                        return SModuleAsNode(it)
                    }
                })
            }
        }
        private val tempModulesAccessor: IChildAccessor<SRepository> = object : IChildAccessor<SRepository> {
            override fun get(repository: SRepository): Iterable<INode> {
                val modules: Iterable<SModule> = repository.modules
                return Sequence.fromIterable<SModule>(modules).where(object : IWhereFilter<SModule?>() {
                    override fun accept(it: SModule?): Boolean {
                        return isVisible(it)
                    }
                }).where(object : IWhereFilter<SModule?>() {
                    override fun accept(it: SModule?): Boolean {
                        return SModuleAsNode.Companion.isTempModule(it)
                    }
                }).select<INode>(object : ISelector<SModule, SModuleAsNode>() {
                    override fun select(it: SModule): SModuleAsNode {
                        return SModuleAsNode(it)
                    }
                })
            }
        }
        private val projectsAccessor: IChildAccessor<SRepository> = object : IChildAccessor<SRepository> {
            override fun get(element: SRepository): Iterable<INode> {
                val projects: List<Project> = ProjectManager.getInstance().openedProjects
                return ListSequence.fromList(projects).ofType(MPSProject::class.java)
                    .select<INode>(object : ISelector<MPSProject, ProjectAsNode>() {
                        override fun select(it: MPSProject): ProjectAsNode {
                            return ProjectAsNode(it)
                        }
                    })
            }
        }
    }
}
