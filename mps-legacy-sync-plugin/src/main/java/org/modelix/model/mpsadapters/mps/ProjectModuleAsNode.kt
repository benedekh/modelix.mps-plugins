package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.structure.project.ModulePath
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleReference
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.IArea
import java.util.Objects

/*Generated by MPS */
class ProjectModuleAsNode(project: MPSProject, module: SModule) :
    TreeElementAsNode<Pair<MPSProject, SModule>>(project to module) {
    private val moduleAccessor: IReferenceAccessor<Pair<MPSProject, SModule>> =
        object : IReferenceAccessor<Pair<MPSProject, SModule>> {
            public override fun get(element: Pair<MPSProject, SModule>): INode? {
                return SModuleAsNode(element.second)
            }

            public override fun set(element: Pair<MPSProject, SModule>, target: INode?): INode? {
                throw UnsupportedOperationException("readonly")
            }
        }
    private val virtualFolderAccessor: IPropertyAccessor<Pair<MPSProject, SModule>> =
        object : IPropertyAccessor<Pair<MPSProject, SModule>> {
            public override fun get(element: Pair<MPSProject, SModule>): String? {
                return check_9jclrw_a0a0a0a1(element.first.getPath((element.second)))
            }

            public override fun set(element: Pair<MPSProject, SModule>, value: String?): String? {
                element.first.setVirtualFolder((element.second), value)
                return value
            }
        }

    override fun getReferenceAccessor(role: String): IReferenceAccessor<Pair<MPSProject, SModule>>? {
        if (Objects.equals(role, LINKS.`module$DFjI`.getName())) {
            return moduleAccessor
        }
        return super.getReferenceAccessor(role)
    }

    override fun getPropertyAccessor(role: String): IPropertyAccessor<Pair<MPSProject, SModule>>? {
        if (Objects.equals(role, PROPS.`virtualFolder$dgnn`.getName())) {
            return virtualFolderAccessor
        }
        return super.getPropertyAccessor(role)
    }

    public override val concept: IConcept
        get() {
            return SConceptAdapter.wrap(CONCEPTS.`ProjectModule$uf`)
        }

    public override val parent: INode
        get() {
            return ProjectAsNode(element.first)
        }

    public override val reference: INodeReference
        get() {
            return NodeReference(
                parent!!.reference as ProjectAsNode.NodeReference?,
                element.second.getModuleReference()
            )
        }

    public override val roleInParent: String?
        get() {
            return LINKS.`modules$Bi3g`.getName()
        }

    class NodeReference(
        private val projectRef: ProjectAsNode.NodeReference?,
        private val moduleRef: SModuleReference?
    ) : INodeReference {
        public override fun serialize(): String {
            return "mps-project-module:" + moduleRef + "#IN#" + projectRef!!.serialize()
        }

        fun getModuleRef(): SModuleReference? {
            return moduleRef
        }

        fun getProjectRef(): ProjectAsNode.NodeReference? {
            return projectRef
        }

        public override fun resolveNode(area: IArea?): INode? {
            val project: MPSProject = projectRef!!.resolveNode(area)?.element ?: return null
            val module: SModule = moduleRef!!.resolve(project.repository) ?: return null
            return ProjectModuleAsNode(project, module)
        }

        public override fun equals(o: Any?): Boolean {
            if (this === o) {
                return true
            }
            if (o == null || this.javaClass != o.javaClass) {
                return false
            }
            val that: NodeReference = o as NodeReference
            if ((if (moduleRef != null) !((moduleRef == that.moduleRef)) else that.moduleRef != null)) {
                return false
            }
            if ((if (projectRef != null) !((projectRef == that.projectRef)) else that.projectRef != null)) {
                return false
            }
            return true
        }

        public override fun hashCode(): Int {
            var result: Int = 0
            result = 31 * result + ((if (moduleRef != null) (moduleRef as Any).hashCode() else 0))
            result = 31 * result + ((if (projectRef != null) (projectRef as Any).hashCode() else 0))
            return result
        }
    }

    private object LINKS {
        /*package*/
        val `module$DFjI`: SReferenceLink = MetaAdapterFactory.getReferenceLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x5040008087d5d3d4L,
            0x5040008087d5d3edL,
            "module"
        )

        /*package*/
        val `modules$Bi3g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            0x37a0917d689de9e2L,
            "modules"
        )
    }

    private object PROPS {
        /*package*/
        val `virtualFolder$dgnn`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x3a4fe9e427e83264L,
            0x3a4fe9e427e83265L,
            "virtualFolder"
        )
    }

    private object CONCEPTS {
        /*package*/
        val `ProjectModule$uf`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x3a4fe9e427e83264L,
            "org.modelix.model.repositoryconcepts.structure.ProjectModule"
        )
    }

    companion object {
        private fun check_9jclrw_a0a0a0a1(checkedDotOperand: ModulePath?): String? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getVirtualFolder()
            }
            return null
        }
    }
}
