package org.modelix.model.mpsadapters.mps

import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.SModelReference
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SNodeId
import org.jetbrains.mps.openapi.model.SNodeReference
import org.jetbrains.mps.openapi.model.SReference
import org.modelix.model.api.PNodeAdapter.Companion.wrap

/*Generated by MPS */
class AReference(private val reference: SReference) : jetbrains.mps.smodel.SReference(
    reference.getLink(),
    null,
) {
    @Deprecated("")
    public override fun getRole(): String {
        throw UnsupportedOperationException()
    }

    public override fun getLink(): SReferenceLink {
        return reference.getLink()
    }

    public override fun getSourceNode(): SNode {
        return (ANode.Companion.wrap(reference.getSourceNode()))
    }

    public override fun getTargetNodeReference(): SNodeReference {
        return ANodeReference(reference.getTargetNodeReference())
    }

    public override fun getTargetSModelReference(): SModelReference? {
        return reference.getTargetSModelReference()
    }

    public override fun getTargetNodeId(): SNodeId? {
        return reference.getTargetNodeId()
    }

    public override fun makeDirect() {
        throw UnsupportedOperationException()
    }

    public override fun makeIndirect(): Boolean {
        throw UnsupportedOperationException()
    }

    public override fun getResolveInfo(): String? {
        return null
    }

    public override fun setResolveInfo(info: String) {
        throw UnsupportedOperationException()
    }

    override fun getTargetNode_internal(report: ProblemReporter): SNode {
        return (ANode.wrap(reference.getTargetNode()))
    }

    companion object {
        fun wrap(refToWrap: SReference?): jetbrains.mps.smodel.SReference? {
            if (refToWrap == null) {
                return null
            }
            if (refToWrap is jetbrains.mps.smodel.SReference) {
                return refToWrap
            }
            return AReference(refToWrap)
        }
    }
}
