package org.modelix.model.mpsadapters.mps

import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.SModelReference
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SNodeId
import org.jetbrains.mps.openapi.model.SNodeReference
import org.jetbrains.mps.openapi.model.SReference
import org.modelix.model.api.PNodeAdapter.Companion.wrap

/*Generated by MPS */
class AReference(private val reference: SReference) : jetbrains.mps.smodel.SReference(
    reference.link,
    null,
) {
    @Deprecated("")
    override fun getRole(): String {
        throw UnsupportedOperationException()
    }

    override fun getLink(): SReferenceLink {
        return reference.link
    }

    override fun getSourceNode(): SNode {
        return (ANode.Companion.wrap(reference.sourceNode))
    }

    override fun getTargetNodeReference(): SNodeReference {
        return ANodeReference(reference.targetNodeReference)
    }

    override fun getTargetSModelReference(): SModelReference? {
        return reference.targetSModelReference
    }

    override fun getTargetNodeId(): SNodeId? {
        return reference.targetNodeId
    }

    override fun makeDirect() {
        throw UnsupportedOperationException()
    }

    override fun makeIndirect(): Boolean {
        throw UnsupportedOperationException()
    }

    override fun getResolveInfo(): String? {
        return null
    }

    override fun setResolveInfo(info: String) {
        throw UnsupportedOperationException()
    }

    override fun getTargetNode_internal(report: ProblemReporter): SNode {
        return (ANode.wrap(reference.targetNode))
    }

    companion object {
        fun wrap(refToWrap: SReference?): jetbrains.mps.smodel.SReference? {
            if (refToWrap == null) {
                return null
            }
            if (refToWrap is jetbrains.mps.smodel.SReference) {
                return refToWrap
            }
            return AReference(refToWrap)
        }
    }
}
