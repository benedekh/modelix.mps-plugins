package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P1_E0
import jetbrains.mps.internal.collections.runtime.CollectionSequence
import jetbrains.mps.internal.collections.runtime.IMapping
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.project.AbstractModule
import jetbrains.mps.project.DevKit
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.project.Solution
import jetbrains.mps.project.facets.JavaModuleFacet
import jetbrains.mps.project.structure.modules.Dependency
import jetbrains.mps.project.structure.modules.ModuleDescriptor
import jetbrains.mps.project.structure.modules.SolutionDescriptor
import jetbrains.mps.project.structure.project.ModulePath
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.smodel.tempmodel.TempModule
import jetbrains.mps.smodel.tempmodel.TempModule2
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SLanguage
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.module.SDependency
import org.jetbrains.mps.openapi.module.SDependencyScope
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleFacet
import org.jetbrains.mps.openapi.module.SModuleId
import org.jetbrains.mps.openapi.module.SModuleReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.IArea
import org.modelix.model.mpsplugin.SModuleUtils
import java.util.LinkedList
import java.util.Objects
import kotlin.jvm.functions.Function0.invoke
import kotlin.jvm.functions.Function1.invoke

/*Generated by MPS */
class SModuleAsNode(module: SModule) : TreeElementAsNode<SModule?>(module) {
    public override fun getArea(): IArea {
        return MPSArea(getElement().getRepository())
    }

    override val concept: IConcept
        get() {
            return (SConceptAdapter.Companion.wrap(CONCEPTS.`Module$4i`))!!
        }

    override fun getChildAccessor(role: String?): IChildAccessor<SModule?>? {
        if ((role == LINKS.`models$h3QT`.getName())) {
            return modelsAccessor
        }
        if ((role == LINKS.`facets$vw9T`.getName())) {
            return facetsAccessor
        }
        if ((role == LINKS.`dependencies$vC8r`.getName())) {
            return dependenciesAccessor
        }
        if ((role == LINKS.`languageDependencies$vKlY`.getName())) {
            return languageDependenciesAccessor
        }
        return super.getChildAccessor(role)
    }

    override fun getPropertyAccessor(role: String): IPropertyAccessor<SModule?>? {
        if ((role == PROPS.`name$MnvL`.getName())) {
            return nameAccessor
        }
        if ((role == PROPS.`id$7MjP`.getName())) {
            return idAccessor
        }
        if ((role == PROPS.`moduleVersion$sDQK`.getName())) {
            return moduleVersionAccessor
        }
        if ((role == PROPS.`compileInMPS$sEzN`.getName())) {
            return compileInMPSAccessor
        }
        if ((role == PROPS.`virtualPackage$EkXl`.getName())) {
            return virtualFolderAccessor
        }
        return super.getPropertyAccessor(role)
    }

    override fun getReferenceAccessor(role: String): IReferenceAccessor<SModule?>? {
        return super.getReferenceAccessor(role)
    }

    override val parent: INode?
        get() {
            if (!(SRepositoryAsNode.Companion.isVisible(getElement()))) {
                return null
            }
            return SRepositoryAsNode(getElement().getRepository())
        }
    override val roleInParent: String?
        get() {
            if (!(SRepositoryAsNode.Companion.isVisible(getElement()))) {
                return null
            }
            return ((if (isTempModule(getElement())) LINKS.`tempModules$Zqoa` else LINKS.`modules$jBPn`)).getName()
        }
    override val reference: INodeReference
        get() {
            return NodeReference(getElement().getModuleReference())
        }

    fun findDependency(dependencyId: SModuleId?): ModuleDependencyAsNode? {
        if (!((getElement() is AbstractModule))) {
            return null
        }
        val moduleDescriptor: ModuleDescriptor? = (getElement() as AbstractModule?)!!.getModuleDescriptor()
        if (moduleDescriptor == null) {
            return null
        }
        for (entry: IMapping<SModuleReference, Int> in MapSequence.fromMap(moduleDescriptor.getDependencyVersions())) {
            if (Objects.equals(entry.key().getModuleId(), dependencyId)) {
                return ModuleDependencyAsNode(
                    entry.key(),
                    entry.value(),
                    isDirectDependency(getElement(), entry.key().getModuleId()),
                    isReexport(getElement(), entry.key().getModuleId()),
                    getElement(),
                    getDependencyScope(getElement(), entry.key().getModuleId())
                )
            }
        }
        return null
    }

    fun findSingleLanguageDependency(dependencyId: SModuleId?): SingleLanguageDependencyAsNode? {
        if (!((getElement() is AbstractModule))) {
            return null
        }
        val moduleDescriptor: ModuleDescriptor? = (getElement() as AbstractModule?)!!.getModuleDescriptor()
        if (moduleDescriptor != null) {
            for (entry: IMapping<SModuleReference, Int> in MapSequence.fromMap(moduleDescriptor.getDependencyVersions())) {
                if (Objects.equals(entry.key().getModuleId(), dependencyId)) {
                    return SingleLanguageDependencyAsNode(entry.key(), entry.value(), getElement())
                }
            }
        }
        return null
    }

    fun findDevKitDependency(dependencyId: SModuleId?): DevKitDependencyAsNode? {
        if (!((getElement() is AbstractModule))) {
            return null
        }
        val moduleDescriptor: ModuleDescriptor? = (getElement() as AbstractModule?)!!.getModuleDescriptor()
        if (moduleDescriptor != null) {
            for (devKit: SModuleReference in CollectionSequence.fromCollection(moduleDescriptor.getUsedDevkits())) {
                if (Objects.equals(devKit.getModuleId(), dependencyId)) {
                    return DevKitDependencyAsNode(devKit, getElement())
                }
            }
        }
        return null
    }

    class NodeReference(val moduleRef: SModuleReference?) : INodeReference {

        public override fun serialize(): String {
            return "mps-module:" + moduleRef
        }

        public override fun resolveNode(area: IArea?): INode? {
            val repo: _T<SRepository?> = _T(null)
            if (area != null) {
                val areas: List<IArea> = area.collectAreas()
                repo.value = ListSequence.fromList(areas).ofType(MPSArea::class.java)
                    .select(object : ISelector<MPSArea, SRepository?>() {
                        public override fun select(it: MPSArea): SRepository? {
                            return it.getRepository()
                        }
                    }).where(NotNullWhereFilter<Any?>() as _return_P1_E0<Boolean?, SRepository>?).first()
            }
            if (repo.value == null) {
                repo.value = MPSModuleRepository.getInstance()
            }
            val resolved: _T<SModule?> = _T(null)
            if (repo.value!!.getModelAccess().canRead()) {
                resolved.value = moduleRef!!.resolve((repo.value)!!)
            } else {
                repo.value!!.getModelAccess().runReadAction(object : Runnable {
                    public override fun run() {
                        resolved.value = moduleRef!!.resolve((repo.value)!!)
                    }
                })
            }
            return (if (resolved.value == null) null else SModuleAsNode(resolved.value!!))
        }

        public override fun equals(o: Any?): Boolean {
            if (this === o) {
                return true
            }
            if (o == null || this.javaClass != o.javaClass) {
                return false
            }
            val that: NodeReference = o as NodeReference
            if ((if (moduleRef != null) !((moduleRef == that.moduleRef)) else that.moduleRef != null)) {
                return false
            }
            return true
        }

        public override fun hashCode(): Int {
            var result: Int = 0
            result = 31 * result + ((if (moduleRef != null) (moduleRef as Any).hashCode() else 0))
            return result
        }
    }

    private object CONCEPTS {
        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module"
        )
    }

    private object LINKS {
        /*package*/
        val `models$h3QT`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x69652614fd1c512L,
            "models"
        )

        /*package*/
        val `facets$vw9T`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde953529916cL,
            "facets"
        )

        /*package*/
        val `dependencies$vC8r`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299179L,
            "dependencies"
        )

        /*package*/
        val `languageDependencies$vKlY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299187L,
            "languageDependencies"
        )

        /*package*/
        val `modules$jBPn`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x69652614fd1c517L,
            "modules"
        )

        /*package*/
        val `tempModules$Zqoa`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x72291b7f31486ecaL,
            "tempModules"
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name"
        )

        /*package*/
        val `id$7MjP`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x3aa34013f2a802e0L,
            "id"
        )

        /*package*/
        val `moduleVersion$sDQK`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299142L,
            "moduleVersion"
        )

        /*package*/
        val `compileInMPS$sEzN`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299145L,
            "compileInMPS"
        )

        /*package*/
        val `virtualPackage$EkXl`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x115eca8579fL,
            "virtualPackage"
        )
    }

    companion object {
        fun isTempModule(module: SModule?): Boolean {
            return module is TempModule || module is TempModule2
        }

        private val nameAccessor: IPropertyAccessor<SModule?> = object : ReadOnlyPropertyAccessor<SModule?>() {
            public override fun get(element: SModule?): String? {
                return element!!.getModuleName()
            }
        }
        private val idAccessor: IPropertyAccessor<SModule?> = object : ReadOnlyPropertyAccessor<SModule?>() {
            public override fun get(element: SModule?): String? {
                return element!!.getModuleId().toString()
            }
        }
        private val virtualFolderAccessor: IPropertyAccessor<SModule?> = object : ReadOnlyPropertyAccessor<SModule?>() {
            public override fun get(element: SModule?): String? {
                val projects: List<Project> = ProjectManager.getInstance().getOpenedProjects()
                val value: String = ListSequence.fromList(projects).ofType(
                    MPSProject::class.java
                ).select(object : ISelector<MPSProject, String?>() {
                    public override fun select(it: MPSProject): String? {
                        return check_jbj149_a0a0a0a0b0a0a0f(it.getPath((element)!!))
                    }
                }).where(NotNullWhereFilter<Any?>() as _return_P1_E0<Boolean?, String>?).first()
                if (("" == value)) return null // default value is returned as not being set to avoid unnecessary synchronization
                return value
            }
        }
        private val moduleVersionAccessor: IPropertyAccessor<SModule?> = object : ReadOnlyPropertyAccessor<SModule?>() {
            public override fun get(element: SModule?): String? {
                val moduleDescriptor: ModuleDescriptor? = (element as AbstractModule?)!!.getModuleDescriptor()
                if (element is AbstractModule) {
                    val version: Int = check_jbj149_a0a0b0a0a0h(moduleDescriptor)
                    if (version == 0) return null // default value is returned as not being set to avoid unnecessary synchronization
                    return version.toString()
                } else {
                    return 0.toString()
                }
            }
        }
        private val compileInMPSAccessor: IPropertyAccessor<SModule?> = object : ReadOnlyPropertyAccessor<SModule?>() {
            public override fun get(element: SModule?): String? {
                if (element is DevKit) {
                    return false.toString()
                }
                if (element is AbstractModule) {
                    try {
                        val value: Boolean = check_jbj149_a0a0a0b0a0a0j(element.getModuleDescriptor())
                        if (value) return null // default value is returned as not being set to avoid unnecessary synchronization
                        return value.toString()
                    } catch (uoe: UnsupportedOperationException) {
                        return false.toString()
                    }
                } else {
                    return false.toString()
                }
            }
        }
        private val modelsAccessor: IChildAccessor<SModule?> = object : IChildAccessor<SModule?> {
            public override fun get(module: SModule?): Iterable<INode> {
                val models: Iterable<SModel?>? = SModuleUtils.getModelsWithoutDescriptor(module)
                return Sequence.fromIterable(models).select<INode>(object : ISelector<SModel, SModelAsNode>() {
                    public override fun select(it: SModel): SModelAsNode {
                        return SModelAsNode(it)
                    }
                })
            }
        }
        private val facetsAccessor: IChildAccessor<SModule?> = object : IChildAccessor<SModule> {
            public override fun get(module: SModule): Iterable<INode> {
                val facets: Iterable<SModuleFacet> = module.getFacets()
                // TODO We ignore facets which are not JavaModuleFacet. In the future we may need to process those too
                return Sequence.fromIterable(facets).where(object : IWhereFilter<SModuleFacet?>() {
                    public override fun accept(it: SModuleFacet?): Boolean {
                        return it is JavaModuleFacet
                    }
                }).select<INode>(object : ISelector<SModuleFacet, JavaModuleFacetAsNode>() {
                    public override fun select(it: SModuleFacet): JavaModuleFacetAsNode {
                        return JavaModuleFacetAsNode((it as JavaModuleFacet))
                    }
                })
            }
        }
        private val dependenciesAccessor: IChildAccessor<SModule?> = object : IChildAccessor<SModule?> {
            public override fun get(module: SModule?): MutableIterable<INode>? {
                if (!((module is AbstractModule))) {
                    return Sequence.fromIterable(emptyList())
                }
                val moduleDescriptor: ModuleDescriptor? = module.getModuleDescriptor()
                val deps: List<INode> = ListSequence.fromList(LinkedList())
                if (moduleDescriptor == null) {
                    return null
                }
                for (depVersion: IMapping<SModuleReference, Int> in MapSequence.fromMap<SModuleReference, Int>(
                    moduleDescriptor.getDependencyVersions()
                )) {
                    ListSequence.fromList(deps).addElement(
                        ModuleDependencyAsNode(
                            depVersion.key(),
                            depVersion.value(),
                            isDirectDependency(module, depVersion.key().getModuleId()),
                            isReexport(module, depVersion.key().getModuleId()),
                            module,
                            getDependencyScope(module, depVersion.key().getModuleId())
                        )
                    )
                }
                return deps
            }
        }
        private val languageDependenciesAccessor: IChildAccessor<SModule?> = object : IChildAccessor<SModule?> {
            public override fun get(module: SModule?): Iterable<INode> {
                if (!((module is AbstractModule))) {
                    return Sequence.fromIterable(emptyList())
                }
                val moduleDescriptor: ModuleDescriptor? = module.getModuleDescriptor()
                val deps: List<INode> = ListSequence.fromList(LinkedList())
                if (moduleDescriptor != null) {
                    for (depVersion: IMapping<SLanguage, Int> in MapSequence.fromMap<SLanguage, Int>(moduleDescriptor.getLanguageVersions())) {
                        ListSequence.fromList(deps).addElement(
                            SingleLanguageDependencyAsNode(
                                depVersion.key().getSourceModuleReference(),
                                depVersion.value(),
                                module
                            )
                        )
                    }
                    for (devKit: SModuleReference in CollectionSequence.fromCollection<SModuleReference>(
                        moduleDescriptor.getUsedDevkits()
                    )) {
                        ListSequence.fromList(deps).addElement(DevKitDependencyAsNode(devKit, module))
                    }
                }
                return deps
            }
        }

        private fun getDependencyScope(module: SModule?, moduleId: SModuleId): SDependencyScope? {
            if (module is Solution) {
                // This gives slightly different results than the getDeclaredDepencies
                val solutionDescriptor: SolutionDescriptor = module.getModuleDescriptor()
                for (dep: Dependency in CollectionSequence.fromCollection(solutionDescriptor.getDependencies())) {
                    if (Objects.equals(dep.getModuleRef().getModuleId(), moduleId)) {
                        return dep.getScope()
                    }
                }
                return null
            }
            for (declaredDep: SDependency in Sequence.fromIterable(
                module!!.getDeclaredDependencies()
            )) {
                if (Objects.equals(declaredDep.getTargetModule().getModuleId(), moduleId)) {
                    return declaredDep.getScope()
                }
            }
            return null
        }

        private fun isDirectDependency(module: SModule?, moduleId: SModuleId): Boolean {
            if (module is Solution) {
                // This gives slightly different results than the getDeclaredDepencies
                val solutionDescriptor: SolutionDescriptor = module.getModuleDescriptor()
                for (dep: Dependency in CollectionSequence.fromCollection(solutionDescriptor.getDependencies())) {
                    if (Objects.equals(dep.getModuleRef().getModuleId(), moduleId)) {
                        return true
                    }
                }
                return false
            }
            for (declaredDep: SDependency in Sequence.fromIterable(
                module!!.getDeclaredDependencies()
            )) {
                if (Objects.equals(declaredDep.getTargetModule().getModuleId(), moduleId)) {
                    return true
                }
            }
            return false
        }

        private fun isReexport(module: SModule?, moduleId: SModuleId): Boolean {
            for (declaredDep: SDependency in Sequence.fromIterable(
                module!!.getDeclaredDependencies()
            )) {
                if (Objects.equals(declaredDep.getTargetModule().getModuleId(), moduleId)) {
                    return declaredDep.isReexport()
                }
            }
            return false
        }

        fun wrap(module: SModule?): SModuleAsNode? {
            return (if (module == null) null else SModuleAsNode(module))
        }

        private fun check_jbj149_a0a0a0a0b0a0a0f(checkedDotOperand: ModulePath?): String? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getVirtualFolder()
            }
            return null
        }

        private fun check_jbj149_a0a0b0a0a0h(checkedDotOperand: ModuleDescriptor?): Int {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getModuleVersion()
            }
            return 0
        }

        private fun check_jbj149_a0a0a0b0a0a0j(checkedDotOperand: ModuleDescriptor?): Boolean {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getCompileInMPS()
            }
            return false
        }
    }
}
