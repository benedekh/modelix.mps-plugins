package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P1_E0
import jetbrains.mps.internal.collections.runtime.CollectionSequence
import jetbrains.mps.internal.collections.runtime.IMapping
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.project.AbstractModule
import jetbrains.mps.project.DevKit
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.project.Solution
import jetbrains.mps.project.facets.JavaModuleFacet
import jetbrains.mps.project.structure.modules.Dependency
import jetbrains.mps.project.structure.modules.ModuleDescriptor
import jetbrains.mps.project.structure.modules.SolutionDescriptor
import jetbrains.mps.project.structure.project.ModulePath
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.smodel.tempmodel.TempModule
import jetbrains.mps.smodel.tempmodel.TempModule2
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SLanguage
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.module.SDependency
import org.jetbrains.mps.openapi.module.SDependencyScope
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleFacet
import org.jetbrains.mps.openapi.module.SModuleId
import org.jetbrains.mps.openapi.module.SModuleReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.IArea
import org.modelix.model.mpsplugin.SModuleUtils
import java.util.LinkedList
import java.util.Objects

/*Generated by MPS */
class SModuleAsNode(module: SModule) : TreeElementAsNode<SModule>(module) {
    override fun getArea(): IArea {
        return MPSArea(element.repository)
    }

    override val concept: IConcept
        get() {
            return (SConceptAdapter.Companion.wrap(CONCEPTS.`Module$4i`))
        }

    override fun getChildAccessor(role: String?): IChildAccessor<SModule>? {
        if ((role == LINKS.`models$h3QT`.name)) {
            return modelsAccessor
        }
        if ((role == LINKS.`facets$vw9T`.name)) {
            return facetsAccessor
        }
        if ((role == LINKS.`dependencies$vC8r`.name)) {
            return dependenciesAccessor
        }
        if ((role == LINKS.`languageDependencies$vKlY`.name)) {
            return languageDependenciesAccessor
        }
        return super.getChildAccessor(role)
    }

    override fun getPropertyAccessor(role: String): IPropertyAccessor<SModule>? {
        if ((role == PROPS.`name$MnvL`.name)) {
            return nameAccessor
        }
        if ((role == PROPS.`id$7MjP`.name)) {
            return idAccessor
        }
        if ((role == PROPS.`moduleVersion$sDQK`.name)) {
            return moduleVersionAccessor
        }
        if ((role == PROPS.`compileInMPS$sEzN`.name)) {
            return compileInMPSAccessor
        }
        if ((role == PROPS.`virtualPackage$EkXl`.name)) {
            return virtualFolderAccessor
        }
        return super.getPropertyAccessor(role)
    }

    override val parent: INode?
        get() {
            if (!(SRepositoryAsNode.Companion.isVisible(element))) {
                return null
            }
            return element.repository?.let { SRepositoryAsNode(it) }
        }
    override val roleInParent: String?
        get() {
            if (!(SRepositoryAsNode.Companion.isVisible(element))) {
                return null
            }
            return ((if (isTempModule(element)) LINKS.`tempModules$Zqoa` else LINKS.`modules$jBPn`)).name
        }
    override val reference: INodeReference
        get() {
            return NodeReference(element.moduleReference)
        }

    fun findDependency(dependencyId: SModuleId?): ModuleDependencyAsNode? {
        if (!((element is AbstractModule))) {
            return null
        }
        val moduleDescriptor: ModuleDescriptor? = (element as AbstractModule?)!!.moduleDescriptor
        if (moduleDescriptor == null) {
            return null
        }
        for (entry: IMapping<SModuleReference, Int> in MapSequence.fromMap(moduleDescriptor.dependencyVersions)) {
            if (Objects.equals(entry.key().moduleId, dependencyId)) {
                return ModuleDependencyAsNode(
                    entry.key(),
                    entry.value(),
                    isDirectDependency(element, entry.key().moduleId),
                    isReexport(element, entry.key().moduleId),
                    element,
                    getDependencyScope(element, entry.key().moduleId),
                )
            }
        }
        return null
    }

    fun findSingleLanguageDependency(dependencyId: SModuleId?): SingleLanguageDependencyAsNode? {
        if (!((element is AbstractModule))) {
            return null
        }
        val moduleDescriptor: ModuleDescriptor? = (element as AbstractModule?)!!.moduleDescriptor
        if (moduleDescriptor != null) {
            for (entry: IMapping<SModuleReference, Int> in MapSequence.fromMap(moduleDescriptor.dependencyVersions)) {
                if (Objects.equals(entry.key().moduleId, dependencyId)) {
                    return SingleLanguageDependencyAsNode(entry.key(), entry.value(), element)
                }
            }
        }
        return null
    }

    fun findDevKitDependency(dependencyId: SModuleId?): DevKitDependencyAsNode? {
        if (!((element is AbstractModule))) {
            return null
        }
        val moduleDescriptor: ModuleDescriptor? = (element as AbstractModule?)!!.moduleDescriptor
        if (moduleDescriptor != null) {
            for (devKit: SModuleReference in CollectionSequence.fromCollection(moduleDescriptor.usedDevkits)) {
                if (Objects.equals(devKit.moduleId, dependencyId)) {
                    return DevKitDependencyAsNode(devKit, element)
                }
            }
        }
        return null
    }

    class NodeReference(val moduleRef: SModuleReference) : INodeReference {

        override fun serialize(): String {
            return "mps-module:" + moduleRef
        }

        override fun resolveNode(area: IArea?): INode? {
            val repo: _T<SRepository?> = _T(null)
            if (area != null) {
                val areas: List<IArea> = area.collectAreas()
                repo.value = ListSequence.fromList(areas).ofType(MPSArea::class.java)
                    .select(object : ISelector<MPSArea, SRepository?>() {
                        override fun select(it: MPSArea): SRepository {
                            return it.repository
                        }
                    }).where(NotNullWhereFilter<Any?>() as _return_P1_E0<Boolean?, SRepository?>?).first()
            }
            if (repo.value == null) {
                repo.value = MPSModuleRepository.getInstance()
            }
            val resolved: _T<SModule?> = _T(null)
            if (repo.value!!.modelAccess.canRead()) {
                resolved.value = moduleRef.resolve((repo.value)!!)
            } else {
                repo.value!!.modelAccess.runReadAction(object : Runnable {
                    override fun run() {
                        resolved.value = moduleRef.resolve((repo.value)!!)
                    }
                })
            }
            return (if (resolved.value == null) null else SModuleAsNode(resolved.value!!))
        }

        override fun equals(o: Any?): Boolean {
            if (this === o) {
                return true
            }
            if (o == null || this.javaClass != o.javaClass) {
                return false
            }
            val that: NodeReference = o as NodeReference
            return !(if (moduleRef != null) !((moduleRef == that.moduleRef)) else that.moduleRef != null)
        }

        override fun hashCode(): Int {
            var result: Int = 0
            result = 31 * result + ((if (moduleRef != null) (moduleRef as Any).hashCode() else 0))
            return result
        }
    }

    private object CONCEPTS {
        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module",
        )
    }

    private object LINKS {
        /*package*/
        val `models$h3QT`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x69652614fd1c512L,
            "models",
        )

        /*package*/
        val `facets$vw9T`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde953529916cL,
            "facets",
        )

        /*package*/
        val `dependencies$vC8r`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299179L,
            "dependencies",
        )

        /*package*/
        val `languageDependencies$vKlY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299187L,
            "languageDependencies",
        )

        /*package*/
        val `modules$jBPn`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x69652614fd1c517L,
            "modules",
        )

        /*package*/
        val `tempModules$Zqoa`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x72291b7f31486ecaL,
            "tempModules",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )

        /*package*/
        val `id$7MjP`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x3aa34013f2a802e0L,
            "id",
        )

        /*package*/
        val `moduleVersion$sDQK`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299142L,
            "moduleVersion",
        )

        /*package*/
        val `compileInMPS$sEzN`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299145L,
            "compileInMPS",
        )

        /*package*/
        val `virtualPackage$EkXl`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x10802efe25aL,
            0x115eca8579fL,
            "virtualPackage",
        )
    }

    companion object {
        fun isTempModule(module: SModule?): Boolean {
            return module is TempModule || module is TempModule2
        }

        private val nameAccessor: IPropertyAccessor<SModule> = object : ReadOnlyPropertyAccessor<SModule>() {
            override fun get(element: SModule): String? {
                return element.moduleName
            }
        }
        private val idAccessor: IPropertyAccessor<SModule> = object : ReadOnlyPropertyAccessor<SModule>() {
            override fun get(element: SModule): String {
                return element.moduleId.toString()
            }
        }
        private val virtualFolderAccessor: IPropertyAccessor<SModule> = object : ReadOnlyPropertyAccessor<SModule>() {
            override fun get(element: SModule): String? {
                val projects: List<Project> = ProjectManager.getInstance().openedProjects
                val value: String? = ListSequence.fromList(projects).ofType(
                    MPSProject::class.java,
                ).select(object : ISelector<MPSProject, String?>() {
                    override fun select(it: MPSProject): String? {
                        return check_jbj149_a0a0a0a0b0a0a0f(it.getPath((element)))
                    }
                }).where(NotNullWhereFilter<Any?>() as _return_P1_E0<Boolean?, String?>?).first()
                if (("" == value)) return null // default value is returned as not being set to avoid unnecessary synchronization
                return value
            }
        }
        private val moduleVersionAccessor: IPropertyAccessor<SModule> = object : ReadOnlyPropertyAccessor<SModule>() {
            override fun get(element: SModule): String? {
                val moduleDescriptor: ModuleDescriptor? = (element as AbstractModule?)!!.moduleDescriptor
                if (element is AbstractModule) {
                    val version: Int = check_jbj149_a0a0b0a0a0h(moduleDescriptor)
                    if (version == 0) return null // default value is returned as not being set to avoid unnecessary synchronization
                    return version.toString()
                } else {
                    return 0.toString()
                }
            }
        }
        private val compileInMPSAccessor: IPropertyAccessor<SModule> = object : ReadOnlyPropertyAccessor<SModule>() {
            override fun get(element: SModule): String? {
                if (element is DevKit) {
                    return false.toString()
                }
                if (element is AbstractModule) {
                    try {
                        val value: Boolean = check_jbj149_a0a0a0b0a0a0j(element.moduleDescriptor)
                        if (value) return null // default value is returned as not being set to avoid unnecessary synchronization
                        return value.toString()
                    } catch (uoe: UnsupportedOperationException) {
                        return false.toString()
                    }
                } else {
                    return false.toString()
                }
            }
        }
        private val modelsAccessor: IChildAccessor<SModule> = object : IChildAccessor<SModule> {
            override fun get(module: SModule): Iterable<INode> {
                val models: Iterable<SModel?> = SModuleUtils.getModelsWithoutDescriptor(module)
                return Sequence.fromIterable(models).select<INode>(object : ISelector<SModel, SModelAsNode>() {
                    override fun select(it: SModel): SModelAsNode {
                        return SModelAsNode(it)
                    }
                })
            }
        }
        private val facetsAccessor: IChildAccessor<SModule> = object : IChildAccessor<SModule> {
            override fun get(module: SModule): Iterable<INode> {
                val facets: Iterable<SModuleFacet> = module.facets
                // TODO We ignore facets which are not JavaModuleFacet. In the future we may need to process those too
                return Sequence.fromIterable(facets).where(object : IWhereFilter<SModuleFacet?>() {
                    override fun accept(it: SModuleFacet?): Boolean {
                        return it is JavaModuleFacet
                    }
                }).select<INode>(object : ISelector<SModuleFacet, JavaModuleFacetAsNode>() {
                    override fun select(it: SModuleFacet): JavaModuleFacetAsNode {
                        return JavaModuleFacetAsNode((it as JavaModuleFacet))
                    }
                })
            }
        }
        private val dependenciesAccessor: IChildAccessor<SModule> = object : IChildAccessor<SModule> {
            override fun get(module: SModule): Iterable<INode> {
                if (!((module is AbstractModule))) {
                    return Sequence.fromIterable(emptyList())
                }
                val moduleDescriptor: ModuleDescriptor? = module.moduleDescriptor
                val deps: List<INode> = ListSequence.fromList(LinkedList())
                if (moduleDescriptor == null) {
                    return emptyList()
                }
                for (depVersion: IMapping<SModuleReference, Int> in MapSequence.fromMap<SModuleReference, Int>(
                    moduleDescriptor.dependencyVersions,
                )) {
                    ListSequence.fromList(deps).addElement(
                        ModuleDependencyAsNode(
                            depVersion.key(),
                            depVersion.value(),
                            isDirectDependency(module, depVersion.key().moduleId),
                            isReexport(module, depVersion.key().moduleId),
                            module,
                            getDependencyScope(module, depVersion.key().moduleId),
                        ),
                    )
                }
                return deps
            }
        }
        private val languageDependenciesAccessor: IChildAccessor<SModule> = object : IChildAccessor<SModule> {
            override fun get(module: SModule): Iterable<INode> {
                if (!((module is AbstractModule))) {
                    return Sequence.fromIterable(emptyList())
                }
                val moduleDescriptor: ModuleDescriptor? = module.moduleDescriptor
                val deps: List<INode> = ListSequence.fromList(LinkedList())
                if (moduleDescriptor != null) {
                    for (depVersion: IMapping<SLanguage, Int> in MapSequence.fromMap<SLanguage, Int>(moduleDescriptor.languageVersions)) {
                        ListSequence.fromList(deps).addElement(
                            SingleLanguageDependencyAsNode(
                                depVersion.key().sourceModuleReference,
                                depVersion.value(),
                                module,
                            ),
                        )
                    }
                    for (devKit: SModuleReference in CollectionSequence.fromCollection<SModuleReference>(
                        moduleDescriptor.usedDevkits,
                    )) {
                        ListSequence.fromList(deps).addElement(DevKitDependencyAsNode(devKit, module))
                    }
                }
                return deps
            }
        }

        private fun getDependencyScope(module: SModule?, moduleId: SModuleId): SDependencyScope? {
            if (module is Solution) {
                // This gives slightly different results than the getDeclaredDepencies
                val solutionDescriptor: SolutionDescriptor = module.moduleDescriptor
                for (dep: Dependency in CollectionSequence.fromCollection(solutionDescriptor.dependencies)) {
                    if (Objects.equals(dep.moduleRef.moduleId, moduleId)) {
                        return dep.scope
                    }
                }
                return null
            }
            for (declaredDep: SDependency in Sequence.fromIterable(
                module!!.declaredDependencies,
            )) {
                if (Objects.equals(declaredDep.targetModule.moduleId, moduleId)) {
                    return declaredDep.scope
                }
            }
            return null
        }

        private fun isDirectDependency(module: SModule?, moduleId: SModuleId): Boolean {
            if (module is Solution) {
                // This gives slightly different results than the getDeclaredDepencies
                val solutionDescriptor: SolutionDescriptor = module.moduleDescriptor
                for (dep: Dependency in CollectionSequence.fromCollection(solutionDescriptor.dependencies)) {
                    if (Objects.equals(dep.moduleRef.moduleId, moduleId)) {
                        return true
                    }
                }
                return false
            }
            for (declaredDep: SDependency in Sequence.fromIterable(
                module!!.declaredDependencies,
            )) {
                if (Objects.equals(declaredDep.targetModule.moduleId, moduleId)) {
                    return true
                }
            }
            return false
        }

        private fun isReexport(module: SModule?, moduleId: SModuleId): Boolean {
            for (declaredDep: SDependency in Sequence.fromIterable(
                module!!.declaredDependencies,
            )) {
                if (Objects.equals(declaredDep.targetModule.moduleId, moduleId)) {
                    return declaredDep.isReexport
                }
            }
            return false
        }

        fun wrap(module: SModule?): SModuleAsNode? {
            return (if (module == null) null else SModuleAsNode(module))
        }

        private fun check_jbj149_a0a0a0a0b0a0a0f(checkedDotOperand: ModulePath?): String? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.virtualFolder
            }
            return null
        }

        private fun check_jbj149_a0a0b0a0a0h(checkedDotOperand: ModuleDescriptor?): Int {
            if (null != checkedDotOperand) {
                return checkedDotOperand.moduleVersion
            }
            return 0
        }

        private fun check_jbj149_a0a0a0b0a0a0j(checkedDotOperand: ModuleDescriptor?): Boolean {
            if (null != checkedDotOperand) {
                return checkedDotOperand.compileInMPS
            }
            return false
        }
    }
}
