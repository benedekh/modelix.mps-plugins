package org.modelix.model.mpsadapters.mps

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._void_P1_E0
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.smodel.adapter.ids.MetaIdHelper
import jetbrains.mps.smodel.adapter.ids.SConceptId
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.smodel.language.ConceptRegistry
import jetbrains.mps.smodel.runtime.ConceptDescriptor
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.modelix.model.api.IConcept
import java.util.Objects

/*Generated by MPS */
class BootstrapConceptMappings() {
    private var sconcept2uid: Map<SConceptId, String> = MapSequence.fromMap(HashMap())
    private var uid2sconcept: Map<String, SConceptId> = MapSequence.fromMap(HashMap())
    private var concepts: Map<String, IConcept> = MapSequence.fromMap(HashMap())
    fun register(concept: IConcept, sconcept: SAbstractConcept?) {
        register(concept, MetaIdHelper.getConcept(sconcept))
    }

    fun unregister(concept: IConcept, sconcept: SAbstractConcept?) {
        unregister(concept, MetaIdHelper.getConcept(sconcept))
    }

    @Synchronized
    fun register(concept: IConcept, sconceptId: SConceptId) {
        val uid: String = concept.getUID()
        uid2sconcept = modifyCopy<String, SConceptId>(
            uid2sconcept,
            object : _void_P1_E0<Map<String, SConceptId>?> {
                public override fun invoke(copy: Map<String, SConceptId>?) {
                    MapSequence.fromMap(copy).put(uid, sconceptId)
                }
            },
        )
        sconcept2uid = modifyCopy<SConceptId, String>(
            sconcept2uid,
            object : _void_P1_E0<Map<SConceptId, String>?> {
                public override fun invoke(copy: Map<SConceptId, String>?) {
                    MapSequence.fromMap(copy).put(sconceptId, uid)
                }
            },
        )
        concepts = modifyCopy<String, IConcept>(
            concepts,
            object : _void_P1_E0<Map<String, IConcept>?> {
                public override fun invoke(copy: Map<String, IConcept>?) {
                    MapSequence.fromMap(copy).put(uid, concept)
                }
            },
        )
    }

    @Synchronized
    fun unregister(concept: IConcept, sconceptId: SConceptId) {
        val uid: String = concept.getUID()
        if (!(Objects.equals(getSConceptId(uid), sconceptId))) {
            throw RuntimeException("Attempt to unregister " + uid + " = " + sconceptId + " while " + getSConceptId(uid) + " was registered")
        }
        uid2sconcept = modifyCopy<String, SConceptId>(
            uid2sconcept,
            object : _void_P1_E0<Map<String, SConceptId>?> {
                public override fun invoke(copy: Map<String, SConceptId>?) {
                    MapSequence.fromMap(copy).removeKey(uid)
                }
            },
        )
        sconcept2uid = modifyCopy(
            sconcept2uid,
            object : _void_P1_E0<Map<SConceptId, String>?> {
                public override fun invoke(copy: Map<SConceptId, String>?) {
                    MapSequence.fromMap(copy).removeKey(sconceptId)
                }
            },
        )
        concepts = modifyCopy<String, IConcept>(
            concepts,
            object : _void_P1_E0<Map<String, IConcept>?> {
                public override fun invoke(copy: Map<String, IConcept>?) {
                    MapSequence.fromMap(copy).removeKey(uid)
                }
            },
        )
    }

    fun getSConcept(concept: IConcept?): SAbstractConcept? {
        val sconceptId: SConceptId? = getSConceptId(concept!!.getUID())
        if (sconceptId == null) {
            return null
        }
        val conceptDescriptor: ConceptDescriptor = ConceptRegistry.getInstance().getConceptDescriptor(sconceptId)
        if (conceptDescriptor is IllegalConceptDescriptor) {
            return null
        }
        return MetaAdapterFactory.getAbstractConcept(conceptDescriptor)
    }

    fun getConcept(concept: SAbstractConcept?): IConcept? {
        val sconceptId: SConceptId = MetaIdHelper.getConcept(concept)
        val uid: String? = getUID(sconceptId)
        if (uid == null) {
            return null
        }
        return MapSequence.fromMap(concepts).get(uid)
    }

    fun getSConceptId(uid: String): SConceptId? {
        return MapSequence.fromMap(uid2sconcept).get(uid)
    }

    fun getUID(sconceptId: SConceptId): String? {
        return MapSequence.fromMap(sconcept2uid).get(sconceptId)
    }

    private fun <K, V> modifyCopy(map: Map<K, V>, modifier: _void_P1_E0<in Map<K, V>>): Map<K, V> {
        val copy: Map<K, V> = MapSequence.fromMap(HashMap())
        MapSequence.fromMap(copy).putAll(map)
        modifier.invoke(copy)
        return copy
    }

    companion object {
        val INSTANCE: BootstrapConceptMappings = BootstrapConceptMappings()
    }
}
