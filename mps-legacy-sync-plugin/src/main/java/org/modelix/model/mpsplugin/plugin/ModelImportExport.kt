package org.modelix.model.mpsplugin.plugin

import com.intellij.openapi.application.ApplicationManager
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.IterableUtils
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.messages.IMessage
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.StandaloneMPSProject
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.jetbrains.mps.openapi.module.SModule
import org.modelix.common.PropertyOrEnv
import org.modelix.model.api.IConcept
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.client.IModelClient
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsplugin.Binding
import org.modelix.model.mpsplugin.ModelCloudExporter
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.mpsplugin.ModelServerConnections
import org.modelix.model.mpsplugin.ProjectBinding
import org.modelix.model.mpsplugin.SyncDirection
import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.PrintWriter
import java.io.StringWriter
import java.net.Socket
import java.util.function.Consumer

/*Generated by MPS */
class ModelImportExport() {
    fun cloud2mps() {
        val exportPath = PropertyOrEnv.get(ModelixExportConfiguration.PATH)
        println("Modelix Application Plugin - export path: $exportPath")
        if ((exportPath == null || exportPath.length == 0)) {
            System.err.println(ModelixExportConfiguration.PATH + " not provided")
            System.exit(1)
        }
        try {
            println("Modelix Application Plugin - Starting model export ...")
            System.setProperty(ModelixExportConfiguration.STARTED, "true")
            val modelServerURL = PropertyOrEnv.get(ModelixExportConfiguration.SERVER_URL)
            println("Modelix Application Plugin - consider gradle task connection")
            val socketPortStr = PropertyOrEnv.get(ModelixExportConfiguration.GRADLE_PLUGIN_SOCKET_PORT)
            val gradleTaskOut = _T<PrintWriter>()
            if (socketPortStr != null && !((socketPortStr == null || socketPortStr.length == 0))) {
                println("Modelix Application Plugin - connecting to gradle task on port $socketPortStr")
                val gradleTaskPort = socketPortStr.toInt()
                val gradleTaskClient = Socket("127.0.0.1", gradleTaskPort)
                gradleTaskOut.value = PrintWriter(gradleTaskClient.getOutputStream(), true)
                val gradleTaskIn = BufferedReader(InputStreamReader(gradleTaskClient.getInputStream()))
            } else {
                println("Modelix Application Plugin - connecting to gradle task not requested")
                val sw = StringWriter()
                gradleTaskOut.value = PrintWriter(sw, true)
            }
            println("Modelix Application Plugin - gradle task considered")
            val modelServerConnection: ModelServerConnection =
                ModelServerConnections.instance.ensureModelServerIsPresent(modelServerURL)
            println("Modelix Application Plugin - Waiting for Model Server Connection")
            modelServerConnection.whenConnected(object : Consumer<ModelServerConnection> {
                override fun accept(connection: ModelServerConnection) {
                    println("Modelix Application Plugin - Connected, starting ModelCloudExporter")
                    ApplicationManager.getApplication().invokeLaterOnWriteThread(object : Runnable {
                        override fun run() {
                            ApplicationManager.getApplication().runWriteAction(object : Runnable {
                                override fun run() {
                                    try {
                                        val modelCloudExporter = ModelCloudExporter(
                                            modelServerURL,
                                            PropertyOrEnv.get(ModelixExportConfiguration.REPOSITORY_ID),
                                            PropertyOrEnv.get(ModelixExportConfiguration.BRANCH_NAME),
                                        ).setCheckoutMode()
                                        val stuffToDoOnceWeGetAProject: Consumer<Project> =
                                            object : Consumer<Project> {
                                                override fun accept(mpsProject: Project) {
                                                    println("Modelix Application Plugin - Got the project: $mpsProject")
                                                    val runExport: Runnable = object : Runnable {
                                                        override fun run() {
                                                            ApplicationManager.getApplication()
                                                                .invokeLater(object : Runnable {
                                                                    override fun run() {
                                                                        println("========================================================")
                                                                        println("Modelix Application Plugin - Running the actual exporter")
                                                                        println("========================================================")
                                                                        mpsProject.repository.modelAccess.executeCommand(
                                                                            Runnable {
                                                                                try {
                                                                                    modelCloudExporter!!.setCheckoutMode()
                                                                                        .export(exportPath, mpsProject)
                                                                                    // Application.exit does not let us set a proper exit code, therefore we communicate
                                                                                    // we failed or managed to export through strings...
                                                                                    println("DOWNLOAD TASK WRITING " + "<MODEL EXPORT COMPLETED SUCCESSFULLY>\n")
                                                                                    gradleTaskOut.value.println("<MODEL EXPORT COMPLETED SUCCESSFULLY>")
                                                                                } catch (t: Throwable) {
                                                                                    t.printStackTrace()
                                                                                    println("CHECKOUT FAILED")
                                                                                    // Application.exit does not let us set a proper exit code, therefore we communicate
                                                                                    // we failed or managed to export through strings...
                                                                                    println("DOWNLOAD TASK WRITING " + "<MODEL EXPORT NOT COMPLETED SUCCESSFULLY>\n")
                                                                                    gradleTaskOut.value.println("<MODEL EXPORT NOT COMPLETED SUCCESSFULLY>")
                                                                                }
                                                                            },
                                                                        )
                                                                        System.setProperty(
                                                                            ModelixExportConfiguration.DONE,
                                                                            "true",
                                                                        )
                                                                        println("Starting shut down of Application")
                                                                        ApplicationManager.getApplication()
                                                                            .invokeLater(object : Runnable {
                                                                                override fun run() {
                                                                                    ApplicationManager.getApplication()
                                                                                        .exit(true, true, false)
                                                                                }
                                                                            })
                                                                    }
                                                                })
                                                        }
                                                    }
                                                    val make = PropertyOrEnv.get(ModelixExportConfiguration.MAKE)
                                                    if (make == null) {
                                                        println("Modelix Application Plugin - No need to run make")
                                                        runExport.run()
                                                    } else {
                                                        println("Modelix Application Plugin - Running make before export")
                                                        var modulesToBuild: List<SModule>? = null
                                                        if ((make == "all")) {
                                                            modulesToBuild = ListSequence.fromListWithValues(
                                                                ArrayList(),
                                                                mpsProject.projectModules as Iterable<SModule>,
                                                            )
                                                        } else {
                                                            modulesToBuild = ListSequence.fromList(
                                                                ListSequence.fromListWithValues(
                                                                    ArrayList(),
                                                                    mpsProject.projectModules as Iterable<SModule>,
                                                                ),
                                                            ).where(object : IWhereFilter<SModule>() {
                                                                override fun accept(it: SModule): Boolean {
                                                                    val virtualFolder =
                                                                        (mpsProject as StandaloneMPSProject).getFolderFor(
                                                                            it,
                                                                        )
                                                                    println("Modelix Application Plugin - Considering module: " + it.moduleName + " virtual folder: " + virtualFolder + ", make is currently: " + make)
                                                                    return Sequence.fromIterable<String>(
                                                                        Sequence.fromArray<String>(
                                                                            *make.split(",".toRegex())
                                                                                .dropLastWhile { it.isEmpty() }
                                                                                .toTypedArray(),
                                                                        ),
                                                                    )
                                                                        .any(object : IWhereFilter<String?>() {
                                                                            override fun accept(it: String?): Boolean {
                                                                                return (virtualFolder == it)
                                                                            }
                                                                        })
                                                                }
                                                            }).toListSequence()
                                                        }
                                                        println(
                                                            "Modelix Application Plugin - Modules to be built: " + IterableUtils.join(
                                                                ListSequence.fromList(modulesToBuild)
                                                                    .select(object : ISelector<SModule, String?>() {
                                                                        override fun select(it: SModule): String? {
                                                                            return it.moduleName
                                                                        }
                                                                    }),
                                                                ", ",
                                                            ),
                                                        )
                                                        ProjectMakeRunner.execute(
                                                            mpsProject,
                                                            false,
                                                            modulesToBuild,
                                                            object : Consumer<Tuples._2<String, List<IMessage>>> {
                                                                override fun accept(res: Tuples._2<String, List<IMessage>>) {
                                                                    println("========================================================")
                                                                    println("Modelix Application Plugin - Make completed successfully")
                                                                    println("========================================================")
                                                                    if (LOG.isDebugEnabled) {
                                                                        LOG.debug("Make messages:")
                                                                    }
                                                                    for (message: IMessage in ListSequence.fromList(res._1())) {
                                                                        if (LOG.isDebugEnabled) {
                                                                            LOG.debug("  <MAKE> " + message.kind + " " + message.text)
                                                                        }
                                                                    }
                                                                    if (LOG.isInfoEnabled) {
                                                                        LOG.info("Make Project Success: " + res._0())
                                                                    }
                                                                    println("========================================================")
                                                                    println("Modelix Application Plugin - Make completed successfully")
                                                                    println("========================================================")
                                                                    runExport.run()
                                                                }
                                                            },
                                                            object : Consumer<Tuples._2<String?, List<IMessage>>> {
                                                                override fun accept(res: Tuples._2<String?, List<IMessage>>) {
                                                                    println("========================================")
                                                                    println("Modelix Application Plugin - Make failed")
                                                                    println("  make message should follow:")
                                                                    println("========================================")
                                                                    if (LOG.isDebugEnabled) {
                                                                        LOG.debug("Make messages:")
                                                                    }
                                                                    for (message: IMessage in ListSequence.fromList(res._1())) {
                                                                        if (LOG.isInfoEnabled) {
                                                                            LOG.info("  <MAKE> " + message.kind + " " + message.text)
                                                                        }
                                                                        println("  <MAKE> " + message.kind + " " + message.text)
                                                                    }
                                                                    if (LOG.isEnabledFor(Level.WARN)) {
                                                                        LOG.warn("Make Project Failure: " + res._0())
                                                                    }
                                                                    println("========================================")

                                                                    // We try to export anyway
                                                                    runExport.run()
                                                                }
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        ProjectManagerExtensions.withTheOnlyProject(
                                            stuffToDoOnceWeGetAProject,
                                        )
                                    } catch (ex: Exception) {
                                        if (LOG.isEnabledFor(Level.ERROR)) {
                                            LOG.error("Modelix Application Plugin Failure", ex)
                                        }
                                        // Application.exit does not let us set a proper exit code, therefore we communicate
                                        // we failed or managed to export through strings...
                                        println("<MODEL EXPORT NOT COMPLETED SUCCESSFULLY>")
                                        ApplicationManager.getApplication().exit(true, true, false)
                                    }
                                }
                            })
                        }
                    })
                }
            })
        } catch (ex: Exception) {
            ex.printStackTrace()
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Modelix Application Plugin Failure", ex)
            }
            System.exit(1)
        }
    }

    fun mps2cloud() {
        try {
            println("Modelix Application Plugin - Starting model import ...")
            System.setProperty(ModelixImportConfiguration.STARTED, "true")
            val modelServerURL = PropertyOrEnv.get(ModelixImportConfiguration.SERVER_URL)
            val modelServerConnection: ModelServerConnection =
                ModelServerConnections.instance.ensureModelServerIsPresent(modelServerURL)
            println("Modelix Application Plugin - Waiting for Model Server Connection")
            modelServerConnection.whenConnected(object : Consumer<ModelServerConnection> {
                override fun accept(connection: ModelServerConnection) {
                    println("Modelix Application Plugin - Connected, starting model import")
                    ApplicationManager.getApplication().invokeLaterOnWriteThread(object : Runnable {
                        override fun run() {
                            ApplicationManager.getApplication().runWriteAction(object : Runnable {
                                override fun run() {
                                    try {
                                        ProjectManagerExtensions.withTheOnlyProject(
                                            object : Consumer<Project> {
                                                override fun accept(project: Project) {
                                                    println("Project " + project.name + " opened")
                                                    for (module: SModule in ListSequence.fromList(project.projectModules)) {
                                                        println("Project module: " + module.moduleName)
                                                    }
                                                    val repositoryId =
                                                        RepositoryId((PropertyOrEnv.get(ModelixImportConfiguration.REPOSITORY_ID))!!)
                                                    val activeBranch = connection.getActiveBranch(repositoryId)
                                                    activeBranch!!.switchBranch(
                                                        PropertyOrEnv.getOrElse(
                                                            ModelixImportConfiguration.BRANCH_NAME,
                                                            RepositoryId.DEFAULT_BRANCH,
                                                        ),
                                                    )
                                                    val projectNodeId =
                                                        activeBranch.branch.computeWriteT<Long> { t: IWriteTransaction ->
                                                            val allChildren: Iterable<Long> =
                                                                t.getAllChildren(ITree.ROOT_ID)
                                                            val projectConcept: IConcept? =
                                                                SConceptAdapter.Companion.wrap(CONCEPTS.`Project$An`)
                                                            var id: Long? = Sequence.fromIterable<Long>(allChildren)
                                                                .findFirst(object : IWhereFilter<Long?>() {
                                                                    override fun accept(it: Long?): Boolean {
                                                                        return check_d5jcfl_a0a0a0a2a0a0a6a0a0a0a0a0a0a0a0a0a1a0a0f0a0c(
                                                                            t.getConcept(
                                                                                (it)!!,
                                                                            ),
                                                                            projectConcept,
                                                                        )
                                                                    }
                                                                })
                                                            if (id == null) {
                                                                id = t.addNewChild(
                                                                    ITree.ROOT_ID,
                                                                    "projects",
                                                                    -1,
                                                                    projectConcept,
                                                                )
                                                            }
                                                            id
                                                        }
                                                    val binding = ProjectBinding(
                                                        project as MPSProject,
                                                        projectNodeId,
                                                        SyncDirection.TO_CLOUD,
                                                    )
                                                    connection.addBinding(
                                                        repositoryId,
                                                        binding,
                                                        object : Runnable {
                                                            override fun run() {
                                                                waitForWriteToModelServer(
                                                                    binding,
                                                                    connection.getClient(),
                                                                    object : Runnable {
                                                                        override fun run() {
                                                                            println("<MODEL IMPORT COMPLETED SUCCESSFULLY>")
                                                                            ApplicationManager.getApplication()
                                                                                .invokeLater(object : Runnable {
                                                                                    override fun run() {
                                                                                        ApplicationManager.getApplication()
                                                                                            .exit(true, true, false)
                                                                                    }
                                                                                })
                                                                        }
                                                                    },
                                                                )
                                                            }
                                                        },
                                                    )
                                                }
                                            },
                                        )
                                    } catch (ex: Exception) {
                                        if (LOG.isEnabledFor(Level.ERROR)) {
                                            LOG.error("Modelix Application Plugin Failure", ex)
                                        }
                                        // Application.exit does not let us set a proper exit code, therefore we communicate
                                        // we failed or managed to export through strings...
                                        println("<MODEL IMPORT FAILED>")
                                        ApplicationManager.getApplication().exit(true, true, false)
                                    }
                                }
                            })
                        }
                    })
                }
            })
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Modelix Application Plugin Failure", ex)
            }
            System.exit(1)
        }
    }

    private fun waitForWriteToModelServer(binding: Binding, client: IModelClient?, whenDone: Runnable) {
        ApplicationManager.getApplication().executeOnPooledThread(object : Runnable {
            override fun run() {
                try {
                    val condition: _return_P0_E0<out Boolean> = object : _return_P0_E0<Boolean> {
                        override fun invoke(): Boolean {
                            return (client!!.getPendingSize() == 0) && (client.asyncStore.getPendingSize() == 0) && binding.isDone
                        }
                    }
                    while (true) {
                        Thread.sleep(1000)
                        if (!(condition.invoke())) {
                            continue
                        }
                        Thread.sleep(1000)
                        if (!(condition.invoke())) {
                            continue
                        }
                        Thread.sleep(1000)
                        if (!(condition.invoke())) {
                            continue
                        }
                        break
                    }
                    whenDone.run()
                } catch (e: InterruptedException) {
                }
            }
        })
    }

    private object CONCEPTS {
        /*package*/
        val `Project$An` = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            "org.modelix.model.repositoryconcepts.structure.Project",
        )
    }

    companion object {
        private val LOG = LogManager.getLogger(ModelImportExport::class.java)
        private fun check_d5jcfl_a0a0a0a2a0a0a6a0a0a0a0a0a0a0a0a0a1a0a0f0a0c(
            checkedDotOperand: IConcept?,
            projectConcept: IConcept?,
        ): Boolean {
            return if (null != checkedDotOperand) {
                checkedDotOperand.isSubConceptOf(projectConcept)
            } else {
                false
            }
        }
    }
}
