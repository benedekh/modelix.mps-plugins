package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.module.ModuleDeleteHelper
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.ModuleId
import jetbrains.mps.project.Solution
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleId
import org.jetbrains.mps.openapi.persistence.PersistenceFacade
import org.modelix.model.api.IConcept
import org.modelix.model.api.IProperty
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.lazy.unwrap
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SModuleAsNode
import java.util.Objects

/*Generated by MPS */
class ProjectModulesSynchronizer(cloudParentId: Long, val project: MPSProject) :
    Synchronizer<SModule>(cloudParentId, LINKS.`modules$Bi3g`.name) {

    override val mPSChildren: Iterable<SModule>
        get() {
            val projectModules: List<SModule> = project.projectModules
            return ListSequence.fromList(projectModules).where(object : IWhereFilter<SModule?>() {
                override fun accept(it: SModule?): Boolean {
                    return it is Solution
                }
            })
        }

    override fun getCloudChildren(tree: ITree): Iterable<Long> {
        return Sequence.fromIterable<Long?>(super.getCloudChildren(tree)).where(object : IWhereFilter<Long?>() {
            override fun accept(it: Long?): Boolean {
                val concept: IConcept? = tree.getConcept((it)!!)
                return concept!!.isExactly(SConceptAdapter.Companion.wrap(CONCEPTS.`Module$4i`)) || concept.isSubConceptOf(
                    SConceptAdapter.Companion.wrap(CONCEPTS.`Solution$q3`),
                )
            }
        })
    }

    override fun createMPSChild(tree: ITree, cloudChildId: Long): SModule? {
        var id: SModuleId? = getModuleId(tree, cloudChildId)
        if (id == null) {
            id = ModuleId.foreign("cloud-" + cloudChildId)
        }
        val name: String? = tree.getProperty(cloudChildId, PROPS.`name$MnvL`.name)
        val concept: IConcept? = tree.getConcept(cloudChildId)
        return createModule(name, id, cloudChildId, SConceptAdapter.Companion.unwrap(concept))
    }

    protected fun createModule(name: String?, id: SModuleId?, modelNodeId: Long, type: SAbstractConcept?): SModule? {
        if (type!!.isSubConceptOf(CONCEPTS.`Language$qy`)) {
            return null
        } else if (type.isSubConceptOf(CONCEPTS.`DevKit$r1`)) {
            return null
        } else {
            return MPSProjectUtils.createModule(project, name, id as ModuleId?, this)
        }
    }

    override fun removeMPSChild(mpsChild: SModule) {
        ModuleDeleteHelper((project)).deleteModules(listOf(mpsChild), false, true)
        project.removeModule((mpsChild))
    }

    override fun associate(
        tree: ITree,
        cloudChildren: List<Long>,
        mpsChildren: List<SModule>,
        direction: SyncDirection?,
    ): Map<Long, SModule> {
        val result: Map<Long, SModule> = MapSequence.fromMap(HashMap())
        val availableModules: List<SModule?> = ListSequence.fromListWithValues(ArrayList(), mpsChildren)
        for (cloudModuleId: Long in cloudChildren) {
            val id: SModuleId? = getModuleId(tree, cloudModuleId)
            val name: String? = tree.getProperty(cloudModuleId, PROPS.`name$MnvL`.name)

            // There can be modules with duplicate names. That's why we can't just search in a map.
            val itr: MutableIterator<SModule?> = ListSequence.fromList(availableModules).iterator()
            while (itr.hasNext()) {
                val it: SModule? = itr.next()
                if (id != null && Objects.equals(it!!.moduleId, id) || Objects.equals(
                        it!!.moduleName,
                        name,
                    )
                ) {
                    MapSequence.fromMap(result).put(cloudModuleId, it)
                    itr.remove()
                    break
                }
            }
        }
        return result
    }

    protected fun getModuleId(tree: ITree, cloudModuleId: Long): SModuleId? {
        val serializedId: String? = tree.getProperty(cloudModuleId, PROPS.`id$7MjP`.name)
        if ((serializedId == null || serializedId.length == 0)) {
            return null
        }
        return PersistenceFacade.getInstance().createModuleId(serializedId)
    }

    override fun createCloudChild(t: IWriteTransaction, mpsChild: SModule): Long {
        return createModuleOnCloud(t, mpsChild, cloudParentId, LINKS.`modules$Bi3g`.name)
    }

    private object LINKS {
        /*package*/
        val `modules$Bi3g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            0x37a0917d689de9e2L,
            "modules",
        )
    }

    internal object CONCEPTS {
        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module",
        )

        /*package*/
        val `Solution$q3`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x65e0d25ff052e203L,
            "org.modelix.model.repositoryconcepts.structure.Solution",
        )

        /*package*/
        val `DevKit$r1`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x65e0d25ff052e205L,
            "org.modelix.model.repositoryconcepts.structure.DevKit",
        )

        /*package*/
        val `Language$qy`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x65e0d25ff052e204L,
            "org.modelix.model.repositoryconcepts.structure.Language",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )

        /*package*/
        val `id$7MjP`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x3aa34013f2a802e0L,
            "id",
        )
    }

    companion object {
        fun createModuleOnCloud(
            t: IWriteTransaction,
            mpsModule: SModule?,
            cloudParentId: Long,
            cloudRole: String?,
        ): Long {
            val modelNodeId: Long =
                t.addNewChild(cloudParentId, cloudRole, -1, SConceptAdapter.Companion.wrap(CONCEPTS.`Module$4i`))
            val moduleAsNode: SModuleAsNode = SModuleAsNode((mpsModule)!!)
            for (property: IProperty in moduleAsNode.concept.getAllProperties()) {
                t.setProperty(modelNodeId, property.name, moduleAsNode.getPropertyValue(property.name))
            }
            t.setProperty(modelNodeId, PROPS.`id$7MjP`.name, mpsModule.moduleId.toString())
            t.setProperty(modelNodeId, "\$originalId", moduleAsNode.reference.serialize())
            t.setProperty(modelNodeId, PROPS.`name$MnvL`.name, mpsModule.moduleName)
            return modelNodeId
        }
    }
}
