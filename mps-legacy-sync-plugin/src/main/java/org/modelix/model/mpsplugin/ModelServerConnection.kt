package org.modelix.model.mpsplugin

import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.project.ProjectManager
import com.intellij.openapi.project.ProjectManagerListener
import com.intellij.util.messages.MessageBusConnection
import io.ktor.client.HttpClient
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.ide.project.ProjectHelper
import jetbrains.mps.internal.collections.runtime.IListSequence
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SNode
import org.modelix.common.AuthorOverride
import org.modelix.common.InstanceJwtToken
import org.modelix.model.api.IBranch
import org.modelix.model.api.ITransaction
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.api.addNewChild
import org.modelix.model.area.PArea
import org.modelix.model.client.ActiveBranch
import org.modelix.model.client.ConnectionListener
import org.modelix.model.client.IModelClient
import org.modelix.model.client.ReplicatedRepository
import org.modelix.model.client.RestWebModelClient
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SNodeAPI
import org.modelix.model.mpsplugin.plugin.EModelixExecutionMode
import org.modelix.model.mpsplugin.plugin.ModelixConfigurationSystemProperties
import java.util.Arrays
import java.util.Objects
import java.util.function.Consumer
import javax.swing.SwingUtilities

/*Generated by MPS */
class ModelServerConnection @JvmOverloads constructor(baseUrl: String, providedHttpClient: HttpClient? = null) {
    private val SETTINGS_KEY_PREFIX: String = ModelServerConnection::class.java.getName() + ".token/"
    val baseUrl: String
    private val client: RestWebModelClient
    private var infoTree: MpsReplicatedRepository? = null
    private val activeBranches: Map<RepositoryId?, ActiveBranch> = MapSequence.fromMap(HashMap())
    private var listeners: List<IListener> = ListSequence.fromList(ArrayList())
    var id: String? = null
        private set
    var email: String? = null
        private set
    private val messageBusConnection: MessageBusConnection
    private val bindings: Map<RepositoryId?, RootBinding> = MapSequence.fromMap(HashMap())

    init {
        if (LOG.isDebugEnabled) {
            LOG.debug("ModelServerConnection.init(" + baseUrl + ")")
        }
        messageBusConnection = ApplicationManager.getApplication().messageBus.connectToMessageBus()
        messageBusConnection.subscribe(
            getProjectManagerTopic(),
            object : ProjectManagerListener {
                override fun projectClosing(closingProject: Project) {
                    for (closingProjectBinding: ProjectBinding? in Sequence.fromIterable(MapSequence.fromMap(bindings).values)
                        .translate(object : ITranslator2<RootBinding, Binding?>() {
                            override fun translate(it: RootBinding): Iterable<Binding?> {
                                return it.allBindings
                            }
                        }).ofType(ProjectBinding::class.java).where(object : IWhereFilter<ProjectBinding>() {
                            override fun accept(it: ProjectBinding): Boolean {
                                return Objects.equals(ProjectHelper.toIdeaProject(it.project), closingProject)
                            }
                        }).toListSequence()) {
                        removeBinding(closingProjectBinding)
                    }
                }
            },
        )
        this.baseUrl = baseUrl
        val workspaceTokenProvider: () -> String? = { InstanceJwtToken.token }
        val tokenProvider: (() -> String?)? =
            (if (ModelixConfigurationSystemProperties.executionMode == EModelixExecutionMode.PROJECTOR) workspaceTokenProvider else null)
        client = RestWebModelClient(
            baseUrl,
            tokenProvider,
            Arrays.asList(ConnectionListenerForForbiddenMessage(baseUrl)),
            providedHttpClient,
        )
        val connectedFirstTime: Wrappers._boolean = Wrappers._boolean(true)
        client.addStatusListener({ oldStatus: RestWebModelClient.ConnectionStatus?, newStatus: RestWebModelClient.ConnectionStatus ->
            if (newStatus == RestWebModelClient.ConnectionStatus.CONNECTED && connectedFirstTime.value) {
                connectedFirstTime.value = false
                onConnect()
            }
            for (l: IListener in ListSequence.fromList(listeners)) {
                l.connectionStatusChanged(newStatus == RestWebModelClient.ConnectionStatus.CONNECTED)
            }
        })
    }

    /**
     * It seems that several connections are open at the same time: we do not want to show
     * error messages multiple times, so we use a shared state of the connection
     */
    private class ConnectionListenerForForbiddenMessage(private val baseUrl: String) : ConnectionListener {
        override fun receivedForbiddenResponse() {
            if (!(inForbiddenState())) {
                MapSequence.fromMap(inForbiddenStateByURL).put(baseUrl, true)
                SwingUtilities.invokeLater(object : Runnable {
                    override fun run() {
                        ModelixNotifications.notifyError(
                            "Forbidden Access",
                            "Unauthorized to connect to Model Server " + baseUrl + ". Check you are logged in and have the right to access that Model Server",
                        )
                    }
                })
            }
        }

        override fun receivedSuccessfulResponse() {
            MapSequence.fromMap(inForbiddenStateByURL).put(baseUrl, false)
        }

        private fun inForbiddenState(): Boolean {
            if (MapSequence.fromMap(inForbiddenStateByURL).containsKey(baseUrl)) {
                return (MapSequence.fromMap(inForbiddenStateByURL).get(baseUrl))!!
            } else {
                return false
            }
        }

        companion object {
            private val inForbiddenStateByURL: Map<String, Boolean> = MapSequence.fromMap(HashMap())
        }
    }

    fun getRootBinding(repositoryId: RepositoryId?): RootBinding {
        var rootBinding: RootBinding? = MapSequence.fromMap(bindings).get(repositoryId)
        if (rootBinding == null) {
            rootBinding = RootBinding(this, repositoryId)
            MapSequence.fromMap(bindings).put(repositoryId, rootBinding)
        }
        return rootBinding
    }

    @Deprecated("")
    fun reconnect() {
        client.reconnect()
    }

    private fun onConnect() {
        id = client.get("server-id")
        if ((id == null || id!!.length == 0)) {
            // TODO 'repositoryId' was renamed to 'server-id'. After migrating all servers this request is not required anymore.
            id = client.get("repositoryId")
        }
        if ((id == null || id!!.length == 0)) {
            throw RuntimeException(baseUrl + " doesn't provide an ID")
        }
        if (infoTree == null) {
            infoTree = MpsReplicatedRepository(
                client,
                INFO_REPOSITORY_ID,
                ActiveBranch.DEFAULT_BRANCH_NAME,
                { author },
            )
        }
        try {
            email = client.getEmail()
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Failed to read the users e-mail address", ex)
            }
        }
        if (LOG.isDebugEnabled) {
            LOG.debug("connected to " + baseUrl)
        }
    }

    val author: String?
        get() {
            var email: String? = email
            if (Objects.equals(email, "<no email>")) {
                email = null
            }
            return AuthorOverride.apply(email)
        }
    val isConnected: Boolean
        get() {
            val status: RestWebModelClient.ConnectionStatus? = check_v06aqd_a0a0fb(client)
            return status != RestWebModelClient.ConnectionStatus.NEW && status != RestWebModelClient.ConnectionStatus.WAITING_FOR_TOKEN
        }

    protected fun checkConnected() {
        val connectionStatus: RestWebModelClient.ConnectionStatus? = check_v06aqd_a0a0jb(client)
        if (connectionStatus != RestWebModelClient.ConnectionStatus.CONNECTED) {
            client.reconnect()
        }
        if (!(isConnected)) {
            throw IllegalStateException("Not connected. Client is in status " + connectionStatus)
        }
    }

    val allRepositories: List<SNode>
        get() {
            return PArea((infoBranch)!!).executeWrite({
                SLinkOperations.getChildren(
                    info,
                    LINKS.`repositories$b56J`,
                )
            })
        }
    val allRepositoriesCount: Int
        get() {
            return PArea((infoBranch)!!).executeWrite({
                ListSequence.fromList(
                    SLinkOperations.getChildren(
                        info,
                        LINKS.`repositories$b56J`,
                    ),
                ).count()
            })
        }

    fun getRepositoryInfoById(repositoryId: String): SNode {
        val repositoryInfo: SNode = PArea((infoBranch)!!).executeRead<SNode>({
            val modelServerInfo: SNode? = info
            ListSequence.fromList(SLinkOperations.getChildren(modelServerInfo, LINKS.`repositories$b56J`))
                .findFirst(object : IWhereFilter<SNode?>() {
                    override fun accept(it: SNode?): Boolean {
                        return Objects.equals(
                            SPropertyOperations.getString(it, PROPS.`id$baYB`),
                            repositoryId,
                        )
                    }
                })
        })
        if (repositoryInfo == null) {
            val knownRepositoryIds: List<String> = PArea((infoBranch)!!).executeRead<IListSequence<String>>({
                val modelServerInfo: SNode? = info
                ListSequence.fromList(SLinkOperations.getChildren(modelServerInfo, LINKS.`repositories$b56J`))
                    .select(object : ISelector<SNode?, String>() {
                        override fun select(it: SNode?): String {
                            return SPropertyOperations.getString(it, PROPS.`id$baYB`)
                        }
                    }).toListSequence()
            })
            throw IllegalArgumentException("RepositoryInfo with ID " + repositoryId + " not found. Known repository ids: " + knownRepositoryIds)
        }
        return repositoryInfo
    }

    fun addRepository(id: String?): SNode {
        return PArea((infoBranch)!!).executeWrite({
            val modelServerInfo = info!!
            val repositoryInfo: SNode = SNodeOperations.cast(
                SNodeAPI.addNewChild(modelServerInfo, LINKS.`repositories$b56J`),
                CONCEPTS.`RepositoryInfo$5Y`,
            )
            SPropertyOperations.assign(repositoryInfo, PROPS.`id$baYB`, id)
            val branchInfo: SNode =
                SNodeOperations.cast(SNodeAPI.addNewChild(repositoryInfo, LINKS.`branches$b5_g`), CONCEPTS.`BranchInfo$6t`)
            SPropertyOperations.assign(branchInfo, PROPS.`name$MnvL`, ActiveBranch.DEFAULT_BRANCH_NAME)
            repositoryInfo
        })
    }

    fun removeRepository(id: String?) {
        PArea((infoBranch)!!).executeWrite<SNode>({
            val info: SNode? = info
            SNodeOperations.deleteNode(
                ListSequence.fromList(
                    SLinkOperations.getChildren(
                        info,
                        LINKS.`repositories$b56J`,
                    ),
                ).findFirst(object : IWhereFilter<SNode?>() {
                    override fun accept(it: SNode?): Boolean {
                        return Objects.equals(SPropertyOperations.getString(it, PROPS.`id$baYB`), id)
                    }
                }),
            )
        })
    }

    fun hasProjectBinding(repositoryId: RepositoryId?, projectNodeId: Long): Boolean {
        return Sequence.fromIterable(projectBindings).any(object : IWhereFilter<ProjectBinding>() {
            override fun accept(it: ProjectBinding): Boolean {
                return Objects.equals(
                    it.cloudRepository?.repositoryId,
                    repositoryId,
                ) && Objects.equals(it.projectNodeId, projectNodeId)
            }
        })
    }

    val projectBindings: Iterable<ProjectBinding>
        get() {
            return Sequence.fromIterable(MapSequence.fromMap(bindings).values)
                .translate(object : ITranslator2<RootBinding, Binding?>() {
                    override fun translate(it: RootBinding): Iterable<Binding?> {
                        return it.allBindings
                    }
                }).ofType(ProjectBinding::class.java)
        }

    @JvmOverloads
    fun addBinding(repositoryId: RepositoryId?, binding: Binding, callback: Runnable? = null) {
        binding.setOwner(getRootBinding(repositoryId))
        binding.activate(callback)
    }

    fun removeBinding(binding: Binding?) {
        binding!!.deactivate(null)
        binding.setOwner(null)
    }

    fun hasModuleBinding(repositoryId: RepositoryId?, moduleNodeId: Long): Boolean {
        return Sequence.fromIterable(
            moduleBindings,
        ).any(object : IWhereFilter<ModuleBinding>() {
            override fun accept(it: ModuleBinding): Boolean {
                return Objects.equals(
                    it.cloudRepository?.repositoryId,
                    repositoryId,
                ) && Objects.equals(it.moduleNodeId, moduleNodeId)
            }
        })
    }

    fun getModuleBinding(repositoryId: RepositoryId?, moduleNodeId: Long): List<ModuleBinding> {
        return Sequence.fromIterable(
            moduleBindings,
        ).where(object : IWhereFilter<ModuleBinding>() {
            override fun accept(it: ModuleBinding): Boolean {
                return Objects.equals(
                    it.cloudRepository?.repositoryId,
                    repositoryId,
                ) && Objects.equals(it.moduleNodeId, moduleNodeId)
            }
        }).toListSequence()
    }

    val moduleBindings: Iterable<ModuleBinding>
        get() {
            return Sequence.fromIterable(MapSequence.fromMap(bindings).values)
                .translate(object : ITranslator2<RootBinding, Binding?>() {
                    override fun translate(it: RootBinding): Iterable<Binding?> {
                        return it.allBindings
                    }
                }).ofType(ModuleBinding::class.java)
        }
    val infoBranch: IBranch?
        get() {
            checkConnected()
            return infoTree?.branch
        }

    fun <T> computeRead(repositoryId: RepositoryId?, producer: Function0<T>): T {
        return infoBranch!!.computeRead({
            val activeBranch: ActiveBranch = getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch.branch
            PArea(branch).executeRead({ producer.invoke() })
        })
    }

    val info: SNode?
        get() {
            if (infoTree == null) {
                return null
            }
            checkConnected()
            val result: SNode? = PArea(infoTree!!.branch).executeRead({
                val t: ITransaction = infoTree!!.branch.transaction
                val allChildren_: Iterable<Long> = t.getAllChildren(ITree.ROOT_ID)
                val allChildren: Iterable<SNode> =
                    Sequence.fromIterable<Long>(allChildren_).select<SNode>(object : ISelector<Long?, SNode>() {
                        override fun select(it: Long?): SNode {
                            return NodeToSNodeAdapter.wrap(PNodeAdapter((it)!!, infoTree!!.branch))
                        }
                    })
                Sequence.fromIterable(SNodeOperations.ofConcept(allChildren, CONCEPTS.`ModelServerInfo$5v`)).first()
            })
            if (result == null) {
                SharedExecutors.FIXED.submit(
                    _Adapters._return_P0_E0_to_Runnable_adapter(object : _return_P0_E0<SNode> {
                        override fun invoke(): SNode {
                            return PArea(infoTree!!.branch).executeWrite<SNode>({
                                val t: IWriteTransaction = infoTree!!.branch.writeTransaction
                                val id: Long = t.addNewChild(
                                    ITree.ROOT_ID,
                                    "info",
                                    -1,
                                    SConceptAdapter.Companion.wrap(CONCEPTS.`ModelServerInfo$5v`),
                                )
                                val repoInfo: SNode = SNodeOperations.cast(
                                    NodeToSNodeAdapter.wrap(PNodeAdapter(id, infoTree!!.branch)),
                                    CONCEPTS.`ModelServerInfo$5v`,
                                )
                                addRepository(DEFAULT_REPOSITORY_ID)
                                repoInfo
                            })
                        }
                    }),
                )
            }
            return result
        }

    fun getActiveBranch(repositoryId: RepositoryId?): ActiveBranch {
        checkConnected()
        synchronized(activeBranches, {
            var ab: ActiveBranch? = MapSequence.fromMap(activeBranches).get(repositoryId)
            if (ab == null) {
                ab = object : ActiveBranch(client, (repositoryId)!!, null, { author ?: "<unknown author>" }) {
                    override fun createReplicatedRepository(
                        client: IModelClient,
                        repositoryId: RepositoryId,
                        branchName: String,
                        user: () -> String,
                    ): ReplicatedRepository {
                        return MpsReplicatedRepository(client, repositoryId, branchName, user)
                    }
                }
                MapSequence.fromMap(activeBranches).put(repositoryId, ab)
            }
            return ab
        })
    }

    fun getActiveBranches(): Iterable<ActiveBranch> {
        synchronized(
            activeBranches,
            { return Sequence.fromIterable(MapSequence.fromMap(activeBranches).values).toListSequence() },
        )
    }

    @Synchronized
    fun dispose() {
        try {
            messageBusConnection.disconnect()
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        try {
            check_v06aqd_a0a1a17(client)
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        try {
            check_v06aqd_a0a2a17(infoTree)
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        for (binding: RootBinding in Sequence.fromIterable(MapSequence.fromMap(bindings).values)) {
            binding.deactivate(null)
        }
        synchronized(activeBranches, {
            for (ab: ActiveBranch in Sequence.fromIterable(MapSequence.fromMap(activeBranches).values)) {
                try {
                    ab.dispose()
                } catch (ex: Exception) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("", ex)
                    }
                }
            }
            MapSequence.fromMap(activeBranches).clear()
        })
    }

    fun getClient(): IModelClient {
        checkConnected()
        return client
    }

    override fun toString(): String {
        return baseUrl
    }

    fun addListener(l: IListener) {
        val newListeners: List<IListener> = ListSequence.fromListWithValues(ArrayList(), listeners)
        ListSequence.fromList(newListeners).addElement(l)
        listeners = newListeners
    }

    fun removeListener(l: IListener) {
        val newListeners: List<IListener> = ListSequence.fromListWithValues(ArrayList(), listeners)
        ListSequence.fromList(newListeners).removeElement(l)
        listeners = newListeners
    }

    fun whenConnected(consumer: Consumer<ModelServerConnection>) {
        if (isConnected) {
            consumer.accept(this)
        } else {
            val listener: IListener = object : IListener {
                override fun connectionStatusChanged(connected: Boolean) {
                    if (connected) {
                        consumer.accept(this@ModelServerConnection)
                        removeListener(this)
                    }
                }
            }
            addListener(listener)
        }
    }

    open interface IListener {
        fun connectionStatusChanged(connected: Boolean) {}
        fun bindingAdded(binding: Binding?) {}
        fun bindingRemoved(binding: Binding?) {}
        fun bindingActivated(binding: Binding?) {}
        fun bindingDeactivated(binding: Binding?) {}
    }

    private object LINKS {
        /*package*/
        val `repositories$b56J`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcbfL,
            0x62b7d9b07cecbcc2L,
            "repositories",
        )

        /*package*/
        val `branches$b5_g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc0L,
            0x62b7d9b07cecbcc4L,
            "branches",
        )
    }

    private object PROPS {
        /*package*/
        val `id$baYB`: SProperty = MetaAdapterFactory.getProperty(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc0L,
            0x62b7d9b07cecbcc6L,
            "id",
        )

        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )
    }

    private object CONCEPTS {
        /*package*/
        val `RepositoryInfo$5Y`: SConcept = MetaAdapterFactory.getConcept(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc0L,
            "org.modelix.model.runtimelang.structure.RepositoryInfo",
        )

        /*package*/
        val `BranchInfo$6t`: SConcept = MetaAdapterFactory.getConcept(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc1L,
            "org.modelix.model.runtimelang.structure.BranchInfo",
        )

        /*package*/
        val `ModelServerInfo$5v`: SConcept = MetaAdapterFactory.getConcept(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcbfL,
            "org.modelix.model.runtimelang.structure.ModelServerInfo",
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(ModelServerConnection::class.java)
        private val INFO_REPOSITORY_ID: RepositoryId = RepositoryId("info")
        val UI_STATE_REPOSITORY_ID: RepositoryId = RepositoryId("uistate")
        val DEFAULT_REPOSITORY_ID: String = "default"
        private fun check_v06aqd_a0a0fb(checkedDotOperand: RestWebModelClient?): RestWebModelClient.ConnectionStatus? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.connectionStatus
            }
            return null
        }

        private fun check_v06aqd_a0a0jb(checkedDotOperand: RestWebModelClient?): RestWebModelClient.ConnectionStatus? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.connectionStatus
            }
            return null
        }

        private fun check_v06aqd_a1a26(checkedDotOperand: MpsReplicatedRepository?): IBranch? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.branch
            }
            return null
        }

        private fun check_v06aqd_a0a1a17(checkedDotOperand: RestWebModelClient?) {
            if (null != checkedDotOperand) {
                checkedDotOperand.dispose()
            }
        }

        private fun check_v06aqd_a0a2a17(checkedDotOperand: MpsReplicatedRepository?) {
            if (null != checkedDotOperand) {
                checkedDotOperand.dispose()
            }
        }
    }
}
