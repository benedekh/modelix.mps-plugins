package org.modelix.model.mpsplugin

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._void_P1_E0
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.modelix.model.api.IBranch
import org.modelix.model.api.ITree
import org.modelix.model.api.ITreeChangeVisitor
import org.modelix.model.api.IWriteTransaction

/*Generated by MPS */
abstract class Binding(protected var initialSyncDirection: SyncDirection?) {
    private var owner: Binding? = null
    private val ownedBindings: Set<Binding> = SetSequence.fromSet(LinkedHashSet())
    var isActive: Boolean = false
        private set
    private val listeners: List<IListener> = ListSequence.fromList(ArrayList())
    var pendingTask: SyncTask? = null
        protected set
    var runningTask: SyncTask? = null
    protected fun assertSyncThread() {
        rootBinding.syncQueue.assertSyncThread()
    }

    val depth: Int
        get() {
            return (if (owner == null) 0 else owner!!.depth + 1)
        }

    fun createTask(direction: SyncDirection, initial: Boolean): SyncTask {
        when (direction) {
            SyncDirection.TO_CLOUD -> return SyncTask(
                this,
                direction,
                initial,
                SetSequence.fromSetAndArray(
                    HashSet(),
                    ELockType.MPS_READ,
                    ELockType.CLOUD_WRITE,
                ),
                object : Runnable {
                    public override fun run() {
                        syncToCloud()
                    }
                },
            )

            SyncDirection.TO_MPS -> // Even if the ITree is passed to the sync method we still need a read transaction on the cloud model
                // ITree.getReferenceTarget(...).resolveNode(...) requires a read transaction
                return SyncTask(
                    this,
                    direction,
                    initial,
                    SetSequence.fromSetAndArray<ELockType>(
                        HashSet<ELockType>(),
                        ELockType.MPS_COMMAND,
                        ELockType.CLOUD_READ,
                    ),
                    object : Runnable {
                        public override fun run() {
                            branch?.transaction?.tree?.let { syncToMPS(it) }
                        }
                    },
                )

            else -> throw RuntimeException("Unknown direction: " + direction)
        }
    }

    fun createTask(direction: SyncDirection, initial: Boolean, callback: Runnable?): SyncTask {
        val task: SyncTask = createTask(direction, initial)
        task.whenDone(callback)
        return task
    }

    @Synchronized
    fun getRequiredSyncLocks(direction: SyncDirection?): Set<ELockType> {
        if (direction == null) {
            return emptySet()
        } else {
            when (direction) {
                SyncDirection.TO_CLOUD -> return SetSequence.fromSetAndArray(
                    HashSet(),
                    ELockType.MPS_READ,
                    ELockType.CLOUD_WRITE,
                )

                SyncDirection.TO_MPS -> // Even if the ITree is passed to the sync method we still need a read transaction on the cloud model
                    // ITree.getReferenceTarget(...).resolveNode(...) requires a read transaction
                    return SetSequence.fromSetAndArray(HashSet(), ELockType.MPS_COMMAND, ELockType.CLOUD_READ)

                else -> throw RuntimeException("Unknown direction: " + direction)
            }
        }
    }

    fun enqueueSync(direction: SyncDirection, initial: Boolean, callback: Runnable?) {
        if (isSynchronizing) {
            return
        }
        forceEnqueueSyncTo(direction, initial, callback)
    }

    fun forceEnqueueSyncTo(direction: SyncDirection, initial: Boolean, callback: Runnable?) {
        val task: SyncTask = createTask(direction, initial, callback)
        val isEnqueued: Boolean = rootBinding.syncQueue.enqueue(task)
        if (isEnqueued) {
            pendingTask = task
        }
    }

    val isDone: Boolean
        get() {
            return (pendingTask == null || pendingTask!!.isDone) && Sequence.fromIterable(getOwnedBindings())
                .all(object : IWhereFilter<Binding>() {
                    public override fun accept(it: Binding): Boolean {
                        return it.isDone
                    }
                })
        }
    open val branch: IBranch?
        get() {
            if (owner != null) {
                return owner!!.branch
            }
            return null
        }

    /**
     * It's more efficient to diff the tree only once and notify all bindings together about changes instead of calling
     * ITree.visitChanges in each binding.
     * First the visitor is notified about changes and then syncToMPS is called. The binding has to remember which model
     * elements are dirty.
     */
    abstract fun getTreeChangeVisitor(oldTree: ITree?, newTree: ITree): ITreeChangeVisitor?

    @Throws(IllegalStateException::class)
    protected fun checkActive() {
        if (!(isActive)) {
            throw IllegalStateException("Activate the binding first: " + this)
        }
    }

    val isSynchronizing: Boolean
        get() {
            return check_cvbvhu_a0a63(runningTask)
        }

    fun syncToMPS(tree: ITree) {
        assertSyncThread()
        checkActive()
        doSyncToMPS(tree)
    }

    protected abstract fun doSyncToMPS(tree: ITree)
    fun syncToCloud() {
        assertSyncThread()
        checkActive()
        syncToCloud(branch!!.writeTransaction)
    }

    fun syncToCloud(t: IWriteTransaction) {
        assertSyncThread()
        checkActive()
        doSyncToCloud(t)
    }

    abstract fun doSyncToCloud(t: IWriteTransaction)
    open val cloudRepository: ICloudRepository?
        get() {
            return owner?.cloudRepository
        }

    fun setOwner(newOwner: Binding?) {
        if (owner === newOwner) {
            return
        }
        if (isActive) {
            deactivate(null)
        }
        if (newOwner === this) {
            throw IllegalArgumentException("Binding can't own itself")
        }
        if (newOwner != null && Sequence.fromIterable(
                newOwner.owners,
            ).contains(this)
        ) {
            throw IllegalArgumentException("Binding would be an indirect owner of itself")
        }
        if (owner != null) {
            SetSequence.fromSet(owner!!.ownedBindings).removeElement(this)
            owner!!.notifyListeners(object : _void_P1_E0<IListener> {
                public override fun invoke(l: IListener) {
                    l.bindingRemoved(this@Binding)
                }
            })
        }
        owner = newOwner
        if (newOwner != null) {
            SetSequence.fromSet(newOwner.ownedBindings).addElement(this)
            if (newOwner.isActive) {
                activate(null)
            }
            newOwner.notifyListeners(object : _void_P1_E0<IListener> {
                public override fun invoke(l: IListener) {
                    l.bindingAdded(this@Binding)
                }
            })
        }
        notifyListeners(object : _void_P1_E0<IListener> {
            public override fun invoke(l: IListener) {
                l.ownerChanged(newOwner)
            }
        })
    }

    fun getOwner(): Binding? {
        return owner
    }

    fun getOwnedBindings(): Iterable<Binding> {
        return ownedBindings
    }

    val owners: Iterable<Binding>
        get() {
            return owner?.let { listOf(it) + it.owners } ?: emptyList()
        }
    val rootOwnerOrSelf: Binding
        get() {
            return (if (owner == null) this else owner!!.rootOwnerOrSelf)
        }
    val rootBinding: RootBinding
        get() {
            val root: RootBinding? = as_cvbvhu_a0a0a16(rootOwnerOrSelf, RootBinding::class.java)
            if (root == null) {
                throw IllegalStateException("Not attached: " + this)
            }
            return root
        }
    val allBindings: Iterable<Binding>
        get() {
            return Sequence.fromIterable(Sequence.singleton(this))
                .concat(
                    SetSequence.fromSet(ownedBindings).translate(object : ITranslator2<Binding, Binding>() {
                        public override fun translate(it: Binding): Iterable<Binding> {
                            return it.allBindings
                        }
                    }),
                )
        }

    @Synchronized
    fun activate(callback: Runnable?) {
        if (!(rootOwnerOrSelf is RootBinding)) {
            throw IllegalStateException("Set an owner first: " + this)
        }
        if (isActive) {
            return
        }
        if (!(this is RootBinding) && !(owner!!.isActive)) {
            throw IllegalStateException("Activate " + owner + " first, before activating " + this)
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug("Activate: " + this)
        }
        isActive = true
        doActivate()
        if (rootBinding.syncQueue.getTask(this) == null) {
            enqueueSync(
                ((if (initialSyncDirection != null) initialSyncDirection else SyncDirection.TO_MPS)!!),
                true,
                callback,
            )
        }
        notifyListeners(object : _void_P1_E0<IListener> {
            public override fun invoke(l: IListener) {
                l.bindingActivated()
            }
        })
    }

    @Synchronized
    fun deactivate(callback: Runnable?) {
        if (!(isActive)) {
            return
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug("Deactivate: " + this)
        }
        isActive = false
        for (child: Binding in SetSequence.fromSet(ownedBindings)) {
            child.deactivate(null)
        }
        doDeactivate()
        notifyListeners(object : _void_P1_E0<IListener> {
            public override fun invoke(l: IListener) {
                l.bindingDeactivated()
            }
        })
        check_cvbvhu_a6a66(callback)
    }

    protected abstract fun doActivate()
    protected abstract fun doDeactivate()
    fun addListener(l: IListener) {
        ListSequence.fromList(listeners).addElement(l)
    }

    fun removeListener(l: IListener) {
        ListSequence.fromList(listeners).removeElement(l)
    }

    protected fun notifyListeners(notifier: _void_P1_E0<in IListener>) {
        ListSequence.fromList(listeners).visitAll(object : IVisitor<IListener>() {
            public override fun visit(it: IListener) {
                try {
                    notifier.invoke(it)
                } catch (ex: Exception) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("", ex)
                    }
                }
            }
        })
    }

    open interface IListener {
        fun bindingAdded(binding: Binding?)
        fun bindingRemoved(binding: Binding?)
        fun ownerChanged(newOwner: Binding?)
        fun bindingActivated()
        fun bindingDeactivated()
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(Binding::class.java)
        private fun check_cvbvhu_a0a63(checkedDotOperand: SyncTask?): Boolean {
            if (null != checkedDotOperand) {
                return checkedDotOperand.isRunning
            }
            return false
        }

        private fun check_cvbvhu_a6a66(checkedDotOperand: Runnable?) {
            if (null != checkedDotOperand) {
                checkedDotOperand.run()
            }
        }

        private fun <T> as_cvbvhu_a0a0a16(o: Any, type: Class<T>): T? {
            return (if (type.isInstance(o)) o as T else null)
        }
    }
}
