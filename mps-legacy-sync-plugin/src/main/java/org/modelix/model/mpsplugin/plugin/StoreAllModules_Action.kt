package org.modelix.model.mpsplugin.plugin

import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.progress.ProgressIndicator
import com.intellij.openapi.progress.ProgressManager
import com.intellij.openapi.progress.Task
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.ide.actions.MPSCommonDataKeys
import jetbrains.mps.ide.project.ProjectHelper
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ISetSequence
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.progress.ProgressMonitorAdapter
import jetbrains.mps.project.MPSProject
import jetbrains.mps.smodel.MPSModuleRepository
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.workbench.action.BaseAction
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.module.SModule
import org.modelix.model.api.IBranch
import org.modelix.model.api.ITransaction
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsplugin.CloudRepository
import org.modelix.model.mpsplugin.ModelCloudImportUtils
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.mpsplugin.history.CloudNodeTreeNode
import org.modelix.model.mpsplugin.history.ModelServerTreeNode
import org.modelix.model.mpsplugin.history.RepositoryTreeNode
import org.modelix.model.mpsplugin.history.TreeNodeClassification
import java.util.Collections
import javax.swing.Icon
import javax.swing.tree.TreeNode

/*Generated by MPS */
class StoreAllModules_Action : BaseAction("Store Entire MPS Module Repository", "", ICON) {
    init {
        setIsAlwaysVisible(false)
        setExecuteOutsideCommand(true)
    }

    override fun isDumbAware(): Boolean {
        return true
    }

    override fun isApplicable(event: AnActionEvent, _params: Map<String, Any>): Boolean {
        return TreeNodeClassification.isProjectNode(event.getData(MPSCommonDataKeys.TREE_NODE))
    }

    public override fun doUpdate(event: AnActionEvent, _params: Map<String, Any>) {
        setEnabledState(event.presentation, isApplicable(event, _params))
    }

    override fun collectActionData(event: AnActionEvent, _params: Map<String, Any>): Boolean {
        if (!(super.collectActionData(event, _params))) {
            return false
        }
        run({
            val p: MPSProject? = event.getData(MPSCommonDataKeys.MPS_PROJECT)
            if (p == null) {
                return false
            }
        })
        run({
            val p: TreeNode? = event.getData(MPSCommonDataKeys.TREE_NODE)
            if (p == null) {
                return false
            }
        })
        return true
    }

    public override fun doExecute(event: AnActionEvent, _params: Map<String, Any>) {
        val nodeTreeNode: CloudNodeTreeNode = (event.getData(MPSCommonDataKeys.TREE_NODE) as CloudNodeTreeNode?)!!
        val modelServer: ModelServerConnection =
            nodeTreeNode.getAncestor(ModelServerTreeNode::class.java).modelServer
        val repositoryId: RepositoryId = nodeTreeNode.getAncestor(RepositoryTreeNode::class.java).repositoryId
        val treeInRepository: CloudRepository = CloudRepository(modelServer, repositoryId)
        val cloudProjectId: Long = (nodeTreeNode.node as PNodeAdapter?)!!.nodeId
        val branch: IBranch = treeInRepository.activeBranch.branch
        val task: Task.Backgroundable = object : Task.Backgroundable(
            ProjectHelper.toIdeaProject(event.getData<MPSProject>(MPSCommonDataKeys.MPS_PROJECT)),
            "Import MPS Repository",
            true,
        ) {
            override fun run(indicator: ProgressIndicator) {
                val progress: ProgressMonitorAdapter = ProgressMonitorAdapter(indicator)
                val mpsRepo: MPSModuleRepository = MPSModuleRepository.getInstance()
                val mpsModules: _T<List<SModule?>?> = _T(null)
                mpsRepo.modelAccess.runReadAction(object : Runnable {
                    override fun run() {
                        mpsModules.value = ListSequence.fromListWithValues(ArrayList(), mpsRepo.modules)
                    }
                })
                val existingModules: Set<String?>? = branch.computeRead<ISetSequence<String?>?>({
                    val t: ITransaction = branch.transaction
                    val existingModules: Iterable<Long> = t.getChildren(cloudProjectId, LINKS.`modules$Bi3g`.name)
                    SetSequence.fromSetWithValues(
                        HashSet(),
                        Sequence.fromIterable(existingModules).select(object : ISelector<Long?, String>() {
                            override fun select(it: Long?): String? {
                                return t.getProperty((it)!!, PROPS.`name$MnvL`.name)
                            }
                        }),
                    )
                })
                mpsModules.value =
                    ListSequence.fromList<SModule?>(mpsModules.value).where(object : IWhereFilter<SModule>() {
                        override fun accept(it: SModule): Boolean {
                            return !(SetSequence.fromSet(existingModules).contains(it.moduleName))
                        }
                    }).toListSequence()
                Collections.shuffle(mpsModules.value)
                progress.start(
                    "Importing " + ListSequence.fromList(mpsModules.value).count() + " Modules",
                    ListSequence.fromList(mpsModules.value).count(),
                )
                for (mpsModule: SModule? in ListSequence.fromList<SModule?>(mpsModules.value)) {
                    if (progress.isCanceled) {
                        break
                    }
                    while (modelServer.getClient().storeCache.keyValueStore.getPendingSize() > 10000) {
                        if (progress.isCanceled) {
                            break
                        }
                        try {
                            Thread.sleep(1000)
                        } catch (e: InterruptedException) {
                            break
                        }
                    }
                    progress.step("Importing Module " + mpsModule!!.moduleName)
                    branch.runWrite({
                        val t: IWriteTransaction = branch.writeTransaction
                        val cloudModuleId: Long = t.addNewChild(
                            cloudProjectId,
                            LINKS.`modules$Bi3g`.name,
                            -1,
                            SConceptAdapter.Companion.wrap(
                                CONCEPTS.`Module$4i`,
                            ),
                        )
                        t.setProperty(cloudModuleId, PROPS.`name$MnvL`.name, mpsModule.moduleName)
                        ModelCloudImportUtils.replicatePhysicalModule(
                            treeInRepository,
                            PNodeAdapter(cloudModuleId, branch),
                            mpsModule,
                            null,
                            progress.subTask(1),
                        )
                    })
                }
            }
        }
        ProgressManager.getInstance().run(task)
    }

    private object LINKS {
        /*package*/
        val `modules$Bi3g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            0x37a0917d689de9e2L,
            "modules",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )
    }

    private object CONCEPTS {
        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module",
        )
    }

    companion object {
        private val ICON: Icon? = null
    }
}
