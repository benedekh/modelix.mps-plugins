package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter
import jetbrains.mps.internal.collections.runtime.Sequence
import org.modelix.model.api.IBranch
import org.modelix.model.api.IBranchListener
import org.modelix.model.api.ITree
import org.modelix.model.api.ITreeChangeVisitor
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.lazy.RepositoryId
import java.util.Objects

/*Generated by MPS */ /**
 * Just a parent for all actual bindings
 */
class RootBinding(override val cloudRepository: ICloudRepository) : Binding(null), IBranchListener {
    val syncQueue: SyncQueue = SyncQueue(this)
    private var disposed: Boolean = false

    init {
        activate(null)
    }

    constructor(connection: ModelServerConnection?, cloudRepositoryId: RepositoryId?) : this(
        CloudRepository(
            connection,
            cloudRepositoryId
        )
    )

    public override fun toString(): String {
        return "bindings"
    }

    override val branch: IBranch?
        get() {
            val branch: IBranch? = super.getBranch()
            return (if (branch != null) branch else cloudRepository.getBranch())
        }

    public override fun treeChanged(oldTree: ITree, newTree: ITree) {
        if (syncQueue.isSynchronizing()) {
            return
        }
        enqueueSync(SyncDirection.TO_MPS, false, null)
    }

    override fun doSyncToMPS(newTree: ITree) {
        assertSyncThread()
        val oldTree: ITree? = syncQueue.getLastTreeAfterSync()
        if (oldTree != null && !(Objects.equals(newTree, oldTree))) {
            val visitors: List<ITreeChangeVisitor> =
                Sequence.fromIterable(getAllBindings()).select(object : ISelector<Binding, ITreeChangeVisitor?>() {
                    public override fun select(it: Binding): ITreeChangeVisitor? {
                        return it.getTreeChangeVisitor(oldTree, newTree)
                    }
                }).where(NotNullWhereFilter<Any?>()).toListSequence()
            if (ListSequence.fromList(visitors).isNotEmpty()) {
                newTree.visitChanges(oldTree, TreeChangeMulticaster(visitors))
            }
        }
    }

    public override fun doSyncToCloud(t: IWriteTransaction) {}
    override fun getTreeChangeVisitor(oldTree: ITree?, newTree: ITree): ITreeChangeVisitor? {
        return null
    }

    override fun doActivate() {
        if (disposed) {
            throw IllegalStateException("Reactivation not supported")
        }
        cloudRepository.getActiveBranch().addListener(this)
    }

    override fun doDeactivate() {
        disposed = true
        cloudRepository.getActiveBranch().removeListener(this)
        syncQueue.dispose()
    }
}
