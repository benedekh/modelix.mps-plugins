package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.project.MPSProject
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SNode
import org.modelix.model.api.IBranch
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.IReadTransaction
import org.modelix.model.api.ITree
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.PArea
import org.modelix.model.client.ActiveBranch
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import java.util.Objects
import java.util.function.Consumer

/*Generated by MPS */
/**
 * This pair (a ModelServer and a Repository) is equivalent to the coordinates of a git repository.
 * The ModelServer is more like a collection of several git repositories.
 */
class CloudRepository(modelServer: ModelServerConnection?, repositoryId: RepositoryId?) : ICloudRepository {
    val modelServer: ModelServerConnection
    override val repositoryId: RepositoryId

    init {
        if (modelServer == null) {
            throw IllegalArgumentException("modelServer should not be null")
        }
        if (repositoryId == null) {
            throw IllegalArgumentException("repositoryId should not be null")
        }
        this.modelServer = modelServer
        this.repositoryId = repositoryId
    }

    override val branch: IBranch
        get() {
            return activeBranch.branch
        }
    override val activeBranch: ActiveBranch
        get() {
            return modelServer.getActiveBranch(repositoryId)
        }
    val isConnected: Boolean
        get() {
            return modelServer.isConnected
        }

    fun presentation(): String {
        if (modelServer.baseUrl.endsWith("/")) {
            return modelServer.baseUrl + repositoryId
        }
        return modelServer.baseUrl + "/" + repositoryId
    }

    public override fun completeId(): String {
        if (modelServer.baseUrl.endsWith("/")) {
            return modelServer.baseUrl + repositoryId
        }
        return modelServer.baseUrl + "/" + repositoryId
    }

    fun <T> computeRead(producer: Function0<T>): T {
        return modelServer.infoBranch!!.computeRead({
            val activeBranch = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch.branch
            PArea(branch).executeRead({ producer.invoke() })
        })
    }

    fun runRead(r: Runnable) {
        PArea(modelServer.infoBranch!!).executeRead({
            val activeBranch = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch!!.branch
            PArea(branch).executeRead({
                r.run()
                Unit
            })
            Unit
        })
    }

    /**
     * Consumer receives the root node
     */
    fun runRead(consumer: Consumer<PNodeAdapter>) {
        val activeBranch = modelServer.getActiveBranch(repositoryId)
        val branch = activeBranch.branch
        val rootNode = PNodeAdapter(ITree.ROOT_ID, branch)
        PArea(branch).executeRead<Unit>({
            consumer.accept(rootNode)
            Unit
        })
    }

    /**
     * Computer receives the root node
     *
     * @param computer
     * @param <T>
     * @return
     </T> */
    fun <T> computeWrite(computer: Function1<PNodeAdapter, T>): T {
        val activeBranch: ActiveBranch? = modelServer.getActiveBranch(repositoryId)
        val branch: IBranch = activeBranch!!.branch
        val rootNode: PNodeAdapter = PNodeAdapter(ITree.ROOT_ID, branch)
        return PArea(branch).executeWrite({ computer.invoke(rootNode) })
    }

    /**
     * Consuter receives the root node
     */
    fun runWrite(consumer: Consumer<PNodeAdapter?>) {
        val activeBranch: ActiveBranch? = modelServer.getActiveBranch(repositoryId)
        val branch: IBranch = activeBranch!!.branch
        val rootNode: PNodeAdapter = PNodeAdapter(ITree.ROOT_ID, branch)
        PArea(branch).executeWrite<Unit>({
            consumer.accept(rootNode)
            Unit
        })
    }

    fun processProjects(consumer: Consumer<SNode>) {
        processRepoRoots(object : Consumer<INode> {
            public override fun accept(iNode: INode) {
                val sNode = NodeToSNodeAdapter.wrap(iNode)
                if (SNodeOperations.isInstanceOf(sNode, CONCEPTS.`Project$An`)) {
                    consumer.accept(SNodeOperations.cast(sNode, CONCEPTS.`Project$An`))
                }
            }
        })
    }

    fun repoRoots(): List<INode> {
        val roots: List<INode> = ListSequence.fromList(ArrayList())
        processRepoRoots(object : Consumer<INode> {
            public override fun accept(it: INode) {
                ListSequence.fromList(roots).addElement(it)
            }
        })
        return roots
    }

    fun processRepoRoots(consumer: Consumer<INode>) {
        PArea(modelServer.infoBranch!!).executeRead({
            val activeBranch = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch.branch
            val rootNode = PNodeAdapter(ITree.ROOT_ID, branch)
            PArea(branch).executeRead<Unit>({
                for (child in rootNode.allChildren) {
                    consumer.accept(child)
                }
                Unit
            })
            Unit
        })
    }

    val readTransaction: IReadTransaction
        get() {
            return activeBranch!!.branch.readTransaction
        }
    val rootBinding: RootBinding?
        get() {
            return modelServer.getRootBinding(repositoryId)
        }

    fun addProjectBinding(nodeId: Long, project: MPSProject, initialSyncDirection: SyncDirection?): ProjectBinding {
        val binding: ProjectBinding = ProjectBinding(project, nodeId, initialSyncDirection)
        addBinding(binding)
        return binding
    }

    fun addTransientModuleBinding(node: INode) {
        addBinding(TransientModuleBinding((node as PNodeAdapter).nodeId))
    }

    fun addBinding(binding: Binding) {
        modelServer.addBinding(repositoryId, binding)
    }

    fun deleteRoot(root: INode?) {
        PArea(modelServer.infoBranch!!).executeWrite({
            val activeBranch = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch.branch
            val rootNode = PNodeAdapter(ITree.ROOT_ID, branch)
            PArea(branch).executeWrite<Unit>({
                rootNode.removeChild((root)!!)
                Unit
            })
            Unit
        })
    }

    fun createProject(name: String?): INode {
        return computeWrite<INode>({ rootNode: PNodeAdapter ->
            val newProject: INode = rootNode.addNewChild(
                LINKS.`projects$NW07`.getName(),
                -1,
                SConceptAdapter.Companion.wrap(
                    CONCEPTS.`Project$An`,
                ),
            )
            newProject.setPropertyValue(PROPS.`name$MnvL`.getName(), name)
            newProject
        })
    }

    fun getProject(name: String?): INode? {
        return computeRead({
            var project: INode? = null
            val activeBranch: ActiveBranch? = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch!!.branch
            val rootNode: PNodeAdapter = PNodeAdapter(ITree.ROOT_ID, branch)
            for (child: INode in Sequence.fromIterable(rootNode.getChildren(LINKS.`projects$NW07`.getName()))) {
                val projectName: String? = child.getPropertyValue(PROPS.`name$MnvL`.getName())
                if (Objects.equals(projectName, name)) {
                    project = child
                }
            }
            project
        })
    }

    fun hasModuleUnderProject(projectNodeId: Long, moduleId: String?): Boolean {
        return computeRead({
            val activeBranch: ActiveBranch? = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch!!.branch
            val rootNode: PNodeAdapter = PNodeAdapter(ITree.ROOT_ID, branch)
            val projectNode: PNodeAdapter = PNodeAdapter(projectNodeId, rootNode.branch)
            ListSequence.fromList(INodeUtils.getChidlrenAsList(projectNode, LINKS.`modules$Bi3g`.getName()))
                .any(object : IWhereFilter<INode>() {
                    public override fun accept(it: INode): Boolean {
                        return Objects.equals(it.getPropertyValue(PROPS.`id$7MjP`.getName()), moduleId)
                    }
                })
        })
    }

    fun hasModuleInRepository(moduleId: String?): Boolean {
        return computeRead({
            val activeBranch: ActiveBranch? = modelServer.getActiveBranch(repositoryId)
            val branch: IBranch = activeBranch!!.branch
            val rootNode: PNodeAdapter = PNodeAdapter(ITree.ROOT_ID, branch)
            ListSequence.fromList(INodeUtils.getChidlrenAsList(rootNode, LINKS.`modules$jBPn`.getName()))
                .any(object : IWhereFilter<INode>() {
                    public override fun accept(it: INode): Boolean {
                        return Objects.equals(it.getPropertyValue(PROPS.`id$7MjP`.getName()), moduleId)
                    }
                })
        })
    }

    fun createModuleUnderProject(projectNodeId: Long, moduleId: String?, moduleName: String?): INode {
        return computeWrite<INode>({ rootNode: PNodeAdapter ->
            val projectNode: PNodeAdapter = PNodeAdapter(projectNodeId, rootNode.branch)
            val newModule: INode = projectNode.addNewChild(
                LINKS.`modules$Bi3g`.getName(),
                -1,
                SConceptAdapter.Companion.wrap(
                    CONCEPTS.`Module$4i`,
                ),
            )
            newModule.setPropertyValue(PROPS.`id$7MjP`.getName(), moduleId)
            newModule.setPropertyValue(PROPS.`name$MnvL`.getName(), moduleName)
            newModule
        })
    }

    fun createModuleUnderProject(cloudModule: INode?, moduleId: String?, moduleName: String?): INode {
        return createModuleUnderProject(INodeUtils.nodeIdAsLong(cloudModule), moduleId, moduleName)
    }

    fun createNode(
        parent: INode?,
        containmentLink: SContainmentLink,
        concept: IConcept?,
        initializer: Consumer<INode>,
    ): INode {
        return computeWrite({ rootNode: PNodeAdapter? ->
            val newNode: INode = parent!!.addNewChild(containmentLink.getName(), -1, concept)
            initializer.accept(newNode)
            newNode
        })
    }

    fun createNode(
        parent: INode?,
        containmentLink: SContainmentLink,
        concept: SConcept?,
        initializer: Consumer<INode>,
    ): INode {
        return createNode(parent, containmentLink, SConceptAdapter.Companion.wrap(concept), initializer)
    }

    fun createModule(moduleName: String?): INode? {
        return computeWrite({ rootNode: PNodeAdapter? ->
            PNodeAdapterCreationMethods.createModuleInRepository(
                rootNode,
                moduleName,
            )
        })
    }

    public override fun hashCode(): Int {
        return modelServer.hashCode() + 7 * repositoryId.hashCode()
    }

    public override fun equals(obj: Any?): Boolean {
        if (obj is CloudRepository) {
            val other: CloudRepository = obj
            return Objects.equals(modelServer, other.modelServer) && Objects.equals(repositoryId, other.repositoryId)
        } else {
            return false
        }
    }

    private object CONCEPTS {
        /*package*/
        val `Project$An`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            "org.modelix.model.repositoryconcepts.structure.Project",
        )

        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module",
        )
    }

    private object LINKS {
        /*package*/
        val `projects$NW07`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x620a8558361d3e0cL,
            "projects",
        )

        /*package*/
        val `modules$Bi3g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            0x37a0917d689de9e2L,
            "modules",
        )

        /*package*/
        val `modules$jBPn`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c516L,
            0x69652614fd1c517L,
            "modules",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )

        /*package*/
        val `id$7MjP`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x3aa34013f2a802e0L,
            "id",
        )
    }

    companion object {
        fun fromPresentationString(presentation: String): CloudRepository {
            val lastSlash: Int = presentation.lastIndexOf("/")
            val url: String = presentation.substring(0, lastSlash)
            val repositoryId: RepositoryId = RepositoryId(presentation.substring(lastSlash + 1))
            val modelServer: ModelServerConnection? =
                ModelServerConnections.instance.ensureModelServerIsPresent(url)
            return CloudRepository(modelServer, repositoryId)
        }
    }
}
