package org.modelix.model.mpsplugin.plugin

import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.Messages
import com.intellij.serviceContainer.ComponentManagerImpl
import de.slisson.mps.reflection.runtime.ReflectionUtil
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P1_E0
import jetbrains.mps.ide.project.ProjectHelper
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.module.SModule
import org.modelix.model.api.IBranch
import org.modelix.model.api.INode
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.area.PArea
import org.modelix.model.mpsplugin.CloudRepository
import org.modelix.model.mpsplugin.INodeUtils
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.mpsplugin.ModelServerConnections
import org.modelix.model.mpsplugin.ModuleBinding
import org.modelix.model.mpsplugin.ProjectModuleBinding
import org.modelix.model.mpsplugin.SharedExecutors
import org.modelix.model.mpsplugin.SyncDirection
import org.modelix.model.mpsplugin.TransientModuleBinding
import org.modelix.model.mpsplugin.history.CloudNodeTreeNode
import org.modelix.model.mpsplugin.plugin._Adapters._return_P1_E0_to_Consumer_adapter
import java.util.Objects
import java.util.concurrent.ConcurrentMap
import java.util.function.Consumer
import java.util.function.Predicate

/*Generated by MPS */
class PersistedBindingConfiguration private constructor(private val project: Project?) {
    fun dispose() {
        val lightServices: ConcurrentMap<Class<*>, Any>? = (
            ReflectionUtil.readField(
                ComponentManagerImpl::class.java,
                (project as ComponentManagerImpl?),
                "lightServices",
            ) as ConcurrentMap<Class<*>, Any>?
            )
        lightServices!!.remove(CloudResourcesConfigurationComponent::class.java)
    }

    fun describeState(): String {
        return readState().toString()
    }

    fun applyToProject() {
        addModelServersAsSpecifiedInPersistedBindingConfiguration()
        bindTransientModulesAsSpecifiedInPersistedConfiguration()
        bindMappedModulesAsSpecifiedInPersistedConfiguration()
    }

    val isEmpty: Boolean
        get() {
            val state: CloudResourcesConfigurationComponent.State = readState()
            if (!(state.modelServers.isEmpty())) {
                return false
            }
            if (!(state.mappedModules.isEmpty())) {
                return false
            }
            if (!(state.transientModules.isEmpty())) {
                return false
            }
            if (!(state.transientProjects.isEmpty())) {
                return false
            }
            return true
        }

    fun hasMappedModule(moduleName: String): Boolean {
        val state: CloudResourcesConfigurationComponent.State = readState()
        for (mm: String? in state.mappedModules) {
            if (mm!!.endsWith("#" + moduleName)) {
                return true
            }
        }
        return false
    }

    fun clear() {
        modifyState(object : Consumer<CloudResourcesConfigurationComponent.State> {
            public override fun accept(state: CloudResourcesConfigurationComponent.State) {
                state.modelServers.clear()
                state.mappedModules.clear()
                state.transientModules.clear()
                state.transientProjects.clear()
            }
        })
        assert(isEmpty)
    }

    private fun readState(): CloudResourcesConfigurationComponent.State {
        val cloudResourcesConfigurationComponent: CloudResourcesConfigurationComponent = project!!.getService(
            CloudResourcesConfigurationComponent::class.java,
        )
        val state: CloudResourcesConfigurationComponent.State = cloudResourcesConfigurationComponent.getState()
        return state
    }

    private fun modifyState(modifier: Consumer<CloudResourcesConfigurationComponent.State>) {
        val cloudResourcesConfigurationComponent: CloudResourcesConfigurationComponent = project!!.getService(
            CloudResourcesConfigurationComponent::class.java,
        )
        val state: CloudResourcesConfigurationComponent.State = readState()
        modifier.accept(state)
        cloudResourcesConfigurationComponent.loadState(state)
    }

    fun addModelServer(modelServer: ModelServerConnection) {
        modifyState(object : Consumer<CloudResourcesConfigurationComponent.State> {
            public override fun accept(state: CloudResourcesConfigurationComponent.State) {
                state.modelServers.add(modelServer.baseUrl)
            }
        })
    }

    fun isModelServerPresent(url: String?): Boolean {
        return readState().modelServers.contains(url)
    }

    fun ensureModelServerIsPresent(modelServer: ModelServerConnection) {
        if (!(isModelServerPresent(modelServer.baseUrl))) {
            modifyState(object : Consumer<CloudResourcesConfigurationComponent.State> {
                public override fun accept(state: CloudResourcesConfigurationComponent.State) {
                    state.modelServers.add(modelServer.baseUrl)
                }
            })
        }
    }

    fun removeModelServer(modelServer: ModelServerConnection) {
        modifyState(object : Consumer<CloudResourcesConfigurationComponent.State> {
            public override fun accept(state: CloudResourcesConfigurationComponent.State) {
                state.modelServers.removeIf(object : Predicate<String?> {
                    public override fun test(url: String?): Boolean {
                        return Objects.equals(url, modelServer.baseUrl)
                    }
                })
                state.transientModules.removeIf(object : Predicate<String?> {
                    public override fun test(moduleStr: String?): Boolean {
                        return moduleStr?.startsWith(modelServer.baseUrl + "#") == true
                    }
                })
            }
        })
    }

    fun addTransientBoundModule(repositoryInModelServer: CloudRepository, nodeTreeNode: CloudNodeTreeNode) {
        addTransientBoundModule(repositoryInModelServer, nodeTreeNode.branch, nodeTreeNode.node)
    }

    fun removeTransientBoundModule(repositoryInModelServer: CloudRepository, nodeTreeNode: CloudNodeTreeNode) {
        removeTransientBoundModule(repositoryInModelServer, nodeTreeNode.branch, nodeTreeNode.node)
    }

    fun removeBoundModule(repositoryInModelServer: CloudRepository, moduleBinding: ModuleBinding) {
        if (moduleBinding is TransientModuleBinding) {
            removeMappedBoundModule(repositoryInModelServer, moduleBinding.moduleNodeId)
        } else if (moduleBinding is ProjectModuleBinding) {
            removeMappedModule(repositoryInModelServer, moduleBinding)
        } else {
            throw UnsupportedOperationException("Unsupported ModuleBinding " + moduleBinding.javaClass)
        }
    }

    fun removeMappedModule(repositoryInModelServer: CloudRepository, binding: ProjectModuleBinding) {
        removeMappedBoundModule(repositoryInModelServer, binding.moduleNodeId)
    }

    fun addTransientBoundModule(repositoryInModelServer: CloudRepository, branch: IBranch?, cloudNode: INode?) {
        modifyState(
            _return_P1_E0_to_Consumer_adapter(object :
                _return_P1_E0<Unit, CloudResourcesConfigurationComponent.State> {
                public override fun invoke(state: CloudResourcesConfigurationComponent.State) {
                    return PArea((branch)!!).executeRead({
                        val moduleName: String? = (cloudNode as PNodeAdapter?)!!.getPropertyValue("name")
                        state.transientModules.add(repositoryInModelServer.completeId() + "#" + moduleName)
                        Unit
                    })
                }
            }),
        )
    }

    fun removeTransientBoundModule(repositoryInModelServer: CloudRepository, branch: IBranch?, cloudNode: INode?) {
        modifyState(
            _return_P1_E0_to_Consumer_adapter(object :
                _return_P1_E0<Unit, CloudResourcesConfigurationComponent.State> {
                public override fun invoke(state: CloudResourcesConfigurationComponent.State) {
                    return PArea((branch)!!).executeRead({
                        val moduleName: String? = (cloudNode as PNodeAdapter?)!!.getPropertyValue("name")
                        val transientModuleDesc: String = repositoryInModelServer.completeId() + "#" + moduleName
                        state.transientModules.remove(transientModuleDesc)
                        Unit
                    })
                }
            }),
        )
    }

    fun removeTransientBoundModule(repositoryInModelServer: CloudRepository, branch: IBranch, nodeId: Long) {
        modifyState(
            _return_P1_E0_to_Consumer_adapter(object :
                _return_P1_E0<Unit, CloudResourcesConfigurationComponent.State> {
                public override fun invoke(state: CloudResourcesConfigurationComponent.State) {
                    return PArea(branch).executeRead({
                        val moduleName: String? = branch.readTransaction.getProperty(nodeId, "name")
                        val transientModuleDesc: String = repositoryInModelServer.completeId() + "#" + moduleName
                        state.transientModules.remove(transientModuleDesc)
                        Unit
                    })
                }
            }),
        )
    }

    fun removeMappedBoundModule(repositoryInModelServer: CloudRepository, nodeId: Long) {
        val branch: IBranch = repositoryInModelServer.activeBranch.branch
        modifyState(
            _return_P1_E0_to_Consumer_adapter<CloudResourcesConfigurationComponent.State>(object :
                _return_P1_E0<Unit, CloudResourcesConfigurationComponent.State> {
                public override fun invoke(state: CloudResourcesConfigurationComponent.State) {
                    return PArea(branch).executeRead({
                        val moduleName: String? = branch.readTransaction.getProperty(nodeId, "name")
                        val moduleDesc: String = repositoryInModelServer.completeId() + "#" + moduleName
                        state.mappedModules.remove(moduleDesc)
                        Unit
                    })
                }
            }),
        )
    }

    fun addTransientBoundModule(repositoryInModelServer: CloudRepository, branch: IBranch?, cloudNodeId: Long) {
        addTransientBoundModule(repositoryInModelServer, branch, PNodeAdapter(cloudNodeId, (branch)!!))
    }

    fun addTransientBoundProject(repositoryInModelServer: CloudRepository, cloudProject: SNode?) {
        modifyState(object : Consumer<CloudResourcesConfigurationComponent.State> {
            public override fun accept(state: CloudResourcesConfigurationComponent.State) {
                repositoryInModelServer.runRead(object : Runnable {
                    public override fun run() {
                        state.transientProjects.add(repositoryInModelServer.completeId())
                    }
                })
            }
        })
    }

    fun addTransientBoundModule(repositoryInModelServer: CloudRepository, nodeTreeNode: PNodeAdapter) {
        modifyState(
            _return_P1_E0_to_Consumer_adapter(object :
                _return_P1_E0<Unit, CloudResourcesConfigurationComponent.State> {
                public override fun invoke(state: CloudResourcesConfigurationComponent.State) {
                    return PArea(nodeTreeNode.branch).executeRead({
                        val moduleName: String? = nodeTreeNode.getPropertyValue("name")
                        state.transientModules.add(repositoryInModelServer.completeId() + "#" + moduleName)
                        Unit
                    })
                }
            }),
        )
    }

    fun addMappedBoundModule(repositoryInModelServer: CloudRepository?, nodeTreeNode: PNodeAdapter?) {
        if (repositoryInModelServer == null) {
            throw IllegalArgumentException("treeInRepository should not be null")
        }
        modifyState(
            _return_P1_E0_to_Consumer_adapter(object :
                _return_P1_E0<Unit, CloudResourcesConfigurationComponent.State> {
                public override fun invoke(state: CloudResourcesConfigurationComponent.State) {
                    return PArea(nodeTreeNode!!.branch).executeRead({
                        val moduleName: String? =
                            (nodeTreeNode as PNodeAdapter?)!!.getPropertyValue(PROPS.`name$MnvL`.getName())
                        if (moduleName == null) {
                            throw IllegalStateException("module should not have null name")
                        }
                        state.mappedModules.add(repositoryInModelServer.completeId() + "#" + moduleName)
                        Unit
                    })
                }
            }),
        )
    }

    private fun addModelServersAsSpecifiedInPersistedBindingConfiguration() {
        val state: CloudResourcesConfigurationComponent.State = readState()
        for (repoUrl: String? in state.modelServers) {
            println("addModelServersAsSpecifiedInPersistedBindingConfiguration " + repoUrl)
            val cloudRepository: ModelServerConnection? = ensureModelServerIsPresent(repoUrl)
        }
    }

    private fun bindTransientModulesAsSpecifiedInPersistedConfiguration() {
        val state: CloudResourcesConfigurationComponent.State = readState()
        for (moduleStr: String? in state.transientModules) {
            val parts: Array<String> = moduleStr!!.split("#".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
            if (parts.size != 2) {
                if (LOG.isEnabledFor(Level.FATAL)) {
                    LOG.fatal(
                        "The configuration of Modelix is not correct, please check .mps/cloudResources.xml. Module entry: " + moduleStr,
                        RuntimeException(),
                    )
                }
                continue
            }
            val repositoryInModelServer: CloudRepository =
                CloudRepository.Companion.fromPresentationString(parts.get(0))
            val modelServer: ModelServerConnection? =
                ensureModelServerIsPresent(repositoryInModelServer.modelServer.baseUrl)
            withConnectedCloudRepo(
                modelServer,
                object : Consumer<ModelServerConnection?> {
                    public override fun accept(msc: ModelServerConnection?) {
                        bindToTransientModules(
                            repositoryInModelServer,
                            SetSequence.fromSetAndArray(HashSet(), parts.get(1)),
                        )
                    }
                },
            )
        }
    }

    private fun bindMappedModulesAsSpecifiedInPersistedConfiguration() {
        val state: CloudResourcesConfigurationComponent.State = readState()
        for (moduleStr: String? in state.mappedModules) {
            val parts: Array<String> = moduleStr!!.split("#".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
            if (parts.size != 2) {
                if (LOG.isEnabledFor(Level.FATAL)) {
                    LOG.fatal(
                        "The configuration of Modelix is not correct, please check .mps/cloudResources.xml. Module entry: " + moduleStr,
                        RuntimeException(),
                    )
                }
                continue
            }
            val repositoryInModelServer: CloudRepository =
                CloudRepository.Companion.fromPresentationString(parts.get(0))
            val modelServer: ModelServerConnection? =
                ensureModelServerIsPresent(repositoryInModelServer.modelServer.baseUrl)
            withConnectedCloudRepo(
                modelServer,
                object : Consumer<ModelServerConnection?> {
                    public override fun accept(msc: ModelServerConnection?) {
                        bindToMappedModules(repositoryInModelServer, SetSequence.fromSetAndArray(HashSet(), parts.get(1)))
                    }
                },
            )
        }
    }

    /**
     * FIXME we should probably not identify modules by name but some unique identifier instead
     *
     * @param repositoryInModelServer
     * @param modulesToBind
     */
    private fun bindToMappedModules(repositoryInModelServer: CloudRepository, modulesToBind: Set<String?>) {
        SharedExecutors.FIXED.execute(object : Runnable {
            public override fun run() {
                repositoryInModelServer.runRead(object : Consumer<PNodeAdapter> {
                    public override fun accept(rootNode: PNodeAdapter) {
                        for (child: INode in Sequence.fromIterable(rootNode.allChildren)) {
                            val name: String? = child.getPropertyValue("name")
                            if (SetSequence.fromSet(modulesToBind).contains(name)) {
                                val physicalModule: SModule? = findPhysicalModule(name)
                                if (physicalModule == null) {
                                    Messages.showErrorDialog(
                                        project,
                                        "We cannot instantiate the mapped binding to " + name + " because the module is missing",
                                        "Error on mapped binding",
                                    )
                                } else {
                                    repositoryInModelServer.addBinding(
                                        ProjectModuleBinding(
                                            INodeUtils.nodeIdAsLong(
                                                child,
                                            ),
                                            physicalModule,
                                            SyncDirection.TO_MPS,
                                        ),
                                    )
                                }
                            }
                        }
                    }
                })
            }
        })
    }

    private fun findPhysicalModule(moduleName: String?): SModule? {
        for (physicalModule: SModule in ListSequence.fromList(
            ProjectHelper.toMPSProject(
                project,
            )!!.getProjectModules(),
        )) {
            if (Objects.equals(physicalModule.getModuleName(), moduleName)) {
                return physicalModule
            }
        }
        return null
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(PersistedBindingConfiguration::class.java)
        private val instances: Map<Project?, PersistedBindingConfiguration> = MapSequence.fromMap(HashMap())
        fun getInstance(project: Project?): PersistedBindingConfiguration? {
            if (!(MapSequence.fromMap(instances).containsKey(project))) {
                MapSequence.fromMap(instances).put(project, PersistedBindingConfiguration(project))
            }
            return MapSequence.fromMap(instances).get(project)
        }

        fun getInstance(project: jetbrains.mps.project.Project?): PersistedBindingConfiguration? {
            return getInstance(ProjectHelper.toIdeaProject(project))
        }

        fun disposeInstance(project: Project?) {
            val instance: PersistedBindingConfiguration? = MapSequence.fromMap(instances).removeKey(project)
            if (instance != null) {
                instance.dispose()
            }
        }

        private fun ensureModelServerIsPresent(url: String?): ModelServerConnection? {
            return ModelServerConnections.instance.ensureModelServerIsPresent(url)
        }

        private fun withConnectedCloudRepoHelper(
            modelServer: ModelServerConnection?,
            consumer: Consumer<ModelServerConnection?>,
            nAttempts: Int,
        ) {
            if (modelServer!!.isConnected) {
                consumer.accept(modelServer)
            } else {
                if (nAttempts <= 0) {
                    LOG.error("Unable to connect to Modelix server. Modelix configuration aborted", null)
                    return
                }
                modelServer.reconnect()
                Thread(object : Runnable {
                    public override fun run() {
                        try {
                            Thread.sleep(250)
                        } catch (e: InterruptedException) {
                        }
                        withConnectedCloudRepoHelper(modelServer, consumer, nAttempts - 1)
                    }
                }).start()
            }
        }

        /**
         * Sometimes we need to wait for the repository to be connected. This is the case for example on starting the plugin.
         */
        private fun withConnectedCloudRepo(
            modelServer: ModelServerConnection?,
            consumer: Consumer<ModelServerConnection?>,
        ) {
            withConnectedCloudRepoHelper(modelServer, consumer, 20)
        }

        /**
         * FIXME we should probably not identify modules by name but some unique identifier instead
         *
         * @param repositoryInModelServer
         * @param modulesToBind
         */
        private fun bindToTransientModules(repositoryInModelServer: CloudRepository, modulesToBind: Set<String?>) {
            SharedExecutors.FIXED.execute(object : Runnable {
                public override fun run() {
                    repositoryInModelServer.runRead(object : Consumer<PNodeAdapter> {
                        public override fun accept(rootNode: PNodeAdapter) {
                            for (child: INode in Sequence.fromIterable(rootNode.allChildren)) {
                                val name: String? = child.getPropertyValue("name")
                                if (SetSequence.fromSet(modulesToBind).contains(name)) {
                                    repositoryInModelServer.addTransientModuleBinding(child)
                                }
                            }
                        }
                    })
                }
            })
        }
    }
}
