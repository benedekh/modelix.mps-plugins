package org.modelix.model.mpsplugin

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.internal.collections.runtime.CollectionSequence
import jetbrains.mps.internal.collections.runtime.IMapping
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.project.ModelImporter
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.util.IterableUtil
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.event.SNodeAddEvent
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IBranch
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.ITransaction
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.deepUnwrapNode
import org.modelix.model.area.CompositeArea
import org.modelix.model.area.IArea
import org.modelix.model.area.PArea
import org.modelix.model.lazy.IBulkTree
import org.modelix.model.lazy.PrefetchCache.Companion.with
import org.modelix.model.mpsadapters.mps.MPSArea
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter
import org.modelix.model.mpsplugin.NodeMap.BranchProvider
import java.util.Objects
import java.util.Optional

/*Generated by MPS */
class ModelSynchronizer(
    protected var modelNodeId: Long,
    protected var model: SModel?,
    private val cloudRepository: ICloudRepository
) {
    protected var nodeMap: NodeMap = NodeMap(object : BranchProvider {
        override val branch: IBranch?
            get() {
                return this@ModelSynchronizer.branch
            }
    })
    private val pendingReferences: PendingReferences = PendingReferences()
    val branch: IBranch
        get() {
            return cloudRepository.branch
        }

    fun prefetchModelContent(tree: ITree?) {
        if (tree is IBulkTree) {
            tree.getDescendants(modelNodeId, true)
        }
    }

    fun runAndFlushReferences(runnable: Runnable) {
        pendingReferences.runAndFlush(runnable)
    }

    fun syncModelToMPS(tree: ITree?, withInitialRemoval: Boolean) {
        with((tree)!!, {
            if (LOG.isTraceEnabled()) {
                LOG.trace(
                    "syncModel initialRemoval=" + withInitialRemoval + " on model " + model!!.getName().getLongName()
                )
            }
            if (withInitialRemoval) {
                for (root: SNode? in ListSequence.fromList(
                    ListSequence.fromListWithValues(
                        ArrayList(),
                        model!!.getRootNodes()
                    )
                ).ofType(
                    SNode::class.java
                )) {
                    ListSequence.fromList(SNodeOperations.getChildren(root)).visitAll(object : IVisitor<SNode?>() {
                        public override fun visit(it: SNode?) {
                            SNodeOperations.deleteNode(it)
                        }
                    })
                }
            }
            pendingReferences.runAndFlush(object : Runnable {
                public override fun run() {
                    prefetchModelContent(tree)
                    syncRootNodesToMPS()
                    syncModelPropertiesToMPS(tree)
                }
            })
            Unit
        })
    }

    fun syncModelPropertiesToMPS(tree: ITree?) {
        ModelPropertiesSynchronizer.Companion.syncModelPropertiesToMPS(tree, model, modelNodeId, cloudRepository)
    }

    fun fullSyncFromMPS() {
        val tree: ITree = branch.transaction.tree
        if (!(tree.containsNode(modelNodeId))) {
            if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn(
                    "Skipping sync for " + this + ", because the model node " + java.lang.Long.toHexString(
                        modelNodeId
                    ) + " doesn't exist in the cloud model"
                )
            }
            return
        }
        with(tree, {
            pendingReferences.runAndFlush(object : Runnable {
                public override fun run() {
                    prefetchModelContent(tree)
                    syncModelPropertiesFromMPS()
                    syncRootNodesFromMPS()
                }
            })
            Unit
        })
        PArea((branch)!!).executeWrite({ Unit })
    }

    protected fun syncRootNodesFromMPS() {
        val t: IWriteTransaction = branch!!.writeTransaction
        val syncedNodes = createChildrenSynchronizer(
            modelNodeId, LINKS.`rootNodes$jxXY`.getName()
        ).syncToCloud(t)
        for (syncedNode: IMapping<Long?, SNode?> in MapSequence.fromMap(syncedNodes)) {
            syncNodeFromMPS(syncedNode.value(), true)
        }
    }

    protected fun syncRootNodesToMPS() {
        val t: ITransaction = branch.transaction
        val syncedNodes = createChildrenSynchronizer(
            modelNodeId, LINKS.`rootNodes$jxXY`.name
        ).syncToMPS(t.tree)
        for (syncedNode in syncedNodes) {
            syncNodeToMPS(syncedNode.key, t.tree, true)
        }
    }

    fun syncModelPropertiesFromMPS() {
        ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncModelPropertiesFromMPS()
    }

    fun syncUsedLanguagesAndDevKitsFromMPS() {
        ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncUsedLanguagesAndDevKitsFromMPS()
    }

    fun syncModelImportsFromMPS() {
        ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncModelImportsFromMPS()
    }

    protected fun getOrCreateMPSNode(nodeId: Long, tree: ITree): SNode {
        if (nodeId == 0L || nodeId == ITree.ROOT_ID) {
            throw RuntimeException("Invalid ID " + nodeId)
        }
        return nodeMap.getOrCreateNode(nodeId, object : _return_P0_E0<SAbstractConcept> {
            public override fun invoke(): SAbstractConcept {
                val concept: IConcept? = tree.getConcept(nodeId)
                if (concept == null) {
                    throw RuntimeException("Node has no concept: " + nodeId)
                }
                val sconcept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(concept)
                if (sconcept == null) {
                    throw RuntimeException("Node has no MPS concept: " + nodeId + ", " + concept)
                }
                return sconcept
            }
        })
    }

    fun syncNodeToMPS(nodeId: Long, tree: ITree, includeDescendants: Boolean) {
        if (LOG.isTraceEnabled()) {
            LOG.trace("syncNode nodeId: " + nodeId)
        }
        try {
            val concept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(tree.getConcept(nodeId))
            if (concept == null) {
                throw RuntimeException(
                    "Node has no concept: " + java.lang.Long.toHexString(nodeId) + ". Role: " + tree.getRole(
                        nodeId
                    ) + ", Concept: " + tree.getConcept(nodeId)
                )
            }
            val node: SNode? = nodeMap.getOrCreateNode(nodeId, object : _return_P0_E0<SAbstractConcept> {
                public override fun invoke(): SAbstractConcept {
                    return concept
                }
            })
            for (property: SProperty in CollectionSequence.fromCollection<SProperty>(concept.getProperties())) {
                node!!.setProperty(property, tree.getProperty(nodeId, property.getName()))
            }
            for (link: SReferenceLink in CollectionSequence.fromCollection(concept.getReferenceLinks())) {
                syncReferenceToMPS(nodeId, link.getName(), tree)
            }
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Failed to sync node " + nodeId, ex)
            }
        }
        syncChildrenToMPS(nodeId, tree, includeDescendants)
    }

    fun syncPropertyToMPS(nodeId: Long, role: String?, tree: ITree) {
        val concept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(tree.getConcept(nodeId))
        val mpsNode: SNode? = getOrCreateMPSNode(nodeId, tree)
        val mpsProperty: SProperty = findProperty(concept, role)
        mpsNode!!.setProperty(mpsProperty, tree.getProperty(nodeId, (role)!!))
    }

    fun syncProperties(source: INode, target: INode) {
        for (property: IProperty in ListSequence.fromList(target.concept!!.getAllProperties())) {
            target.setPropertyValue(property.name, source.getPropertyValue(property.name))
        }
    }

    fun syncReferenceToMPS(nodeId: Long, role: String?, tree: ITree) {
        pendingReferences.add(object : _return_P0_E0<SNode> {
            public override fun invoke(): SNode? {
                try {
                    val node: SNode? = getOrCreateMPSNode(nodeId, tree)
                    val target: INodeReference? = tree.getReferenceTarget(nodeId, (role)!!)
                    val repo: SRepository? = model!!.getRepository()
                    var resolveContext: IArea? = null
                    if (repo == null) {
                        // We look in NodeMap instead
                        resolveContext = CompositeArea(PArea(branch), nodeMap)
                    } else {
                        resolveContext = CompositeArea(PArea(branch), MPSArea(repo), nodeMap)
                    }
                    var targetNode: INode? = check_l95w85_a0g0a0a0a0a14(target, resolveContext)
                    val targetSNode: SNode?
                    var targetAsPNodeAdapter: PNodeAdapter? = null
                    if (targetNode != null) {
                        targetNode = deepUnwrapNode(targetNode)
                    }
                    if (targetNode is PNodeAdapter) {
                        targetAsPNodeAdapter = targetNode
                    }
                    if (targetAsPNodeAdapter == null) {
                        targetSNode = NodeToSNodeAdapter.Companion.wrap(targetNode, repo)
                    } else {
                        val targetId: Long = (if (targetAsPNodeAdapter == null) 0L else targetAsPNodeAdapter.nodeId)
                        targetSNode = (if (targetId == 0L) null else getOrCreateMPSNode(targetId, tree))
                    }
                    val link: SReferenceLink = findReferenceLink(node!!.getConcept(), role)
                    node.setReferenceTarget(link, targetSNode)
                    return targetSNode
                } catch (e: RuntimeException) {
                    throw RuntimeException("issue in syncReference, nodeId " + nodeId + ", role " + role, e)
                }
            }
        })
    }

    fun syncChildrenToMPS(nodeId: Long, tree: ITree, includeDescendants: Boolean) {
        for (linkName: String? in tree.getChildRoles(nodeId)) {
            syncChildrenToMPS(nodeId, linkName, tree, includeDescendants)
        }
    }

    fun syncChildrenToMPS(parentId: Long, role: String?, tree: ITree, includeDescendants: Boolean) {
        if (LOG.isTraceEnabled()) {
            LOG.trace("syncChildren nodeId:" + parentId + ", role:" + role + ", descendants? " + includeDescendants)
        }
        val syncedNodes = createChildrenSynchronizer(parentId, role).syncToMPS(tree)

        // order
        val isRootNodes: Boolean = parentId == modelNodeId && Objects.equals(role, LINKS.`rootNodes$jxXY`.getName())
        if (!(isRootNodes)) {
            val parentNode: SNode? = nodeMap.getNode(parentId)
            val link: SContainmentLink = findContainmentLink(SNodeOperations.getConcept(parentNode), role)
            var index: Int = 0
            for (expectedId: Long in Sequence.fromIterable<Long>(
                IterableUtil.asIterable<Long>(
                    tree.getChildren(
                        parentId,
                        role
                    ).iterator()
                )
            )) {
                val expectedNode: SNode? = nodeMap.getNode(expectedId)
                val actualNode: SNode =
                    ListSequence.fromList(SNodeOperations.getChildren(parentNode, link)).getElement(index)
                if (!(Objects.equals(actualNode, expectedNode))) {
                    SNodeOperations.deleteNode(expectedNode)
                    ListSequence.fromList(SNodeOperations.getChildren(parentNode, link))
                        .insertElement(index, expectedNode)
                }
                index++
            }
        }
        if (includeDescendants) {
            for (childCloudId: Long in MapSequence.fromMap(syncedNodes).keys) {
                syncNodeToMPS(childCloudId, tree, includeDescendants)
            }
        }
    }

    private fun createChildrenSynchronizer(parentId: Long, role: String?): Synchronizer<SNode> {
        return object : Synchronizer<SNode>(parentId, role) {
            public override fun associate(
                tree: ITree,
                cloudChildren: List<Long>,
                mpsChildren: List<SNode>,
                direction: SyncDirection?
            ): Map<Long, SNode> {
                val mpsIdToNode: Map<String, SNode> = MapSequence.fromMap(HashMap())
                ListSequence.fromList<SNode?>(mpsChildren).visitAll(object : IVisitor<SNode>() {
                    public override fun visit(it: SNode) {
                        MapSequence.fromMap(mpsIdToNode).put(it.getNodeId().toString(), it)
                    }
                })
                val mpsChildrenSet: Set<SNode?> = SetSequence.fromSetWithValues(HashSet(), mpsChildren)
                val cloudChildrenSet: Set<Long> = SetSequence.fromSetWithValues(HashSet(), cloudChildren)
                val mapping: Map<Long, SNode> = MapSequence.fromMap(HashMap())
                for (cloudChild: Long in cloudChildren) {
                    var mpsChild: SNode? = nodeMap.getNode(cloudChild)
                    if (mpsChild == null) {
                        val persistedMpsId: String? = tree.getProperty(cloudChild, MPS_NODE_ID_PROPERTY_NAME)
                        if (persistedMpsId != null) {
                            mpsChild = MapSequence.fromMap(mpsIdToNode).get(persistedMpsId)
                            nodeMap.put(cloudChild, mpsChild)
                        }
                    }
                    if (mpsChild != null && SetSequence.fromSet<SNode?>(mpsChildrenSet).contains(mpsChild)) {
                        MapSequence.fromMap(mapping).put(cloudChild, mpsChild)
                    }
                }
                for (mpsChild: SNode? in ListSequence.fromList<SNode?>(mpsChildren)) {
                    val cloudChild: Long = nodeMap.getId(mpsChild)
                    if ((cloudChild != 0L) && tree.containsNode(cloudChild) && SetSequence.fromSet<Long>(
                            cloudChildrenSet
                        ).contains(cloudChild)
                    ) {
                        MapSequence.fromMap(mapping).put(cloudChild, mpsChild)
                    }
                }
                return mapping
            }

            public override fun createCloudChild(t: IWriteTransaction, mpsChild: SNode): Long {
                val nodeId: Long = getOrCreateCloudNode(mpsChild, parentId, role)
                if (t.getParent(nodeId) != parentId || t.getRole(nodeId) !== role) {
                    t.moveChild(parentId, role, -1, nodeId)
                }
                return nodeId
            }

            override fun createMPSChild(tree: ITree, cloudChildId: Long): SNode {
                val newNode = getOrCreateMPSNode(cloudChildId, tree)
                if (isRootNodes) {
                    model!!.addRootNode(newNode)
                } else {
                    val parentMPSNode: SNode? = nodeMap.getNode(tree.getParent(cloudChildId))
                    ListSequence.fromList(
                        SNodeOperations.getChildren(
                            parentMPSNode,
                            findContainmentLink(SNodeOperations.getConcept(parentMPSNode), role)
                        )
                    ).addElement(newNode)
                }
                return newNode
            }

            override val mPSChildren: Iterable<SNode>
                get() {
                    if (isRootNodes) {
                        return model!!.getRootNodes()
                    } else {
                        val parentNode: SNode? = nodeMap.getNode(parentId)
                        if (parentNode == null) {
                            throw IllegalStateException("Node has no parent but it is not a root node")
                        }
                        val children: Iterable<SNode> =
                            parentNode.getChildren(findContainmentLink(parentNode.getConcept(), role))
                        return Sequence.fromIterable(children).ofType(
                            SNode::class.java
                        )
                    }
                }
            private val isRootNodes: Boolean
                private get() {
                    return parentId == modelNodeId && Objects.equals(role, LINKS.`rootNodes$jxXY`.getName())
                }

            public override fun removeMPSChild(mpsChild: SNode) {
                SNodeOperations.deleteNode(mpsChild)
            }
        }
    }

    fun findContainmentLink(concept: SAbstractConcept, linkName: String?): SContainmentLink {
        val links: Iterable<SContainmentLink> = concept.getContainmentLinks()
        val link: SContainmentLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SContainmentLink>() {
            public override fun accept(it: SContainmentLink): Boolean {
                return Objects.equals(it.getName(), linkName)
            }
        })
        if (link == null) {
            throw RuntimeException(concept.toString() + "." + linkName + " not found")
        }
        return link
    }

    fun findReferenceLink(concept: SAbstractConcept, linkName: String?): SReferenceLink {
        val links: Iterable<SReferenceLink> = concept.getReferenceLinks()
        val link: SReferenceLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SReferenceLink>() {
            public override fun accept(it: SReferenceLink): Boolean {
                return Objects.equals(it.getName(), linkName)
            }
        })
        if (link == null) {
            throw RuntimeException(concept.toString() + "." + linkName + " not found")
        }
        return link
    }

    fun findProperty(concept: SAbstractConcept?, role: String?): SProperty {
        val properties: Iterable<SProperty> = concept!!.getProperties()
        val property: SProperty? = Sequence.fromIterable(properties).findFirst(object : IWhereFilter<SProperty>() {
            public override fun accept(it: SProperty): Boolean {
                return Objects.equals(it.getName(), role)
            }
        })
        if (property == null) {
            throw RuntimeException(concept.toString() + "." + role + " not found")
        }
        return property
    }

    fun syncNodeFromMPS(parentNode: SNode?, includeDescendants: Boolean) {
        if (parentNode!!.getModel() !== model) {
            throw RuntimeException("Not part of this model: " + parentNode)
        }
        val branch: IBranch? = branch
        val t: IWriteTransaction = branch!!.writeTransaction
        val concept: SConcept = parentNode!!.getConcept()
        val parentNodeId: Long = getOrCreateCloudNode(parentNode)
        val cloudNode: INode = PNodeAdapter(parentNodeId, (branch))
        MPSNodeMapping.mapToMpsNode(cloudNode, parentNode)
        for (property: SProperty in CollectionSequence.fromCollection<SProperty>(concept.getProperties())) {
            val oldValue: String? = t.getProperty(parentNodeId, property.getName())
            val newValue: String? = parentNode.getProperty(property)
            if (!(Objects.equals(newValue, oldValue))) {
                t.setProperty(parentNodeId, property.getName(), newValue)
            }
        }
        for (link: SReferenceLink in CollectionSequence.fromCollection<SReferenceLink>(concept.getReferenceLinks())) {
            pendingReferences.add(object : _return_P0_E0<SNode> {
                public override fun invoke(): SNode? {
                    val targetSNode: SNode? = parentNode.getReferenceTarget(link)
                    val currentTarget: INodeReference? = t.getReferenceTarget(parentNodeId, link.getName())
                    if (targetSNode == null) {
                        if (currentTarget != null) {
                            t.setReferenceTarget(parentNodeId, link.getName(), null)
                        }
                    } else {
                        val targetId: Long = nodeMap.getId(targetSNode)
                        val targetNode: INode?
                        if (targetId == 0L || !(t.containsNode(targetId))) {
                            targetNode = SNodeToNodeAdapter.Companion.wrap(targetSNode)
                        } else {
                            targetNode = PNodeAdapter(targetId, (branch))
                        }
                        if (!(Objects.equals(currentTarget, targetNode!!.reference))) {
                            t.setReferenceTarget(parentNodeId, link.getName(), targetNode.reference)
                        }
                    }
                    return null as SNode?
                }
            })
        }
        for (link: SContainmentLink? in CollectionSequence.fromCollection<SContainmentLink>(concept.getContainmentLinks())) {
            syncChildrenFromMPS(link, t, parentNodeId, parentNode, includeDescendants)
        }
    }

    protected fun syncChildrenFromMPS(
        link: SContainmentLink?,
        t: IWriteTransaction,
        parentNodeId: Long,
        parentNode: SNode?,
        includeDescendants: Boolean
    ) {
        val syncedNodes: Map<Long, SNode> = createChildrenSynchronizer(parentNodeId, link!!.getName()).syncToCloud(t)

        // order
        val sortedMappings: Iterable<IMapping<Long, SNode>> =
            MapSequence.fromMap(syncedNodes).sort(object : ISelector<IMapping<Long, SNode>, Int>() {
                public override fun select(it: IMapping<Long, SNode>): Int {
                    val mpsNode = it.value()
                    return SNodeOperations.getIndexInParent(mpsNode)
                }
            }, true)
        var index: Int = 0
        for (mapping: IMapping<Long, SNode> in sortedMappings) {
            val cloudId: Long = mapping.key()
            val children: Iterable<Long> = t.getChildren(parentNodeId, link.getName())
            val actualId: Long = Optional.ofNullable(Sequence.fromIterable(children).skip(1).first()).orElse(0L)
            if (actualId != cloudId) {
                t.moveChild(parentNodeId, link.getName(), index, cloudId)
            }
            index++
        }
        if (includeDescendants) {
            for (childNode: SNode? in Sequence.fromIterable(MapSequence.fromMap(syncedNodes).values)) {
                syncNodeFromMPS(childNode, includeDescendants)
            }
        }
    }

    protected fun getOrCreateCloudNode(node: SNode?, parentIfCreate: Long, roleIfCreate: String?): Long {
        var nodeId: Long = nodeMap.getId(node)
        val t: IWriteTransaction = branch!!.writeTransaction
        if (nodeId == 0L || !(t.containsNode(nodeId))) {
            nodeId = t.addNewChild(
                parentIfCreate, roleIfCreate, -1, SConceptAdapter.Companion.wrap(
                    node!!.getConcept()
                )
            )
            nodeMap.put(nodeId, node)
        }
        return nodeId
    }

    protected fun getOrCreateCloudNode(node: SNode?): Long {
        return getOrCreateCloudNode(node, ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE)
    }

    fun getCloudNodeId(node: SNode?): Long {
        return nodeMap.getId(node)
    }

    fun getOrSyncToCloud(node: SNode, t: IWriteTransaction): Long {
        var cloudId: Long = nodeMap.getId(node)
        if (cloudId == 0L || !(t.containsNode(cloudId))) {
            val parent: SNode? = node.getParent()
            if (parent == null) {
                syncRootNodesFromMPS()
            } else {
                val parentCloudId: Long = getOrSyncToCloud(parent, t)
                syncNodeFromMPS(parent, true)
            }
            cloudId = nodeMap.getId(node)
        }
        return cloudId
    }

    fun handleMPSNodeAdded(e: SNodeAddEvent) {
        PArea((branch)!!).executeWrite<Unit>({
            pendingReferences.runAndFlush(object : Runnable {
                public override fun run() {
                    val t: IWriteTransaction = branch.writeTransaction
                    val parentId: Long
                    val role: String
                    if (e.isRoot()) {
                        parentId = modelNodeId
                        role = LINKS.`rootNodes$jxXY`.getName()
                    } else {
                        parentId = nodeMap.getId(e.getParent())
                        role = e.getAggregationLink()!!.getName()
                    }
                    if (parentId == 0L || !(t.containsNode(parentId))) {
                        return
                    }
                    val child: SNode = e.getChild()
                    if (e.isRoot()) {
                        var childId: Long = nodeMap.getId(child)
                        if (childId == 0L || !(t.containsNode(childId))) {
                            childId = t.addNewChild(
                                parentId,
                                role,
                                -1,
                                SConceptAdapter.Companion.wrap(SNodeOperations.getConcept(child))
                            )
                            nodeMap.put(childId, child)
                        } else {
                            t.moveChild(parentId, role, -1, childId)
                        }
                    } else {
                        syncChildrenFromMPS(e.getAggregationLink(), t, parentId, e.getParent(), false)
                    }
                    syncNodeFromMPS(child, true)
                }
            })
            Unit
        })
    }

    fun handleMPSNodeRemoved(e: SNodeRemoveEvent) {
        val branch: IBranch? = branch
        PArea((branch)!!).executeWrite({
            val t: IWriteTransaction = branch.writeTransaction
            val childId: Long = nodeMap.getId(e.getChild())
            if (childId != 0L && t.containsNode(childId)) {
                t.moveChild(ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE, -1, childId)
            }
            Unit
        })
    }

    fun handleReferenceChanged(e: SReferenceChangeEvent) {
        val branch: IBranch? = branch
        PArea((branch)!!).executeWrite<Unit>({
            val t: IWriteTransaction = this.branch!!.writeTransaction
            val targetSNode: SNode? = check_l95w85_a0b0a0a1a96(e.getNewValue())
            val sourceId: Long = getOrCreateCloudNode(e.getNode())
            if (targetSNode == null) {
                t.setReferenceTarget(sourceId, e.getAssociationLink().getName(), null)
            } else {
                val targetId: Long = nodeMap.getId(targetSNode)
                val targetNode: INode?
                if (targetId == 0L || !(t.containsNode(targetId))) {
                    targetNode = SNodeToNodeAdapter.Companion.wrap(targetSNode)
                } else {
                    targetNode = PNodeAdapter(targetId, (branch))
                }
                t.setReferenceTarget(sourceId, e.getAssociationLink().getName(), targetNode!!.reference)
            }
            Unit
        })
    }

    inner class PendingReferences() {
        protected var currentReferences: List<_return_P0_E0<out SNode>>? = null
        @Synchronized
        fun runAndFlush(runnable: Runnable) {
            if (currentReferences == null) {
                try {
                    currentReferences = ListSequence.fromList(ArrayList())
                    runnable.run()
                } finally {
                    try {
                        processPendingReferences()
                    } catch (ex: Exception) {
                        if (LOG.isEnabledFor(Level.ERROR)) {
                            LOG.error("Failed to process pending reference", ex)
                        }
                    }
                    currentReferences = null
                }
            } else {
                runnable.run()
            }
        }

        @Synchronized
        fun add(ref: _return_P0_E0<out SNode>) {
            if (currentReferences == null) {
                throw IllegalStateException("Call runAndFlush first")
            }
            ListSequence.fromList(currentReferences).addElement(ref)
        }

        protected fun processPendingReferences() {
            val targetModels: Set<SModel?> = SetSequence.fromSet(HashSet())
            for (r: _return_P0_E0<out SNode> in ListSequence.fromList<_return_P0_E0<out SNode>>(currentReferences)) {
                try {
                    val targetNode: SNode = r.invoke()
                    SetSequence.fromSet(targetModels).addElement(check_l95w85_a0a1a0a1a6tc(targetNode))
                } catch (ex: Exception) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("", ex)
                    }
                }
            }
            val modelsToImport: Iterable<SModel?> =
                SetSequence.fromSet(targetModels).where(object : IWhereFilter<SModel?>() {
                    public override fun accept(it: SModel?): Boolean {
                        return it != null && it !== model
                    }
                })
            if (Sequence.fromIterable(modelsToImport).isNotEmpty()) {
                val importer: ModelImporter = ModelImporter((model)!!)
                Sequence.fromIterable<SModel?>(modelsToImport).visitAll(object : IVisitor<SModel>() {
                    public override fun visit(it: SModel) {
                        importer.prepare(it.getReference())
                    }
                })
                importer.execute()
            }
        }
    }

    private object LINKS {
        /*package*/
        val `rootNodes$jxXY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x69652614fd1c514L,
            "rootNodes"
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(ModelSynchronizer::class.java)
        val USED_DEVKITS: String = "usedDevkits"
        val MPS_NODE_ID_PROPERTY_NAME: String = "#mpsNodeId#"
        private fun check_l95w85_a0g0a0a0a0a14(checkedDotOperand: INodeReference?, resolveContext: IArea): INode? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.resolveNode(resolveContext)
            }
            return null
        }

        private fun check_l95w85_a0b0a0a1a96(checkedDotOperand: SReference?): SNode? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getTargetNode()
            }
            return null
        }

        private fun check_l95w85_a0a1a0a1a6tc(checkedDotOperand: SNode?): SModel? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.getModel()
            }
            return null
        }
    }
}
