package org.modelix.model.mpsplugin

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.internal.collections.runtime.CollectionSequence
import jetbrains.mps.internal.collections.runtime.IMapping
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.project.ModelImporter
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.util.IterableUtil
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.event.SNodeAddEvent
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.language.SReferenceLink
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SReference
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IBranch
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.ITransaction
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.deepUnwrapNode
import org.modelix.model.api.resolveIn
import org.modelix.model.area.CompositeArea
import org.modelix.model.area.IArea
import org.modelix.model.area.PArea
import org.modelix.model.lazy.IBulkTree
import org.modelix.model.lazy.PrefetchCache.Companion.with
import org.modelix.model.mpsadapters.mps.MPSArea
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter
import org.modelix.model.mpsplugin.NodeMap.BranchProvider
import java.util.Objects
import java.util.Optional

/*Generated by MPS */
class ModelSynchronizer(
    protected var modelNodeId: Long,
    protected var model: SModel?,
    private val cloudRepository: ICloudRepository,
) {
    protected var nodeMap: NodeMap = NodeMap(object : BranchProvider {
        override val branch: IBranch
            get() {
                return this@ModelSynchronizer.branch
            }
    })
    private val pendingReferences: PendingReferences = PendingReferences()
    val branch: IBranch
        get() {
            return cloudRepository.branch
        }

    fun prefetchModelContent(tree: ITree?) {
        if (tree is IBulkTree) {
            tree.getDescendants(modelNodeId, true)
        }
    }

    fun runAndFlushReferences(runnable: Runnable) {
        pendingReferences.runAndFlush(runnable)
    }

    fun syncModelToMPS(tree: ITree?, withInitialRemoval: Boolean) {
        with((tree)!!, {
            if (LOG.isTraceEnabled) {
                LOG.trace(
                    "syncModel initialRemoval=" + withInitialRemoval + " on model " + model!!.name.longName,
                )
            }
            if (withInitialRemoval) {
                for (root: SNode? in ListSequence.fromList(
                    ListSequence.fromListWithValues(
                        ArrayList(),
                        model!!.rootNodes,
                    ),
                ).ofType(
                    SNode::class.java,
                )) {
                    ListSequence.fromList(SNodeOperations.getChildren(root)).visitAll(object : IVisitor<SNode?>() {
                        override fun visit(it: SNode?) {
                            SNodeOperations.deleteNode(it)
                        }
                    })
                }
            }
            pendingReferences.runAndFlush(object : Runnable {
                override fun run() {
                    prefetchModelContent(tree)
                    syncRootNodesToMPS()
                    syncModelPropertiesToMPS(tree)
                }
            })
        })
    }

    fun syncModelPropertiesToMPS(tree: ITree?) {
        ModelPropertiesSynchronizer.Companion.syncModelPropertiesToMPS(tree, model, modelNodeId, cloudRepository)
    }

    fun fullSyncFromMPS() {
        val tree: ITree = branch.transaction.tree
        if (!(tree.containsNode(modelNodeId))) {
            if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn(
                    "Skipping sync for " + this + ", because the model node " + java.lang.Long.toHexString(
                        modelNodeId,
                    ) + " doesn't exist in the cloud model",
                )
            }
            return
        }
        with(tree, {
            pendingReferences.runAndFlush(object : Runnable {
                override fun run() {
                    prefetchModelContent(tree)
                    syncModelPropertiesFromMPS()
                    syncRootNodesFromMPS()
                }
            })
        })
        PArea((branch)).executeWrite({ })
    }

    protected fun syncRootNodesFromMPS() {
        val t: IWriteTransaction = branch.writeTransaction
        val syncedNodes = createChildrenSynchronizer(
            modelNodeId,
            LINKS.`rootNodes$jxXY`.name,
        ).syncToCloud(t)
        for (syncedNode: IMapping<Long?, SNode?> in MapSequence.fromMap(syncedNodes)) {
            syncNodeFromMPS(syncedNode.value(), true)
        }
    }

    protected fun syncRootNodesToMPS() {
        val t: ITransaction = branch.transaction
        val syncedNodes = createChildrenSynchronizer(
            modelNodeId,
            LINKS.`rootNodes$jxXY`.name,
        ).syncToMPS(t.tree)
        for (syncedNode in syncedNodes) {
            syncNodeToMPS(syncedNode.key, t.tree, true)
        }
    }

    fun syncModelPropertiesFromMPS() {
        ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncModelPropertiesFromMPS()
    }

    fun syncUsedLanguagesAndDevKitsFromMPS() {
        ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncUsedLanguagesAndDevKitsFromMPS()
    }

    fun syncModelImportsFromMPS() {
        ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncModelImportsFromMPS()
    }

    protected fun getOrCreateMPSNode(nodeId: Long, tree: ITree): SNode {
        if (nodeId == 0L || nodeId == ITree.ROOT_ID) {
            throw RuntimeException("Invalid ID " + nodeId)
        }
        return nodeMap.getOrCreateNode(
            nodeId,
            object : _return_P0_E0<SAbstractConcept> {
                override fun invoke(): SAbstractConcept {
                    val concept: IConcept? = tree.getConcept(nodeId)
                    if (concept == null) {
                        throw RuntimeException("Node has no concept: " + nodeId)
                    }
                    val sconcept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(concept)
                    if (sconcept == null) {
                        throw RuntimeException("Node has no MPS concept: " + nodeId + ", " + concept)
                    }
                    return sconcept
                }
            },
        )
    }

    fun syncNodeToMPS(nodeId: Long, tree: ITree, includeDescendants: Boolean) {
        if (LOG.isTraceEnabled) {
            LOG.trace("syncNode nodeId: " + nodeId)
        }
        try {
            val concept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(tree.getConcept(nodeId))
            if (concept == null) {
                throw RuntimeException(
                    "Node has no concept: " + java.lang.Long.toHexString(nodeId) + ". Role: " + tree.getRole(
                        nodeId,
                    ) + ", Concept: " + tree.getConcept(nodeId),
                )
            }
            val node: SNode = nodeMap.getOrCreateNode(
                nodeId,
                object : _return_P0_E0<SAbstractConcept> {
                    override fun invoke(): SAbstractConcept {
                        return concept
                    }
                },
            )
            for (property: SProperty in CollectionSequence.fromCollection<SProperty>(concept.properties)) {
                node!!.setProperty(property, tree.getProperty(nodeId, property.name))
            }
            for (link: SReferenceLink in CollectionSequence.fromCollection(concept.referenceLinks)) {
                syncReferenceToMPS(nodeId, link.name, tree)
            }
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Failed to sync node " + nodeId, ex)
            }
        }
        syncChildrenToMPS(nodeId, tree, includeDescendants)
    }

    fun syncPropertyToMPS(nodeId: Long, role: String?, tree: ITree) {
        val concept: SAbstractConcept? = SConceptAdapter.Companion.unwrap(tree.getConcept(nodeId))
        val mpsNode: SNode = getOrCreateMPSNode(nodeId, tree)
        val mpsProperty: SProperty = findProperty(concept, role)
        mpsNode!!.setProperty(mpsProperty, tree.getProperty(nodeId, (role)!!))
    }

    fun syncProperties(source: INode, target: INode) {
        for (property: IProperty in ListSequence.fromList(target.concept!!.getAllProperties())) {
            target.setPropertyValue(property.name, source.getPropertyValue(property.name))
        }
    }

    fun syncReferenceToMPS(nodeId: Long, role: String?, tree: ITree) {
        pendingReferences.add(object : _return_P0_E0<SNode> {
            override fun invoke(): SNode? {
                try {
                    val node: SNode = getOrCreateMPSNode(nodeId, tree)
                    val target: INodeReference? = tree.getReferenceTarget(nodeId, (role)!!)
                    val repo: SRepository? = model!!.repository
                    var resolveContext: IArea? = null
                    if (repo == null) {
                        // We look in NodeMap instead
                        resolveContext = CompositeArea(PArea(branch), nodeMap)
                    } else {
                        resolveContext = CompositeArea(PArea(branch), MPSArea(repo), nodeMap)
                    }
                    var targetNode: INode? = check_l95w85_a0g0a0a0a0a14(target, resolveContext)
                    val targetSNode: SNode?
                    var targetAsPNodeAdapter: PNodeAdapter? = null
                    if (targetNode != null) {
                        targetNode = deepUnwrapNode(targetNode)
                    }
                    if (targetNode is PNodeAdapter) {
                        targetAsPNodeAdapter = targetNode
                    }
                    if (targetAsPNodeAdapter == null) {
                        targetSNode = NodeToSNodeAdapter.Companion.wrap(targetNode, repo)
                    } else {
                        val targetId: Long = (if (targetAsPNodeAdapter == null) 0L else targetAsPNodeAdapter.nodeId)
                        targetSNode = (if (targetId == 0L) null else getOrCreateMPSNode(targetId, tree))
                    }
                    val link: SReferenceLink = findReferenceLink(node!!.concept, role)
                    node.setReferenceTarget(link, targetSNode)
                    return targetSNode
                } catch (e: RuntimeException) {
                    throw RuntimeException("issue in syncReference, nodeId " + nodeId + ", role " + role, e)
                }
            }
        })
    }

    fun syncChildrenToMPS(nodeId: Long, tree: ITree, includeDescendants: Boolean) {
        for (linkName: String? in tree.getChildRoles(nodeId)) {
            syncChildrenToMPS(nodeId, linkName, tree, includeDescendants)
        }
    }

    fun syncChildrenToMPS(parentId: Long, role: String?, tree: ITree, includeDescendants: Boolean) {
        if (LOG.isTraceEnabled) {
            LOG.trace("syncChildren nodeId:" + parentId + ", role:" + role + ", descendants? " + includeDescendants)
        }
        val syncedNodes = createChildrenSynchronizer(parentId, role).syncToMPS(tree)

        // order
        val isRootNodes: Boolean = parentId == modelNodeId && Objects.equals(role, LINKS.`rootNodes$jxXY`.name)
        if (!(isRootNodes)) {
            val parentNode: SNode? = nodeMap.getNode(parentId)
            val link: SContainmentLink = findContainmentLink(SNodeOperations.getConcept(parentNode), role)
            var index: Int = 0
            for (expectedId: Long in Sequence.fromIterable<Long>(
                IterableUtil.asIterable<Long>(
                    tree.getChildren(
                        parentId,
                        role,
                    ).iterator(),
                ),
            )) {
                val expectedNode: SNode? = nodeMap.getNode(expectedId)
                val actualNode: SNode =
                    ListSequence.fromList(SNodeOperations.getChildren(parentNode, link)).getElement(index)
                if (!(Objects.equals(actualNode, expectedNode))) {
                    SNodeOperations.deleteNode(expectedNode)
                    ListSequence.fromList(SNodeOperations.getChildren(parentNode, link))
                        .insertElement(index, expectedNode)
                }
                index++
            }
        }
        if (includeDescendants) {
            for (childCloudId: Long in MapSequence.fromMap(syncedNodes).keys) {
                syncNodeToMPS(childCloudId, tree, includeDescendants)
            }
        }
    }

    private fun createChildrenSynchronizer(parentId: Long, role: String?): Synchronizer<SNode> {
        return object : Synchronizer<SNode>(parentId, role) {
            override fun associate(
                tree: ITree,
                cloudChildren: List<Long>,
                mpsChildren: List<SNode>,
                direction: SyncDirection?,
            ): Map<Long, SNode> {
                val mpsIdToNode: Map<String, SNode> = MapSequence.fromMap(HashMap())
                ListSequence.fromList<SNode?>(mpsChildren).visitAll(object : IVisitor<SNode>() {
                    override fun visit(it: SNode) {
                        MapSequence.fromMap(mpsIdToNode).put(it.nodeId.toString(), it)
                    }
                })
                val mpsChildrenSet: Set<SNode?> = SetSequence.fromSetWithValues(HashSet(), mpsChildren)
                val cloudChildrenSet: Set<Long> = SetSequence.fromSetWithValues(HashSet(), cloudChildren)
                val mapping: Map<Long, SNode> = MapSequence.fromMap(HashMap())
                for (cloudChild: Long in cloudChildren) {
                    var mpsChild: SNode? = nodeMap.getNode(cloudChild)
                    if (mpsChild == null) {
                        val persistedMpsId: String? = tree.getProperty(cloudChild, MPS_NODE_ID_PROPERTY_NAME)
                        if (persistedMpsId != null) {
                            mpsChild = MapSequence.fromMap(mpsIdToNode).get(persistedMpsId)
                            nodeMap.put(cloudChild, mpsChild)
                        }
                    }
                    if (mpsChild != null && SetSequence.fromSet<SNode?>(mpsChildrenSet).contains(mpsChild)) {
                        MapSequence.fromMap(mapping).put(cloudChild, mpsChild)
                    }
                }
                for (mpsChild: SNode? in ListSequence.fromList<SNode?>(mpsChildren)) {
                    val cloudChild: Long = nodeMap.getId(mpsChild)
                    if ((cloudChild != 0L) && tree.containsNode(cloudChild) && SetSequence.fromSet<Long>(
                            cloudChildrenSet,
                        ).contains(cloudChild)
                    ) {
                        MapSequence.fromMap(mapping).put(cloudChild, mpsChild)
                    }
                }
                return mapping
            }

            override fun createCloudChild(t: IWriteTransaction, mpsChild: SNode): Long {
                val nodeId: Long = getOrCreateCloudNode(mpsChild, parentId, role)
                if (t.getParent(nodeId) != parentId || t.getRole(nodeId) !== role) {
                    t.moveChild(parentId, role, -1, nodeId)
                }
                return nodeId
            }

            override fun createMPSChild(tree: ITree, cloudChildId: Long): SNode {
                val newNode = getOrCreateMPSNode(cloudChildId, tree)
                if (isRootNodes) {
                    model!!.addRootNode(newNode)
                } else {
                    val parentMPSNode: SNode? = nodeMap.getNode(tree.getParent(cloudChildId))
                    ListSequence.fromList(
                        SNodeOperations.getChildren(
                            parentMPSNode,
                            findContainmentLink(SNodeOperations.getConcept(parentMPSNode), role),
                        ),
                    ).addElement(newNode)
                }
                return newNode
            }

            override val mPSChildren: Iterable<SNode>
                get() {
                    if (isRootNodes) {
                        return model!!.rootNodes
                    } else {
                        val parentNode: SNode? = nodeMap.getNode(parentId)
                        if (parentNode == null) {
                            throw IllegalStateException("Node has no parent but it is not a root node")
                        }
                        val children: Iterable<SNode> =
                            parentNode.getChildren(findContainmentLink(parentNode.concept, role))
                        return Sequence.fromIterable(children).ofType(
                            SNode::class.java,
                        )
                    }
                }
            private val isRootNodes: Boolean
                private get() {
                    return parentId == modelNodeId && Objects.equals(role, LINKS.`rootNodes$jxXY`.name)
                }

            override fun removeMPSChild(mpsChild: SNode) {
                SNodeOperations.deleteNode(mpsChild)
            }
        }
    }

    fun findContainmentLink(concept: SAbstractConcept, linkName: String?): SContainmentLink {
        val links: Iterable<SContainmentLink> = concept.containmentLinks
        val link: SContainmentLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SContainmentLink>() {
            override fun accept(it: SContainmentLink): Boolean {
                return Objects.equals(it.name, linkName)
            }
        })
        if (link == null) {
            throw RuntimeException(concept.toString() + "." + linkName + " not found")
        }
        return link
    }

    fun findReferenceLink(concept: SAbstractConcept, linkName: String?): SReferenceLink {
        val links: Iterable<SReferenceLink> = concept.referenceLinks
        val link: SReferenceLink? = Sequence.fromIterable(links).findFirst(object : IWhereFilter<SReferenceLink>() {
            override fun accept(it: SReferenceLink): Boolean {
                return Objects.equals(it.name, linkName)
            }
        })
        if (link == null) {
            throw RuntimeException(concept.toString() + "." + linkName + " not found")
        }
        return link
    }

    fun findProperty(concept: SAbstractConcept?, role: String?): SProperty {
        val properties: Iterable<SProperty> = concept!!.properties
        val property: SProperty? = Sequence.fromIterable(properties).findFirst(object : IWhereFilter<SProperty>() {
            override fun accept(it: SProperty): Boolean {
                return Objects.equals(it.name, role)
            }
        })
        if (property == null) {
            throw RuntimeException(concept.toString() + "." + role + " not found")
        }
        return property
    }

    fun syncNodeFromMPS(parentNode: SNode?, includeDescendants: Boolean) {
        if (parentNode!!.model !== model) {
            throw RuntimeException("Not part of this model: " + parentNode)
        }
        val branch: IBranch = branch
        val t: IWriteTransaction = branch!!.writeTransaction
        val concept: SConcept = parentNode!!.concept
        val parentNodeId: Long = getOrCreateCloudNode(parentNode)
        val cloudNode: INode = PNodeAdapter(parentNodeId, (branch))
        MPSNodeMapping.mapToMpsNode(cloudNode, parentNode)
        for (property: SProperty in CollectionSequence.fromCollection<SProperty>(concept.properties)) {
            val oldValue: String? = t.getProperty(parentNodeId, property.name)
            val newValue: String? = parentNode.getProperty(property)
            if (!(Objects.equals(newValue, oldValue))) {
                t.setProperty(parentNodeId, property.name, newValue)
            }
        }
        for (link: SReferenceLink in CollectionSequence.fromCollection<SReferenceLink>(concept.referenceLinks)) {
            pendingReferences.add(object : _return_P0_E0<SNode> {
                override fun invoke(): SNode? {
                    val targetSNode: SNode? = parentNode.getReferenceTarget(link)
                    val currentTarget: INodeReference? = t.getReferenceTarget(parentNodeId, link.name)
                    if (targetSNode == null) {
                        if (currentTarget != null) {
                            t.setReferenceTarget(parentNodeId, link.name, null)
                        }
                    } else {
                        val targetId: Long = nodeMap.getId(targetSNode)
                        val targetNode: INode?
                        if (targetId == 0L || !(t.containsNode(targetId))) {
                            targetNode = SNodeToNodeAdapter.Companion.wrap(targetSNode)
                        } else {
                            targetNode = PNodeAdapter(targetId, (branch))
                        }
                        if (!(Objects.equals(currentTarget, targetNode!!.reference))) {
                            t.setReferenceTarget(parentNodeId, link.name, targetNode.reference)
                        }
                    }
                    return null
                }
            })
        }
        for (link: SContainmentLink? in CollectionSequence.fromCollection<SContainmentLink>(concept.containmentLinks)) {
            syncChildrenFromMPS(link, t, parentNodeId, parentNode, includeDescendants)
        }
    }

    protected fun syncChildrenFromMPS(
        link: SContainmentLink?,
        t: IWriteTransaction,
        parentNodeId: Long,
        parentNode: SNode?,
        includeDescendants: Boolean,
    ) {
        val syncedNodes: Map<Long, SNode> = createChildrenSynchronizer(parentNodeId, link!!.name).syncToCloud(t)

        // order
        val sortedMappings: Iterable<IMapping<Long, SNode>> =
            MapSequence.fromMap(syncedNodes).sort(
                object : ISelector<IMapping<Long, SNode>, Int>() {
                    override fun select(it: IMapping<Long, SNode>): Int {
                        val mpsNode = it.value()
                        return SNodeOperations.getIndexInParent(mpsNode)
                    }
                },
                true,
            )
        var index: Int = 0
        for (mapping: IMapping<Long, SNode> in sortedMappings) {
            val cloudId: Long = mapping.key()
            val children: Iterable<Long> = t.getChildren(parentNodeId, link.name)
            val actualId: Long = Optional.ofNullable(Sequence.fromIterable(children).skip(1).first()).orElse(0L)
            if (actualId != cloudId) {
                t.moveChild(parentNodeId, link.name, index, cloudId)
            }
            index++
        }
        if (includeDescendants) {
            for (childNode: SNode? in Sequence.fromIterable(MapSequence.fromMap(syncedNodes).values)) {
                syncNodeFromMPS(childNode, includeDescendants)
            }
        }
    }

    protected fun getOrCreateCloudNode(node: SNode?, parentIfCreate: Long, roleIfCreate: String?): Long {
        var nodeId: Long = nodeMap.getId(node)
        val t: IWriteTransaction = branch.writeTransaction
        if (nodeId == 0L || !(t.containsNode(nodeId))) {
            nodeId = t.addNewChild(
                parentIfCreate, roleIfCreate, -1,
                SConceptAdapter.Companion.wrap(
                    node!!.concept,
                ),
            )
            nodeMap.put(nodeId, node)
        }
        return nodeId
    }

    protected fun getOrCreateCloudNode(node: SNode?): Long {
        return getOrCreateCloudNode(node, ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE)
    }

    fun getCloudNodeId(node: SNode?): Long {
        return nodeMap.getId(node)
    }

    fun getOrSyncToCloud(node: SNode, t: IWriteTransaction): Long {
        var cloudId: Long = nodeMap.getId(node)
        if (cloudId == 0L || !(t.containsNode(cloudId))) {
            val parent: SNode? = node.parent
            if (parent == null) {
                syncRootNodesFromMPS()
            } else {
                val parentCloudId: Long = getOrSyncToCloud(parent, t)
                syncNodeFromMPS(parent, true)
            }
            cloudId = nodeMap.getId(node)
        }
        return cloudId
    }

    fun handleMPSNodeAdded(e: SNodeAddEvent) {
        PArea((branch)).executeWrite<Unit>({
            pendingReferences.runAndFlush(object : Runnable {
                override fun run() {
                    val t: IWriteTransaction = branch.writeTransaction
                    val parentId: Long
                    val role: String
                    if (e.isRoot) {
                        parentId = modelNodeId
                        role = LINKS.`rootNodes$jxXY`.name
                    } else {
                        parentId = nodeMap.getId(e.parent)
                        role = e.aggregationLink!!.name
                    }
                    if (parentId == 0L || !(t.containsNode(parentId))) {
                        return
                    }
                    val child: SNode = e.child
                    if (e.isRoot) {
                        var childId: Long = nodeMap.getId(child)
                        if (childId == 0L || !(t.containsNode(childId))) {
                            childId = t.addNewChild(
                                parentId,
                                role,
                                -1,
                                SConceptAdapter.Companion.wrap(SNodeOperations.getConcept(child)),
                            )
                            nodeMap.put(childId, child)
                        } else {
                            t.moveChild(parentId, role, -1, childId)
                        }
                    } else {
                        syncChildrenFromMPS(e.aggregationLink, t, parentId, e.parent, false)
                    }
                    syncNodeFromMPS(child, true)
                }
            })
        })
    }

    fun handleMPSNodeRemoved(e: SNodeRemoveEvent) {
        val branch: IBranch = branch
        PArea((branch)!!).executeWrite({
            val t: IWriteTransaction = branch.writeTransaction
            val childId: Long = nodeMap.getId(e.child)
            if (childId != 0L && t.containsNode(childId)) {
                t.moveChild(ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE, -1, childId)
            }
            Unit
        })
    }

    fun handleReferenceChanged(e: SReferenceChangeEvent) {
        val branch: IBranch = branch
        PArea((branch)!!).executeWrite<Unit>({
            val t: IWriteTransaction = this.branch.writeTransaction
            val targetSNode: SNode? = check_l95w85_a0b0a0a1a96(e.newValue)
            val sourceId: Long = getOrCreateCloudNode(e.node)
            if (targetSNode == null) {
                t.setReferenceTarget(sourceId, e.associationLink.name, null)
            } else {
                val targetId: Long = nodeMap.getId(targetSNode)
                val targetNode: INode?
                if (targetId == 0L || !(t.containsNode(targetId))) {
                    targetNode = SNodeToNodeAdapter.Companion.wrap(targetSNode)
                } else {
                    targetNode = PNodeAdapter(targetId, (branch))
                }
                t.setReferenceTarget(sourceId, e.associationLink.name, targetNode!!.reference)
            }
        })
    }

    inner class PendingReferences {
        protected var currentReferences: List<_return_P0_E0<out SNode>>? = null

        @Synchronized
        fun runAndFlush(runnable: Runnable) {
            if (currentReferences == null) {
                try {
                    currentReferences = ListSequence.fromList(ArrayList())
                    runnable.run()
                } finally {
                    try {
                        processPendingReferences()
                    } catch (ex: Exception) {
                        if (LOG.isEnabledFor(Level.ERROR)) {
                            LOG.error("Failed to process pending reference", ex)
                        }
                    }
                    currentReferences = null
                }
            } else {
                runnable.run()
            }
        }

        @Synchronized
        fun add(ref: _return_P0_E0<out SNode>) {
            if (currentReferences == null) {
                throw IllegalStateException("Call runAndFlush first")
            }
            ListSequence.fromList(currentReferences).addElement(ref)
        }

        protected fun processPendingReferences() {
            val targetModels: Set<SModel?> = SetSequence.fromSet(HashSet())
            currentReferences?.forEach { r ->
                try {
                    val targetNode = r.invoke()
                    SetSequence.fromSet(targetModels).addElement(check_l95w85_a0a1a0a1a6tc(targetNode))
                } catch (ex: Exception) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("", ex)
                    }
                }
            }
            val modelsToImport: Iterable<SModel?> =
                SetSequence.fromSet(targetModels).where(object : IWhereFilter<SModel?>() {
                    override fun accept(it: SModel?): Boolean {
                        return it != null && it !== model
                    }
                })
            if (Sequence.fromIterable(modelsToImport).isNotEmpty) {
                val importer: ModelImporter = ModelImporter((model)!!)
                Sequence.fromIterable<SModel?>(modelsToImport).visitAll(object : IVisitor<SModel>() {
                    override fun visit(it: SModel) {
                        importer.prepare(it.reference)
                    }
                })
                importer.execute()
            }
        }
    }

    private object LINKS {
        /*package*/
        val `rootNodes$jxXY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x69652614fd1c514L,
            "rootNodes",
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(ModelSynchronizer::class.java)
        val USED_DEVKITS: String = "usedDevkits"
        val MPS_NODE_ID_PROPERTY_NAME: String = "#mpsNodeId#"
        private fun check_l95w85_a0g0a0a0a0a14(checkedDotOperand: INodeReference?, resolveContext: IArea): INode? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.resolveIn(resolveContext!!)
            }
            return null
        }

        private fun check_l95w85_a0b0a0a1a96(checkedDotOperand: SReference?): SNode? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.targetNode
            }
            return null
        }

        private fun check_l95w85_a0a1a0a1a6tc(checkedDotOperand: SNode?): SModel? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.model
            }
            return null
        }
    }
}
