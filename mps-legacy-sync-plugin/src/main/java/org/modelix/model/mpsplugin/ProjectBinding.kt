package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.IMapping
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.project.MPSProject
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleReference
import org.modelix.model.api.IBranch
import org.modelix.model.api.IReadTransaction
import org.modelix.model.api.ITree
import org.modelix.model.api.ITreeChangeVisitor
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import java.util.Objects

/*Generated by MPS */
class ProjectBinding(val project: MPSProject, var projectNodeId: Long, initialSyncDirection: SyncDirection?) :
    Binding(initialSyncDirection) {
    @Suppress("removal")
    private val repositoryListener = object : org.jetbrains.mps.openapi.module.SRepositoryListenerBase() {
        public override fun moduleAdded(p1: SModule) {
            enqueueSyncToCloud()
        }

        public override fun moduleRemoved(p1: SModuleReference) {
            enqueueSyncToCloud()
        }

        private fun enqueueSyncToCloud() {
            enqueueSync(SyncDirection.TO_CLOUD, false, null)
        }
    }

    init {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Project binding created: " + this)
        }
    }

    public override fun toString(): String {
        return "Project: " + java.lang.Long.toHexString(projectNodeId) + " -> " + project!!.getName()
    }

    override fun doActivate() {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Activating: " + this)
        }
        val branch: IBranch? = this.branch
        if (projectNodeId == 0L) {
            project!!.getRepository().getModelAccess().runReadAction(object : Runnable {
                public override fun run() {
                    branch!!.runWriteT({ t: IWriteTransaction ->
                        projectNodeId = t.addNewChild(
                            ITree.ROOT_ID, "projects", -1, SConceptAdapter.Companion.wrap(
                                CONCEPTS.`Project$An`
                            )
                        )
                        t.setProperty(projectNodeId, PROPS.`name$MnvL`.getName(), project.getName())
                        Unit
                    })
                    enqueueSync(SyncDirection.TO_CLOUD, true, null)
                }
            })
        } else {
            val cloudProjectIsEmpty: Boolean = branch!!.computeReadT({ t: IReadTransaction ->
                val children: Iterable<Long> = t.getChildren(projectNodeId, LINKS.`modules$Bi3g`.getName())
                Sequence.fromIterable(children).isEmpty()
            })
            if (cloudProjectIsEmpty) {
                enqueueSync(SyncDirection.TO_CLOUD, true, null)
            } else {
                enqueueSync(SyncDirection.TO_MPS, true, null)
            }
        }
        project!!.getRepository().addRepositoryListener(repositoryListener)
        if (LOG.isDebugEnabled()) {
            LOG.debug("Activated: " + this)
        }
    }

    override fun doDeactivate() {
        project!!.getRepository().removeRepositoryListener(repositoryListener)
    }

    override fun getTreeChangeVisitor(oldTree: ITree?, newTree: ITree): ITreeChangeVisitor? {
        assertSyncThread()
        return object : ITreeChangeVisitor {
            public override fun containmentChanged(nodeId: Long) {}
            public override fun childrenChanged(parentId: Long, role: String?) {
                assertSyncThread()
                if (parentId == projectNodeId && Objects.equals(role, LINKS.`modules$Bi3g`.getName())) {
                    enqueueSync(SyncDirection.TO_MPS, false, null)
                }
            }

            public override fun referenceChanged(nodeId: Long, role: String) {}
            public override fun propertyChanged(nodeId: Long, role: String) {}
        }
    }

    public override fun doSyncToMPS(tree: ITree) {
        val mappings = ProjectModulesSynchronizer(projectNodeId, project).syncToMPS(tree)
        updateBindings(mappings, SyncDirection.TO_MPS)
    }

    public override fun doSyncToCloud(t: IWriteTransaction) {
        val mappings = ProjectModulesSynchronizer(projectNodeId, project).syncToCloud(t)
        updateBindings(mappings, SyncDirection.TO_CLOUD)
    }

    private fun updateBindings(mappings: Map<Long, SModule>, syncDirection: SyncDirection) {
        val mappingsWithoutReadonly: Iterable<IMapping<Long, SModule>> =
            MapSequence.fromMap(mappings).where(object : IWhereFilter<IMapping<Long?, SModule>>() {
                public override fun accept(it: IMapping<Long?, SModule>): Boolean {
                    return !(it.value().isPackaged()) && !(it.value().isReadOnly())
                }
            })
        val bindings: Map<Long, ProjectModuleBinding> = MapSequence.fromMap(HashMap())
        Sequence.fromIterable<Binding?>(getOwnedBindings()).ofType<ProjectModuleBinding>(
            ProjectModuleBinding::class.java
        ).visitAll(object : IVisitor<ProjectModuleBinding>() {
            public override fun visit(it: ProjectModuleBinding) {
                MapSequence.fromMap(bindings).put(it.moduleNodeId, it)
            }
        })
        val toAdd: List<Long> = Sequence.fromIterable(mappingsWithoutReadonly)
            .select(object : ISelector<IMapping<Long, SModule>, Long>() {
                public override fun select(it: IMapping<Long, SModule>): Long {
                    return it.key()
                }
            }).subtract(SetSequence.fromSet(MapSequence.fromMap(bindings).keys)).toListSequence()
        val toRemove: List<Long?> = SetSequence.fromSet(MapSequence.fromMap(bindings).keys).subtract(
            Sequence.fromIterable(mappingsWithoutReadonly)
                .select(object : ISelector<IMapping<Long, SModule>, Long?>() {
                    public override fun select(it: IMapping<Long, SModule>): Long? {
                        return it.key()
                    }
                })
        ).toListSequence()
        ListSequence.fromList(toRemove).visitAll(object : IVisitor<Long>() {
            public override fun visit(it: Long) {
                val binding: ProjectModuleBinding? = MapSequence.fromMap(bindings).get(it)
                binding!!.deactivate(null)
                binding.setOwner(null)
            }
        })
        ListSequence.fromList(toAdd).visitAll(object : IVisitor<Long>() {
            public override fun visit(it: Long) {
                val binding: ProjectModuleBinding =
                    ProjectModuleBinding(it, MapSequence.fromMap(mappings).getValue(it), syncDirection)
                binding.setOwner(this@ProjectBinding)
                binding.activate(null)
            }
        })
    }

    private object CONCEPTS {
        /*package*/
        val `Project$An`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            "org.modelix.model.repositoryconcepts.structure.Project"
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name"
        )
    }

    private object LINKS {
        /*package*/
        val `modules$Bi3g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            0x37a0917d689de9e2L,
            "modules"
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(ProjectBinding::class.java)
    }
}
