package org.modelix.model.mpsplugin

import gnu.trove.map.TLongObjectMap
import gnu.trove.map.TObjectLongMap
import gnu.trove.map.hash.TLongObjectHashMap
import gnu.trove.map.hash.TObjectLongHashMap
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration
import org.jetbrains.mps.openapi.language.SAbstractConcept
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SInterfaceConcept
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SNodeId
import org.jetbrains.mps.openapi.persistence.PersistenceFacade
import org.modelix.model.api.IBranch
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.INode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.AbstractArea
import org.modelix.model.area.IAreaReference
import org.modelix.model.area.PArea
import org.modelix.model.mpsadapters.mps.SNodeReferenceAdapter
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter
import java.util.Objects
import java.util.Optional
import java.util.function.Predicate

/*Generated by MPS */
class NodeMap(private val branchProvider: BranchProvider) : AbstractArea(), IAreaReference {
    interface BranchProvider {
        val branch: IBranch?
    }

    /**
     * Map from Cloud ID to Node
     */
    private val id2node: TLongObjectMap<SNode?> = TLongObjectHashMap()

    /**
     * Map from Node to Cloud ID
     */
    private val node2id: TObjectLongMap<SNode?> = TObjectLongHashMap()
    public override fun resolveConcept(reference: IConceptReference): IConcept? {
        return null
    }

    public override fun getReference(): IAreaReference {
        return this
    }

    fun put(id: Long, node: SNode?) {
        id2node.put(id, node)
        node2id.put(node, id)
    }

    fun removeId(id: Long) {
        val node: SNode? = id2node.remove(id)
        if (node != null) {
            node2id.remove(node)
        }
    }

    fun removeNode(node: SNode?) {
        val id: Long = node2id.remove(node)
        id2node.remove(id)
    }

    fun getNode(id: Long): SNode? {
        return id2node.get(id)
    }

    fun getId(node: SNode?): Long {
        return node2id.get(node)
    }

    fun hasMappingForCloudNode(cloudID: Long): Boolean {
        return id2node.containsKey(cloudID)
    }

    fun getOrCreateNode(id: Long, conceptProducer: _return_P0_E0<out SAbstractConcept>): SNode {
        var node: SNode? = getNode(id)
        if (node == null) {
            try {
                // The id parameters is the ID of the node in the replicated data structure.
                // We could use any ID for the MPS node, but for the load balancing to work properly,
                // node references should be resolvable independent of the MPS instance.
                val nodeId: SNodeId?

                // We need to get the associated MPS Node ID, stored in the INode
                val iNode: INode = PNodeAdapter(id, (branchProvider.branch)!!)
                // We should probably store these values somewhere, to avoid transactions
                val mpsNodeIdAsString: String? =
                    (if (branchProvider.branch!!.canRead()) MPSNodeMapping.mappedMpsNodeID(iNode) else PArea(
                        (branchProvider.branch)!!
                    ).executeRead({ MPSNodeMapping.mappedMpsNodeID(iNode) }))
                if (mpsNodeIdAsString == null) {
                    // Here, given we have no explicit NodeId in the INode, we use the id of the INode
                    // We may want to create a special SNodeId in this case?
                    nodeId = jetbrains.mps.smodel.SNodeId.Regular(id)
                } else {
                    nodeId = PersistenceFacade.getInstance().createNodeId(mpsNodeIdAsString)
                }
                val rawConcept: Any = conceptProducer.invoke()
                val c: SConcept
                if (rawConcept is SInterfaceConcept) {
                    c = MetaAdapterByDeclaration.asInstanceConcept((rawConcept as SAbstractConcept?))
                } else if (rawConcept is SConcept) {
                    c = rawConcept
                } else {
                    throw RuntimeException("Concept producer returned something unexpected: " + rawConcept)
                }
                node = jetbrains.mps.smodel.SNode(c, (nodeId)!!)
                put(id, node)
            } catch (e: RuntimeException) {
                throw RuntimeException(
                    "Issue while trying to create node with id " + id + " and concept " + conceptProducer,
                    e
                )
            }
        }
        return node
    }

    public override fun resolveOriginalNode(reference: INodeReference): INode? {
        if (reference is SNodeReferenceAdapter) {
            val targetNodeId: SNodeId? = reference.getReference()!!.getNodeId()
            val sNode = node2id.keySet().firstOrNull { it?.nodeId == targetNodeId }
            if (sNode != null) {
                return SNodeToNodeAdapter.Companion.wrap(sNode)
            } else {
                return null
            }
        }
        return null
    }

    public override fun getRoot(): INode {
        throw UnsupportedOperationException()
    }
}
