package org.modelix.model.mpsplugin

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._void_P0_E0
import jetbrains.mps.internal.collections.runtime.IMapping
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ITranslator2
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.LinkedListSequence
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.smodel.MPSModuleRepository
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.modelix.model.api.IBranch
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.area.PArea
import java.util.Collections
import java.util.LinkedList
import java.util.Objects
import java.util.concurrent.ExecutionException
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException
import java.util.concurrent.atomic.AtomicBoolean
import java.util.function.Consumer
import java.util.function.Function

/*Generated by MPS */
class SyncQueue(private val owner: RootBinding) {
    private val syncQueue: Map<Binding?, SyncTask> = MapSequence.fromMap(LinkedHashMap(16, 0.75.toFloat(), false))

    @Volatile
    var isSynchronizing: Boolean = false
        private set
    private val syncLock: Any = Any()
    private val activeLocks: List<ELockType?> = ListSequence.fromList(ArrayList())
    private val flushExecutor: FlushExecutor = FlushExecutor()
    private var syncThread: Thread? = null
    var lastTreeAfterSync: ITree? = null
        private set

    fun getTask(binding: Binding?): SyncTask? {
        return MapSequence.fromMap(syncQueue).get(binding)
    }

    fun assertSyncThread() {
        if (Thread.currentThread() !== syncThread) {
            throw RuntimeException("Call only allowed from sync thread (" + syncThread + "), but current thread is " + Thread.currentThread())
        }
    }

    fun dispose() {}
    fun enqueue(task: SyncTask): Boolean {
        if (task.binding.rootBinding !== owner) {
            throw IllegalArgumentException(task.binding.toString() + " is not attached to " + this)
        }
        synchronized(syncQueue, {
            val existingTask: SyncTask? = MapSequence.fromMap(syncQueue).get(task.binding)
            if (existingTask != null) {
                if (existingTask.direction == task.direction && existingTask.isInitialSync == task.isInitialSync) {
                    return false
                }
                throw RuntimeException("Cannot add " + task + ". Queue has pending " + existingTask)
            }
            MapSequence.fromMap(syncQueue).put(task.binding, task)
        })
        flushExecutor.submitFlush()
        return true
    }

    fun flush() {
        flushExecutor.flush()
    }

    private fun loadFromQueue(locks2tasks: MutableMap<Set<ELockType>, List<SyncTask>>) {
        var queueElements: List<SyncTask>?
        synchronized(syncQueue, {
            queueElements = ListSequence.fromListWithValues(ArrayList(), MapSequence.fromMap(syncQueue).values)
            MapSequence.fromMap(syncQueue).clear()
        })
        for (task: SyncTask in ListSequence.fromList(queueElements)) {
            ListSequence.fromList(
                locks2tasks.computeIfAbsent(
                    task.requiredLocks,
                    object : Function<Set<ELockType?>?, List<SyncTask>> {
                        public override fun apply(k: Set<ELockType?>?): List<SyncTask> {
                            return LinkedListSequence.fromLinkedListNew(LinkedList())
                        }
                    })
            ).addElement(task)
        }
        locks2tasks.values.forEach(object : Consumer<List<SyncTask>?> {
            public override fun accept(it: List<SyncTask>?) {
                Collections.sort(it, object : Comparator<SyncTask> {
                    public override fun compare(t1: SyncTask, t2: SyncTask): Int {
                        return t1.binding.depth - t2.binding.depth
                    }
                })
            }
        })
    }

    private fun doFlush() {
        val processedTasks: List<SyncTask> = ListSequence.fromList(ArrayList())
        synchronized(syncLock, {
            assert(!(isSynchronizing))
            try {
                isSynchronizing = true
                syncThread = Thread.currentThread()
                val locks2task: MutableMap<Set<ELockType>, List<SyncTask>> = LinkedHashMap()
                loadFromQueue(locks2task)
                while (Sequence.fromIterable<List<SyncTask>>(
                        MapSequence.fromMap<Set<ELockType>, List<SyncTask>>(
                            locks2task
                        ).values
                    ).translate<SyncTask>(object : ITranslator2<List<SyncTask>, SyncTask>() {
                        public override fun translate(it: List<SyncTask>): Iterable<SyncTask> {
                            return it
                        }
                    }).isNotEmpty()
                ) {
                    for (entry: IMapping<Set<ELockType>, List<SyncTask>> in MapSequence.fromMap<Set<ELockType>, List<SyncTask>>(
                        locks2task
                    ).where(object : IWhereFilter<IMapping<Set<ELockType>, List<SyncTask>>>() {
                        public override fun accept(it: IMapping<Set<ELockType>, List<SyncTask>>): Boolean {
                            return ListSequence.fromList(it.value()).isNotEmpty()
                        }
                    })) {
                        runWithLocks(
                            SetSequence.fromSet<ELockType?>(entry.key()).sort(object : ISelector<ELockType, Int>() {
                                public override fun select(it: ELockType): Int {
                                    return it.ordinal
                                }
                            }, true).toListSequence(), object : _void_P0_E0 {
                                public override fun invoke() {
                                    val tasks: List<SyncTask> = entry.value()
                                    while (ListSequence.fromList<SyncTask>(tasks).isNotEmpty()) {
                                        while (ListSequence.fromList<SyncTask>(tasks).isNotEmpty()) {
                                            val task: SyncTask = ListSequence.fromList(tasks).removeElementAt(0)
                                            if (!(Objects.equals(
                                                    SetSequence.fromSetWithValues(HashSet(), activeLocks),
                                                    task.requiredLocks
                                                ))
                                            ) {
                                                throw IllegalStateException(task.toString() + " requires locks " + task.requiredLocks + ", but active locks are " + activeLocks)
                                            }
                                            ListSequence.fromList(processedTasks).addElement(task)
                                            try {
                                                task.run()
                                            } catch (ex: Exception) {
                                                if (LOG.isEnabledFor(Level.ERROR)) {
                                                    LOG.error("Failed: " + task, ex)
                                                }
                                            }
                                        }
                                        loadFromQueue(locks2task)
                                    }
                                }
                            })
                    }
                }
            } finally {
                isSynchronizing = false
                syncThread = null
            }
        })
        for (task: SyncTask in ListSequence.fromList(processedTasks)) {
            try {
                task.invokeCallbacks()
            } catch (ex: Exception) {
                if (LOG.isEnabledFor(Level.ERROR)) {
                    LOG.error("Exception in binding callback", ex)
                }
            }
        }
    }

    private fun runWithLocks(locks: Iterable<ELockType?>, body: _void_P0_E0) {
        if (Sequence.fromIterable(locks).isEmpty()) {
            body.invoke()
        } else {
            runWithLock(Sequence.fromIterable(locks).first(), object : Runnable {
                public override fun run() {
                    runWithLocks(Sequence.fromIterable(locks).skip(1), body)
                }
            })
        }
    }

    private fun runWithLock(type: ELockType?, body: Runnable) {
        assertSyncThread()
        if (ListSequence.fromList(activeLocks).contains(type)) {
            throw IllegalStateException("Lock " + type + " is already active")
        }
        try {
            ListSequence.fromList(activeLocks).addElement(type)
            when (type) {
                ELockType.MPS_COMMAND -> CommandHelper.runInUndoTransparentCommand(object : Runnable {
                    public override fun run() {
                        val previousSyncThread: Thread? = syncThread
                        try {
                            syncThread = Thread.currentThread()
                            body.run()
                        } finally {
                            syncThread = previousSyncThread
                        }
                    }
                })

                ELockType.MPS_READ -> MPSModuleRepository.getInstance().getModelAccess()
                    .runReadAction(object : Runnable {
                        public override fun run() {
                            body.run()
                        }
                    })

                ELockType.CLOUD_WRITE -> {
                    val branch: IBranch? = owner.branch
                    PArea((branch)!!).executeWrite({
                        body.run()
                        val t: IWriteTransaction = branch.writeTransaction
                        val detachedNodes: Iterable<Long> = t.getChildren(ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE)
                        Sequence.fromIterable(detachedNodes).toListSequence().visitAll(object : IVisitor<Long?>() {
                            public override fun visit(it: Long?) {
                                t.deleteNode((it)!!)
                            }
                        })
                        lastTreeAfterSync = t.tree
                        Unit
                    })
                }

                ELockType.CLOUD_READ -> PArea(owner.branch!!).executeRead({
                    body.run()
                    lastTreeAfterSync = owner.branch!!.transaction.tree
                    Unit
                })

                else -> throw RuntimeException("Unknown lock type: " + type)
            }
        } finally {
            ListSequence.fromList(activeLocks).removeLastElement()
        }
    }

    inner class FlushExecutor() {
        private val asyncFlushLock: Any = Any()
        private var currentAsyncFlush: Future<*>? = null
        private val flushRequested: AtomicBoolean = AtomicBoolean(false)

        @Synchronized
        fun submitFlush(): Future<*>? {
            synchronized(asyncFlushLock, {
                flushRequested.set(true)
                if (currentAsyncFlush != null) {
                    if (currentAsyncFlush!!.isCancelled() || currentAsyncFlush!!.isDone()) {
                        currentAsyncFlush = null
                    }
                }
                if (currentAsyncFlush == null) {
                    currentAsyncFlush = SharedExecutors.FIXED.submit(object : Runnable {
                        public override fun run() {
                            while (flushRequested.getAndSet(false)) {
                                doFlush()
                            }
                        }
                    })
                }
                return currentAsyncFlush
            })
        }

        fun flush() {
            try {
                check_kjxrbf_a0a0a6ib(submitFlush(), this)
            } catch (e: InterruptedException) {
            } catch (e: TimeoutException) {
            } catch (e: ExecutionException) {
            }
        }
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(SyncQueue::class.java)
        @Throws(InterruptedException::class, ExecutionException::class, TimeoutException::class)
        private fun check_kjxrbf_a0a0a6ib(
            checkedDotOperand: Future<*>?,
            checkedDotThisExpression: FlushExecutor
        ): Any? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.get(3, TimeUnit.MINUTES)
            }
            return null
        }
    }
}
