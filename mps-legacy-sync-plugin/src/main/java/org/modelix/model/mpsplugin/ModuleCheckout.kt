package org.modelix.model.mpsplugin

import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.application.ModalityState
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.Solution
import org.modelix.model.api.PNodeAdapter
import javax.swing.SwingUtilities

/*Generated by MPS */
class ModuleCheckout(mpsProject: Project?, private val treeInRepository: CloudRepository?) {
    private val mpsProject: MPSProject?

    init {
        this.mpsProject = mpsProject as MPSProject?
    }

    fun checkoutCloudModule(cloudModule: PNodeAdapter): Solution {
        val modelCloudExporter: ModelCloudExporter = ModelCloudExporter(treeInRepository)
        modelCloudExporter.setCheckoutMode()
        val exportPath: String = mpsProject!!.getProjectFile().getAbsolutePath()
        val moduleIds: Set<Long> = SetSequence.fromSetAndArray(HashSet(), cloudModule.nodeId)
        val solutions: _T<List<Solution>> = _T()
        val r: Runnable = object : Runnable {
            public override fun run() {
                mpsProject.getRepository().getModelAccess().executeCommand(object : Runnable {
                    public override fun run() {
                        solutions.value = modelCloudExporter.export(exportPath, moduleIds, mpsProject)
                    }
                })
            }
        }
        if (SwingUtilities.isEventDispatchThread()) {
            r.run()
        } else {
            ApplicationManager.getApplication().invokeAndWait(r, ModalityState.NON_MODAL)
        }
        if (ListSequence.fromList(solutions.value).count() != 1) {
            throw RuntimeException("One solution expected. These found: " + solutions.value)
        }
        return ListSequence.fromList(solutions.value).getElement(0)
    }
}
