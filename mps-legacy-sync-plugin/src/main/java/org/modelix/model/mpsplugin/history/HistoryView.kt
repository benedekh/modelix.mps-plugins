package org.modelix.model.mpsplugin.history

import com.intellij.openapi.application.ApplicationManager
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.ide.ThreadUtils
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IterableUtils
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import org.modelix.model.LinearHistory
import org.modelix.model.api.IBranch
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.client.ActiveBranch
import org.modelix.model.lazy.CLVersion
import org.modelix.model.lazy.IDeserializingKeyValueStore
import org.modelix.model.lazy.KVEntryReference
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.operations.IOperation
import org.modelix.model.operations.RevertToOp
import org.modelix.model.operations.applyOperation
import java.awt.BorderLayout
import java.awt.FlowLayout
import java.awt.event.ActionEvent
import java.awt.event.ActionListener
import java.util.UUID
import java.util.Vector
import javax.swing.BorderFactory
import javax.swing.JButton
import javax.swing.JPanel
import javax.swing.JScrollPane
import javax.swing.JTable
import javax.swing.table.DefaultTableModel

/*Generated by MPS */
class HistoryView() : JPanel() {
    private val tableModel: DefaultTableModel
    private val table: JTable
    private var versionGetter: _return_P0_E0<out CLVersion?>? = null
    private val versions: List<CLVersion> = ListSequence.fromList(ArrayList())
    private var modelServer: ModelServerConnection? = null
    private var repositoryId: RepositoryId? = null
    private var previousBranchName: String? = null
    private val resetButton: JButton
    private val revertButton: JButton

    init {
        setLayout(BorderLayout())
        tableModel = DefaultTableModel()
        tableModel.addColumn("ID")
        tableModel.addColumn("Author")
        tableModel.addColumn("Time")
        tableModel.addColumn("Operations")
        tableModel.addColumn("Hash")
        table = JTable(tableModel)
        val scrollPane: JScrollPane = JScrollPane(table)
        scrollPane.setBorder(BorderFactory.createEmptyBorder())
        add(scrollPane, BorderLayout.CENTER)
        val buttonPanel: JPanel = JPanel(FlowLayout())
        val loadButton: JButton = JButton("Load Selected Version")
        loadButton.addActionListener(object : ActionListener {
            public override fun actionPerformed(e: ActionEvent) {
                loadSelectedVersion()
            }
        })
        buttonPanel.add(loadButton)
        resetButton = JButton("Reset to ...")
        resetButton.setEnabled(false)
        resetButton.addActionListener(object : ActionListener {
            public override fun actionPerformed(e: ActionEvent) {
                restoreBranch()
            }
        })
        buttonPanel.add(resetButton)
        revertButton = JButton("Revert to Selected Version")
        revertButton.addActionListener(object : ActionListener {
            public override fun actionPerformed(e: ActionEvent) {
                revertToSelectedVersion()
            }
        })
        buttonPanel.add(revertButton)
        add(buttonPanel, BorderLayout.SOUTH)
    }

    fun loadSelectedVersion() {
        val index: Int = table.getSelectedRow()
        if (0 <= index && index < ListSequence.fromList(versions).count()) {
            val version: CLVersion = ListSequence.fromList(versions).getElement(index)
            val branch: ActiveBranch? = modelServer!!.getActiveBranch(repositoryId)
            val branchName: String = "history" + UUID.randomUUID()
            val branchKey: String = repositoryId!!.getBranchKey(branchName)
            modelServer!!.getClient().put(branchKey, version.hash)
            branch!!.switchBranch(branchName)
            resetButton.setEnabled(true)
        }
    }

    fun revertToSelectedVersion() {
        val index: Int = table.getSelectedRow()
        if (0 <= index && index < ListSequence.fromList(versions).count()) {
            val activeBranch: ActiveBranch? = modelServer!!.getActiveBranch(repositoryId)
            val versionToRevertTo: CLVersion = ListSequence.fromList(versions).getElement(index)
            val latestKnownVersion: CLVersion = activeBranch!!.version
            val branch: IBranch = activeBranch.branch
            branch.runWriteT({ t: IWriteTransaction ->
                t.applyOperation(
                    RevertToOp(
                        KVEntryReference(latestKnownVersion.data!!),
                        KVEntryReference(versionToRevertTo.data!!)
                    )
                )
                Unit
            })
            ApplicationManager.getApplication().invokeLater(object : Runnable {
                public override fun run() {
                    refreshHistory()
                }
            })
        }
    }

    fun restoreBranch() {
        modelServer!!.getActiveBranch(repositoryId).switchBranch((previousBranchName)!!)
        resetButton.setEnabled(false)
    }

    fun refreshHistory() {
        loadHistory(modelServer, repositoryId, versionGetter)
    }

    fun loadHistory(
        modelServer: ModelServerConnection?,
        repositoryId: RepositoryId?,
        headVersion: _return_P0_E0<out CLVersion?>?
    ) {
        versionGetter = headVersion
        this.modelServer = modelServer
        this.repositoryId = repositoryId
        previousBranchName = modelServer!!.getActiveBranch(repositoryId).branchName
        resetButton.setText("Reset to " + previousBranchName)
        ThreadUtils.runInUIThreadAndWait(object : Runnable {
            public override fun run() {
                while (tableModel.getRowCount() > 0) {
                    tableModel.removeRow(0)
                }
                ListSequence.fromList(versions).clear()
            }
        })
        ApplicationManager.getApplication().executeOnPooledThread(object : Runnable {
            public override fun run() {
                var version: CLVersion? = headVersion!!.invoke()
                while (version != null) {
                    createTableRow(version)
                    if (version.isMerge()) {
                        val store: IDeserializingKeyValueStore = version.store
                        for (v: CLVersion in ListSequence.fromList(
                            LinearHistory(version.baseVersion!!.hash).load(
                                CLVersion(
                                    version.data!!.mergedVersion1!!.getValue(store), store
                                ), CLVersion(version.data!!.mergedVersion2!!.getValue(store), store)
                            )
                        )) {
                            createTableRow(v)
                        }
                    }
                    if (ListSequence.fromList(versions).count() >= 500) {
                        break
                    }
                    version = version.baseVersion
                }
            }
        })
    }

    private fun createTableRow(version: CLVersion) {
        ThreadUtils.runInUIThreadAndWait(object : Runnable {
            public override fun run() {
                val opsDescription: String
                if (version.isMerge()) {
                    opsDescription =
                        "merge " + version.getMergedVersion1()!!.id + " + " + version.getMergedVersion2()!!.id + " (base " + version.baseVersion + ")"
                } else {
                    opsDescription =
                        "(" + version.numberOfOperations + ") " + ((if (version.operationsInlined()) IterableUtils.join(
                            Sequence.fromIterable((version.operations as Iterable<IOperation>?))
                                .select(object : ISelector<IOperation, String>() {
                                    public override fun select(it: IOperation): String {
                                        return it.toString()
                                    }
                                }), " # "
                        ) else "..."))
                }
                tableModel.addRow(
                    Vector(
                        ListSequence.fromListAndArray(
                            ArrayList<Any?>(),
                            java.lang.Long.toHexString(version.id),
                            version.author,
                            version.time,
                            opsDescription,
                            version.hash
                        )
                    )
                )
                ListSequence.fromList(versions).addElement(version)
            }
        })
    }
}
