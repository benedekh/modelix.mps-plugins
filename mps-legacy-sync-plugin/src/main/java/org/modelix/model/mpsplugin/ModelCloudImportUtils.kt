package org.modelix.model.mpsplugin

import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.ide.project.ProjectHelper
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.progress.EmptyProgressMonitor
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.Solution
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.model.SReference
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.util.ProgressMonitor
import org.modelix.model.api.INode
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SModelAsNode
import org.modelix.model.mpsadapters.mps.SModuleAsNode
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter
import org.modelix.model.mpsplugin.history.CloudNodeTreeNode
import org.modelix.model.mpsplugin.history.CloudNodeTreeNodeBinding
import org.modelix.model.mpsplugin.plugin.PersistedBindingConfiguration
import java.util.function.Consumer
import javax.swing.tree.TreeNode
import kotlin.jvm.functions.Function0.invoke
import kotlin.jvm.functions.Function1.invoke

/*Generated by MPS */ /**
 * This class is responsible for importing local MPS modules into the Modelix server
 */
object ModelCloudImportUtils {
    fun checkoutAndSync(treeNode: TreeNode?, mpsProject: Project?) {
        val nodeTreeNode: CloudNodeTreeNode? = treeNode as CloudNodeTreeNode?
        val treeInRepository: CloudRepository? = CloudNodeTreeNodeBinding.getTreeInRepository(nodeTreeNode)
        val cloudModuleNode: PNodeAdapter? = (nodeTreeNode.getNode() as PNodeAdapter?)
        val solution: Solution? = ModuleCheckout(mpsProject, treeInRepository).checkoutCloudModule(cloudModuleNode)
        mpsProject!!.getRepository().getModelAccess().runReadAction(object : Runnable {
            public override fun run() {
                syncInModelixAsIndependentModule(
                    treeInRepository,
                    solution,
                    ProjectHelper.toIdeaProject(mpsProject),
                    cloudModuleNode
                )
            }
        })
        PersistedBindingConfiguration.Companion.getInstance(ProjectHelper.toIdeaProject(mpsProject))!!
            .addMappedBoundModule(treeInRepository, cloudModuleNode)
    }

    fun checkoutAndSync(treeInRepository: CloudRepository, mpsProject: Project, cloudModuleNodeId: Long) {
        val cloudModuleNode: PNodeAdapter = PNodeAdapter(cloudModuleNodeId, treeInRepository.getActiveBranch().branch)
        val solution: Solution? = ModuleCheckout(mpsProject, treeInRepository).checkoutCloudModule(cloudModuleNode)
        mpsProject.getRepository().getModelAccess().runReadAction(object : Runnable {
            public override fun run() {
                syncInModelixAsIndependentModule(
                    treeInRepository,
                    solution,
                    ProjectHelper.toIdeaProject(mpsProject),
                    cloudModuleNode
                )
            }
        })
        PersistedBindingConfiguration.Companion.getInstance(ProjectHelper.toIdeaProject(mpsProject))!!
            .addMappedBoundModule(treeInRepository, cloudModuleNode)
    }

    fun bindCloudProjectToMpsProject(
        repositoryInModelServer: CloudRepository,
        cloudProjectId: Long,
        mpsProject: MPSProject?,
        initialSyncDirection: SyncDirection?
    ) {
        repositoryInModelServer.addBinding(ProjectBinding(mpsProject, cloudProjectId, initialSyncDirection))
    }

    fun addTransientModuleBinding(
        mpsProject: com.intellij.openapi.project.Project?,
        repositoryInModelServer: CloudRepository,
        cloudNodeId: Long
    ): TransientModuleBinding {
        val modelServerConnection: ModelServerConnection? = repositoryInModelServer.getModelServer()
        val repositoryId: RepositoryId? = repositoryInModelServer.getRepositoryId()
        val transientModuleBinding: TransientModuleBinding = TransientModuleBinding(cloudNodeId)
        modelServerConnection!!.addBinding(repositoryId, transientModuleBinding)
        PersistedBindingConfiguration.Companion.getInstance(mpsProject)!!.addTransientBoundModule(
            repositoryInModelServer,
            repositoryInModelServer.getActiveBranch().branch,
            cloudNodeId
        )
        return transientModuleBinding
    }

    fun containsModule(treeInRepository: CloudRepository, module: SModule?): Boolean {
        return treeInRepository.hasModuleInRepository(module!!.getModuleId().toString())
    }

    /**
     * We create an exact copy of a physical module into Modelix, as a root level module
     * (i.e., a module right below a Tree)
     */
    fun copyInModelixAsIndependentModule(
        treeInRepository: CloudRepository,
        module: SModule?,
        project: com.intellij.openapi.project.Project?,
        progress: ProgressMonitor?
    ): INode? {
        // First create the module
        val cloudModuleNode: INode? = treeInRepository.createModule(module!!.getModuleName())
        replicatePhysicalModule(treeInRepository, cloudModuleNode, module, null, progress)
        return cloudModuleNode
    }

    fun copyAndSyncInModelixAsIndependentModule(
        treeInRepository: CloudRepository,
        module: SModule?,
        mpsProject: com.intellij.openapi.project.Project?,
        progress: ProgressMonitor?
    ) {

        // 1. Copy the module in the cloud repo
        val cloudModuleNode: INode? = copyInModelixAsIndependentModule(treeInRepository, module, mpsProject, progress)
        syncInModelixAsIndependentModule(treeInRepository, module, mpsProject, cloudModuleNode)
    }

    fun copyAndSyncInModelixAsEntireProject(
        treeInRepository: CloudRepository,
        mpsProject: MPSProject?,
        cloudProject: SNode?
    ): ProjectBinding? {
        val binding: ProjectBinding?
        if (cloudProject == null) {
            binding = treeInRepository.addProjectBinding(0L, mpsProject, SyncDirection.TO_CLOUD)
            PersistedBindingConfiguration.Companion.getInstance(ProjectHelper.toIdeaProject(mpsProject))!!
                .addTransientBoundProject(treeInRepository, cloudProject)
        } else {
            val cloudProjectAsNodeToSNodeAdapter: NodeToSNodeAdapter = cloudProject as NodeToSNodeAdapter
            val cloudProjectAsINode: INode? = cloudProjectAsNodeToSNodeAdapter.getWrapped()
            val nodeId: Long = INodeUtils.nodeIdAsLong(cloudProjectAsINode)
            binding = treeInRepository.addProjectBinding(nodeId, mpsProject, SyncDirection.TO_MPS)
            PersistedBindingConfiguration.Companion.getInstance(ProjectHelper.toIdeaProject(mpsProject))!!
                .addTransientBoundProject(treeInRepository, cloudProject)
        }
        return binding
    }

    fun syncInModelixAsIndependentModule(
        treeInRepository: CloudRepository?,
        module: SModule?,
        mpsProject: com.intellij.openapi.project.Project?,
        cloudModuleNode: INode?
    ) {
        val msc: ModelServerConnection? = treeInRepository.getModelServer()
        msc!!.addBinding(
            treeInRepository.getRepositoryId(),
            ProjectModuleBinding((cloudModuleNode as PNodeAdapter?)!!.nodeId, module, SyncDirection.TO_MPS)
        )
        PersistedBindingConfiguration.Companion.getInstance(mpsProject)!!
            .addMappedBoundModule(treeInRepository, cloudModuleNode)
    }

    /**
     * Take an INode already created and make sure it is exactly the same as the physical module given.
     * The modelMappingConsumer may be used to attach a model synchronizer, for example. It is optional.
     */
    fun replicatePhysicalModule(
        treeInRepository: CloudRepository,
        cloudModule: INode?,
        physicalModule: SModule?,
        modelMappingConsumer: Consumer<PhysicalToCloudModelMapping?>?,
        progress: ProgressMonitor?
    ) {
        val _progress: _T<ProgressMonitor?> = _T(progress)
        if (_progress.value == null) {
            _progress.value = EmptyProgressMonitor()
        }
        val sModuleAsNode: SModuleAsNode? = SModuleAsNode.Companion.wrap(physicalModule)
        treeInRepository.runWrite(object : Consumer<PNodeAdapter?> {
            public override fun accept(rootNode: PNodeAdapter?) {
                INodeUtils.copyProperty(cloudModule, sModuleAsNode, PROPS.`name$MnvL`.getName())
                INodeUtils.copyProperty(cloudModule, sModuleAsNode, PROPS.`id$7MjP`.getName())
                INodeUtils.copyProperty(cloudModule, sModuleAsNode, PROPS.`moduleVersion$sDQK`.getName())
                INodeUtils.copyProperty(cloudModule, sModuleAsNode, PROPS.`compileInMPS$sEzN`.getName())
                INodeUtils.cloneChildren(cloudModule, sModuleAsNode, LINKS.`facets$vw9T`.getName())
                INodeUtils.cloneChildren(cloudModule, sModuleAsNode, LINKS.`dependencies$vC8r`.getName())
                INodeUtils.cloneChildren(cloudModule, sModuleAsNode, LINKS.`languageDependencies$vKlY`.getName())
            }
        })
        val models: _T<List<SModel?>?> = _T(null)
        physicalModule!!.getRepository()!!.getModelAccess().runReadAction(object : Runnable {
            public override fun run() {
                models.value = ListSequence.fromListWithValues(
                    ArrayList(),
                    SModuleUtils.getModelsWithoutDescriptor(physicalModule)
                )
            }
        })
        _progress.value!!.start("Module " + physicalModule.getModuleName(), ListSequence.fromList(models.value).count())
        for (model: SModel? in ListSequence.fromList<SModel?>(models.value)) {
            if (_progress.value!!.isCanceled()) {
                break
            }
            physicalModule.getRepository()!!.getModelAccess().runReadAction(object : Runnable {
                public override fun run() {
                    val modelProgress: ProgressMonitor = _progress.value!!.subTask(1)
                    modelProgress.start("Model " + model!!.getName(), 1)
                    val cloudModel: INode? = copyPhysicalModel(treeInRepository, cloudModule, model)
                    if (modelMappingConsumer != null) {
                        modelMappingConsumer.accept(PhysicalToCloudModelMapping(model, cloudModel))
                    }
                    modelProgress.done()
                }
            })
        }
        _progress.value!!.done()
    }

    /**
     * This creates a copy of the given physicalModel under the given cloudModule. It then ensures that it is exactly the same as the given physicalModule.
     *
     * @return the created cloud model
     */
    fun copyPhysicalModel(treeInRepository: CloudRepository, cloudModule: INode?, physicalModel: SModel?): INode? {
        val originalModel: INode? = SModelAsNode.Companion.wrap(physicalModel)
        val cloudModel: INode? = treeInRepository.createNode(
            cloudModule,
            LINKS.`models$h3QT`,
            CONCEPTS.`Model$2P`,
            object : Consumer<INode> {
                public override fun accept(cloudModel: INode) {
                    INodeUtils.copyProperty(cloudModel, originalModel, PROPS.`name$MnvL`.getName())
                    INodeUtils.copyProperty(cloudModel, originalModel, PROPS.`id$lDUo`.getName())
                    INodeUtils.cloneChildren(cloudModel, originalModel, LINKS.`modelImports$8DOI`.getName())
                    INodeUtils.cloneChildren(cloudModel, originalModel, LINKS.`usedLanguages$QK4E`.getName())
                    for (physicalRoot: SNode in Sequence.fromIterable<SNode>(
                        physicalModel!!.getRootNodes()
                    )) {
                        val cloudRoot: INode = cloudModel.addNewChild(
                            LINKS.`rootNodes$jxXY`.getName(),
                            -1,
                            SConceptAdapter.Companion.wrap(physicalRoot.getConcept())
                        )
                        replicatePhysicalNode(cloudRoot, physicalRoot)
                    }
                }
            })
        return cloudModel
    }

    /**
     * This takes a cloud node already created and a physical node.
     * It then ensures that the cloud node is exactly as the original physical node.
     *
     * It operates recursively on children.
     */
    private fun replicatePhysicalNode(cloudNode: INode, physicalNode: SNode) {
        MPSNodeMapping.mapToMpsNode(cloudNode, physicalNode)
        for (prop: SProperty in Sequence.fromIterable(physicalNode.getProperties())) {
            cloudNode.setPropertyValue(prop.getName(), physicalNode.getProperty(prop))
        }
        for (ref: SReference in Sequence.fromIterable(physicalNode.getReferences())) {
            cloudNode.setReferenceTarget(ref.getRole(), SNodeToNodeAdapter.Companion.wrap(ref.getTargetNode()))
        }
        for (physicalChild: SNode in Sequence.fromIterable(physicalNode.getChildren())) {
            val cloudChild: INode = cloudNode.addNewChild(
                physicalChild.getContainmentLink()!!.getName(),
                -1,
                SConceptAdapter.Companion.wrap(physicalChild.getConcept())
            )
            replicatePhysicalNode(cloudChild, physicalChild)
        }
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name"
        )

        /*package*/
        val `id$7MjP`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x3aa34013f2a802e0L,
            "id"
        )

        /*package*/
        val `moduleVersion$sDQK`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299142L,
            "moduleVersion"
        )

        /*package*/
        val `compileInMPS$sEzN`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299145L,
            "compileInMPS"
        )

        /*package*/
        val `id$lDUo`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x244b85440ee67212L,
            "id"
        )
    }

    private object LINKS {
        /*package*/
        val `facets$vw9T`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde953529916cL,
            "facets"
        )

        /*package*/
        val `dependencies$vC8r`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299179L,
            "dependencies"
        )

        /*package*/
        val `languageDependencies$vKlY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x1e9fde9535299187L,
            "languageDependencies"
        )

        /*package*/
        val `models$h3QT`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x69652614fd1c512L,
            "models"
        )

        /*package*/
        val `modelImports$8DOI`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x58dbe6e4d4f32eb8L,
            "modelImports"
        )

        /*package*/
        val `usedLanguages$QK4E`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x4aaf28cf2092e98eL,
            "usedLanguages"
        )

        /*package*/
        val `rootNodes$jxXY`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x69652614fd1c514L,
            "rootNodes"
        )
    }

    private object CONCEPTS {
        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model"
        )
    }
}
