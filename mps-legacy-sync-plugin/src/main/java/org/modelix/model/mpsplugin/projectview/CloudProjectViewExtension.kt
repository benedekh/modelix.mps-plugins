package org.modelix.model.mpsplugin.projectview

import com.intellij.openapi.application.ApplicationManager
import com.intellij.ui.JBColor
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._void_P1_E0
import jetbrains.mps.ide.project.ProjectHelper
import jetbrains.mps.ide.projectPane.ProjectPane
import jetbrains.mps.ide.projectPane.logicalview.ProjectTree
import jetbrains.mps.ide.ui.tree.MPSTreeNode
import jetbrains.mps.ide.ui.tree.TextTreeNode
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelReference
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.module.SModuleListener
import org.jetbrains.mps.openapi.module.SModuleListenerBase
import org.jetbrains.mps.openapi.module.SModuleReference
import org.jetbrains.mps.openapi.module.SRepositoryListener
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase
import org.modelix.model.mpsplugin.CloudTransientModule
import org.modelix.model.mpsplugin.LetterInSquareIcon
import org.modelix.model.mpsplugin.history.TreeModelUtil
import java.awt.Color
import java.awt.event.ActionEvent
import java.awt.event.ActionListener
import java.util.concurrent.atomic.AtomicBoolean
import javax.swing.Icon
import javax.swing.Timer
import javax.swing.event.TreeModelEvent
import javax.swing.event.TreeModelListener
import javax.swing.tree.DefaultTreeModel
import javax.swing.tree.TreeNode
import kotlin.math.min

/*Generated by MPS */
class CloudProjectViewExtension(private val project: Project?) {
    private var cloudTreeNode: TextTreeNode? = null
    private val treeListener: TreeModelListener = object : TreeModelListener {
        private var handling: Boolean = false
        override fun treeNodesChanged(p0: TreeModelEvent) {
            handle()
        }

        override fun treeNodesInserted(p0: TreeModelEvent) {
            handle()
        }

        override fun treeNodesRemoved(p0: TreeModelEvent) {
            handle()
        }

        override fun treeStructureChanged(p0: TreeModelEvent) {
            handle()
        }

        fun handle() {
            if (handling) {
                return
            }
            try {
                handling = true
                attachCloudRootIfNotEmpty()
            } catch (ex: Exception) {
                if (LOG.isEnabledFor(Level.ERROR)) {
                    LOG.error("", ex)
                }
            } finally {
                handling = false
            }
        }
    }
    private var treeModel: DefaultTreeModel? = null
    private val repositoryListener: SRepositoryListener = object : SRepositoryListenerBase() {
        private val modulesDirty: AtomicBoolean = AtomicBoolean(true)
        override fun moduleAdded(m: SModule) {
            if (m is CloudTransientModule) {
                m.addModuleListener(moduleListener)
                queueUpdate()
            }
        }

        override fun moduleRemoved(m: SModuleReference) {
            queueUpdate()
        }

        fun queueUpdate() {
            modulesDirty.set(true)
            ApplicationManager.getApplication().invokeLater(object : Runnable {
                override fun run() {
                    if (modulesDirty.getAndSet(false)) {
                        updateModules()
                    }
                }
            })
        }
    }
    private val moduleListener: SModuleListener = object : SModuleListenerBase() {
        override fun modelAdded(module: SModule, model: SModel) {
            super.modelAdded(module, model)
        }

        override fun modelRemoved(module: SModule, ref: SModelReference) {
            super.modelRemoved(module, ref)
        }
    }

    fun init() {
        cloudTreeNode = TextTreeNode("Cloud")
        cloudTreeNode!!.icon = ROOT_ICON
        waitForProjectTree(object : _void_P1_E0<ProjectTree?> {
            override fun invoke(tree: ProjectTree?) {
                treeModel = TreeModelUtil.getModel(tree)
                treeModel!!.addTreeModelListener(treeListener)
                project!!.repository.addRepositoryListener(repositoryListener)
                updateModules()
            }
        })
    }

    private fun waitForProjectTree(callback: _void_P1_E0<in ProjectTree>) {
        val tree: ProjectTree? = projectTree
        if (tree != null) {
            callback.invoke(tree)
        } else {
            val timer: _T<Timer?> = _T(null)
            timer.value = Timer(
                1000,
                object : ActionListener {
                    override fun actionPerformed(e: ActionEvent) {
                        val tree: ProjectTree? = projectTree
                        if (tree != null) {
                            callback.invoke(tree)
                            timer.value!!.stop()
                        }
                    }
                },
            )
            timer.value!!.start()
        }
    }

    private val projectTree: ProjectTree?
        private get() {
            if (project!!.isDisposed) {
                return null
            }
            val pane: ProjectPane? = ProjectPane.getInstance(
                project,
            )
            if (pane == null) {
                return null
            }
            return pane.tree
        }

    fun dispose() {
        project!!.repository.removeRepositoryListener(repositoryListener)
        if (treeModel != null) {
            treeModel!!.removeTreeModelListener(treeListener)
        }
        MapSequence.fromMap(ourInstances).removeKey(
            ProjectHelper.toIdeaProject(
                project,
            ),
        )
    }

    fun attachCloudRoot() {
        val projectPane: ProjectPane = ProjectPane.getInstance(
            project,
        )
        val root: MPSTreeNode? = projectPane.tree.rootNode
        if (root == null) {
            return
        }
        val model: DefaultTreeModel? = TreeModelUtil.getModel(projectPane.tree)

        // wrong parent
        if (cloudTreeNode!!.parent != null && cloudTreeNode!!.parent !== root) {
            cloudTreeNode!!.removeFromParent()
        }

        // wrong position
        val preferedIndex: Int = 3
        if (cloudTreeNode!!.parent != null && cloudTreeNode!!.parent.getIndex(cloudTreeNode) != min(
                (cloudTreeNode!!.parent.childCount - 1),
                preferedIndex,
            )
        ) {
            model!!.removeNodeFromParent(cloudTreeNode)
        }
        if (cloudTreeNode!!.parent == null) {
            project!!.repository.modelAccess.runReadAction(object : Runnable {
                override fun run() {
                    model!!.insertNodeInto(
                        cloudTreeNode,
                        root,
                        min(root.childCount.toDouble(), preferedIndex.toDouble())
                            .toInt(),
                    )
                }
            })
        }
    }

    fun attachCloudRootIfNotEmpty() {
        if (cloudTreeNode!!.childCount == 0) {
            if (cloudTreeNode!!.parent != null && cloudTreeNode!!.tree != null) {
                TreeModelUtil.getModel(cloudTreeNode!!.tree)!!.removeNodeFromParent(cloudTreeNode)
            }
        } else {
            attachCloudRoot()
        }
    }

    fun forceUpdate() {
        while (cloudTreeNode!!.childCount > 0) {
            val moduleTreeNode: CloudModuleTreeNode = cloudTreeNode!!.getChildAt(0) as CloudModuleTreeNode
            TreeModelUtil.getModel(projectTree)!!.removeNodeFromParent(moduleTreeNode)
            moduleTreeNode.dispose()
        }
        updateModules()
    }

    fun updateModules() {
        val root: MPSTreeNode? = projectTree!!.rootNode
        if (root == null) {
            return
        }
        val treeModel: DefaultTreeModel? = TreeModelUtil.getModel(projectTree)
        project!!.repository.modelAccess.runReadAction(object : Runnable {
            override fun run() {
                val modules: Iterable<SModule> = project.repository.modules
                val module2treeNode: Map<SModule, CloudModuleTreeNode> = MapSequence.fromMap(HashMap())
                val treeNodesToRemove: Set<CloudModuleTreeNode> = SetSequence.fromSet(HashSet())
                Sequence.fromIterable<TreeNode>(getChildren(cloudTreeNode)).ofType<CloudModuleTreeNode>(
                    CloudModuleTreeNode::class.java,
                ).visitAll(object : IVisitor<CloudModuleTreeNode>() {
                    override fun visit(it: CloudModuleTreeNode) {
                        SetSequence.fromSet(treeNodesToRemove).addElement(it)
                        MapSequence.fromMap(module2treeNode).put(it.module, it)
                    }
                })
                var insertAt: Int = 0
                for (webModule: CloudTransientModule in Sequence.fromIterable<SModule>(modules)
                    .ofType<CloudTransientModule>(
                        CloudTransientModule::class.java,
                    ).sort(
                        object : ISelector<CloudTransientModule, String>() {
                            override fun select(it: CloudTransientModule): String {
                                return (it.moduleName)!!
                            }
                        },
                        true,
                    )) {
                    val moduleTreeNode: CloudModuleTreeNode? = MapSequence.fromMap(module2treeNode).get(webModule)
                    if (moduleTreeNode == null) {
                        treeModel!!.insertNodeInto(CloudModuleTreeNode(webModule), cloudTreeNode, insertAt)
                        insertAt++
                    } else {
                        insertAt = moduleTreeNode.parent.getIndex(moduleTreeNode) + 1
                        MapSequence.fromMap(module2treeNode).removeKey(webModule)
                        SetSequence.fromSet(treeNodesToRemove).removeElement(moduleTreeNode)
                    }
                }
                SetSequence.fromSet(treeNodesToRemove).visitAll(object : IVisitor<CloudModuleTreeNode>() {
                    override fun visit(it: CloudModuleTreeNode) {
                        treeModel!!.removeNodeFromParent(it)
                        it.dispose()
                    }
                })
                attachCloudRootIfNotEmpty()
            }
        })
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(CloudProjectViewExtension::class.java)
        val ROOT_ICON: Icon = LetterInSquareIcon("C", 14, 3.0f, 13.0f, JBColor.YELLOW, JBColor.BLACK)
        val MODULE_ICON: Icon = LetterInSquareIcon("M", 14, 2.0f, 13.0f, JBColor.YELLOW, JBColor.BLACK)
        val MODEL_ICON: Icon = LetterInSquareIcon("m", 14, 2.0f, 12.0f, JBColor.YELLOW, JBColor.BLACK)
        private val ourInstances: Map<com.intellij.openapi.project.Project, CloudProjectViewExtension> =
            MapSequence.fromMap(
                HashMap(),
            )

        fun getInstance(ideaProject: com.intellij.openapi.project.Project): CloudProjectViewExtension {
            var instance: CloudProjectViewExtension? = MapSequence.fromMap(ourInstances).get(ideaProject)
            if (instance == null) {
                val mpsProject: MPSProject? = ProjectHelper.fromIdeaProject(ideaProject)
                instance = CloudProjectViewExtension(mpsProject)
                MapSequence.fromMap(ourInstances).put(ideaProject, instance)
            }
            return instance
        }

        fun getInstance(mpsProject: Project?): CloudProjectViewExtension {
            return getInstance(ProjectHelper.toIdeaProject(mpsProject))
        }

        private fun getChildren(parent: TreeNode?): Iterable<TreeNode> {
            val result: List<TreeNode> = ListSequence.fromList(ArrayList())
            for (i in 0 until parent!!.childCount) {
                ListSequence.fromList(result).addElement(parent.getChildAt(i))
            }
            return result
        }
    }
}
