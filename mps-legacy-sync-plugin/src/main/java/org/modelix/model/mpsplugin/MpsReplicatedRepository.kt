package org.modelix.model.mpsplugin

import com.intellij.openapi.command.CommandProcessor
import com.intellij.openapi.command.undo.DocumentReference
import com.intellij.openapi.command.undo.UndoManager
import com.intellij.openapi.command.undo.UndoableAction
import com.intellij.openapi.command.undo.UnexpectedUndoException
import com.intellij.openapi.project.Project
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.smodel.MPSModuleRepository
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.repository.CommandListener
import org.modelix.model.area.PArea
import org.modelix.model.client.IModelClient
import org.modelix.model.client.ReplicatedRepository
import org.modelix.model.lazy.CLVersion
import org.modelix.model.lazy.KVEntryReference
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.operations.UndoOp
import org.modelix.model.operations.applyOperation
import org.modelix.model.persistent.CPVersion
import java.util.function.Supplier

/*Generated by MPS */
class MpsReplicatedRepository(
    client: IModelClient?,
    repositoryId: RepositoryId?,
    branchName: String,
    user: () -> String?
) : ReplicatedRepository(
    (client)!!, (repositoryId)!!, branchName, { (user() ?: "<unknown author>") }) {
    private val commandListener: CommandListener = object : CommandListener {
        public override fun commandStarted() {
            SetSequence.fromSet(affectedDocuments).clear()
            startEdit()
        }

        public override fun commandFinished() {
            val version: CLVersion? = endEdit()
            if (version == null) {
                return
            }
            val project: Project? = CommandProcessor.getInstance().getCurrentCommandProject()
            if (project == null) {
                return
            }
            val undoManager: UndoManager = UndoManager.getInstance(project)
            undoManager.undoableActionPerformed(ModelixUndoableAction(version, affectedDocuments))
        }
    }

    init {
        MPSModuleRepository.getInstance().getModelAccess().addCommandListener(commandListener)
        synchronized(INSTANCES, { SetSequence.fromSet(INSTANCES).addElement(this) })
    }

    public override fun dispose() {
        synchronized(INSTANCES, { SetSequence.fromSet(INSTANCES).removeElement(this) })
        if (isDisposed()) {
            return
        }
        MPSModuleRepository.getInstance().getModelAccess().removeCommandListener(commandListener)
        super.dispose()
    }

    inner class ModelixUndoableAction(private val version: CLVersion, docs: Iterable<DocumentReference>?) :
        UndoableAction {
        private val documents: Array<DocumentReference>

        init {
            documents = Sequence.fromIterable(docs).toGenericArray(
                DocumentReference::class.java
            )
        }

        @Throws(UnexpectedUndoException::class)
        public override fun undo() {
            PArea(branch).executeWrite({
                branch.writeTransaction.applyOperation(UndoOp(KVEntryReference(version.data!!)))
                Unit
            })
        }

        @Throws(UnexpectedUndoException::class)
        public override fun redo() {
            throw UnexpectedUndoException("Not supported yet")
        }

        public override fun getAffectedDocuments(): Array<DocumentReference>? {
            return (if (documents.size == 0) null else documents)
        }

        public override fun isGlobal(): Boolean {
            return documents.size == 0
        }
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(MpsReplicatedRepository::class.java)
        private val INSTANCES: Set<MpsReplicatedRepository> = SetSequence.fromSet(HashSet())
        fun disposeAll() {
            var list: List<MpsReplicatedRepository>?
            synchronized(INSTANCES, { list = ListSequence.fromListWithValues(ArrayList(), INSTANCES) })
            for (instance: MpsReplicatedRepository in ListSequence.fromList(list)) {
                try {
                    instance.dispose()
                } catch (ex: Exception) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("", ex)
                    }
                }
            }
        }

        private val affectedDocuments: Set<DocumentReference> = SetSequence.fromSet(HashSet())
        fun documentChanged(doc: DocumentReference) {
            SetSequence.fromSet(affectedDocuments).addElement(doc)
        }
    }
}
