package org.modelix.model.mpsplugin.history

import jetbrains.mps.ide.ThreadUtils
import jetbrains.mps.ide.ui.tree.TextTreeNode
import jetbrains.mps.internal.collections.runtime.IListSequence
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SNode
import org.modelix.model.api.IBranch
import org.modelix.model.api.IBranchListener
import org.modelix.model.api.ITree
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.area.PArea
import org.modelix.model.client.ActiveBranch
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsplugin.CloudIcons
import org.modelix.model.mpsplugin.CloudRepository
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.mpsplugin.SharedExecutors
import org.modelix.model.mpsplugin.history.CloudView.CloudViewTree
import java.util.Objects
import javax.swing.SwingUtilities
import javax.swing.tree.TreeNode
import kotlin.jvm.functions.Function0.invoke
import kotlin.jvm.functions.Function1.invoke

/*Generated by MPS */
class RepositoryTreeNode(modelServer: ModelServerConnection?, repositoryInfo: SNode?) :
    TextTreeNode(CloudIcons.REPOSITORY_ICON, SPropertyOperations.getString(repositoryInfo, PROPS.`id$baYB`)) {
    val modelServer: ModelServerConnection? = null
    val repositoryInfo: SNode? = null
    var repositoryId: RepositoryId? = null
    private var activeBranch: ActiveBranch? = null
    private val dataTreeNode: TextTreeNode = TextTreeNode("data")
    private val branchesTreeNode: TextTreeNode = TextTreeNode("branches")
    private var bindingsTreeNode: CloudBindingTreeNode? = null
    private val branchListener: IBranchListener = object : IBranchListener {
        public override fun treeChanged(oldTree: ITree?, newTree: ITree) {
            SwingUtilities.invokeLater(object : Runnable {
                public override fun run() {
                    (getTree() as CloudViewTree).runRebuildAction(object : Runnable {
                        public override fun run() {
                            updateData()
                        }
                    }, true)
                }
            })
        }
    }

    init {
        try {
            this.modelServer = modelServer
            this.repositoryInfo = repositoryInfo
            repositoryId = RepositoryId(SPropertyOperations.getString(repositoryInfo, PROPS.`id$baYB`))
            activeBranch = modelServer!!.getActiveBranch(
                RepositoryId(
                    SPropertyOperations.getString(
                        repositoryInfo,
                        PROPS.`id$baYB`
                    )
                )
            )
            val cloudRepository: CloudRepository = CloudRepository(modelServer, repositoryId)
            bindingsTreeNode = CloudBindingTreeNode(cloudRepository.getRootBinding(), cloudRepository)
            setAllowsChildren(true)
            TreeModelUtil.setChildren(
                this,
                ListSequence.fromListAndArray(ArrayList<TreeNode>(), dataTreeNode, branchesTreeNode, bindingsTreeNode)
            )
            activeBranch.addListener(branchListener)
            updateData()
        } catch (e: RuntimeException) {
            throw RuntimeException(
                "Unable to initialize RepositoryTreeNode for repository with id " + SPropertyOperations.getString(
                    repositoryInfo,
                    PROPS.`id$baYB`
                ), e
            )
        }
    }

    override fun onRemove() {
        super.onRemove()
        activeBranch!!.removeListener(branchListener)
    }

    fun updateChildren() {
        updateBranches()
    }

    fun updateBranches() {
        val existing: Map<SNode?, CloudBranchTreeNode> = MapSequence.fromMap(LinkedHashMap(16, 0.75.toFloat(), false))
        ThreadUtils.runInUIThreadAndWait(object : Runnable {
            public override fun run() {
                if (Sequence.fromIterable<TreeNode?>(TreeModelUtil.getChildren(this@RepositoryTreeNode)).isEmpty()) {
                    TreeModelUtil.setChildren(
                        this@RepositoryTreeNode,
                        Sequence.singleton<TreeNode>(LoadingIcon.Companion.apply<TextTreeNode>(TextTreeNode("loading ...")))
                    )
                }
                for (node: CloudBranchTreeNode in Sequence.fromIterable<TreeNode?>(
                    TreeModelUtil.getChildren(
                        branchesTreeNode
                    )
                ).ofType<CloudBranchTreeNode>(
                    CloudBranchTreeNode::class.java
                )) {
                    MapSequence.fromMap(existing).put(node.getBranchInfo(), node)
                }
            }
        })
        SharedExecutors.FIXED.execute(object : Runnable {
            public override fun run() {
                val newChildren: List<TreeNode>? =
                    PArea(modelServer.getInfoBranch()).executeRead<IListSequence<TreeNode>?>({
                        ListSequence.fromList<SNode>(SLinkOperations.getChildren(repositoryInfo, LINKS.`branches$b5_g`))
                            .select<TreeNode>(object : ISelector<SNode?, TreeNode>() {
                                public override fun select(it: SNode?): TreeNode {
                                    val tn: TreeNode? = (if (MapSequence.fromMap(existing)
                                            .containsKey(it)
                                    ) MapSequence.fromMap(existing).get(it) else CloudBranchTreeNode(modelServer, it))
                                    return@executeRead tn
                                }
                            }).toListSequence()
                    })
                ThreadUtils.runInUIThreadNoWait(object : Runnable {
                    public override fun run() {
                        TreeModelUtil.setChildren(branchesTreeNode, newChildren)
                    }
                })
            }
        })
    }

    fun updateData() {
        TreeModelUtil.setTextAndRepaint(dataTreeNode, "data [" + activeBranch!!.branchName + "]")
        val branch: IBranch = activeBranch.branch
        val rootNode: PNodeAdapter = PNodeAdapter(ITree.ROOT_ID, branch)
        val childTreeNodes: Iterable<TreeNode?> =
            Sequence.fromIterable(TreeModelUtil.getChildren(dataTreeNode)).toListSequence()
        if (Sequence.fromIterable(childTreeNodes).count() != 1 || !(Objects.equals(
                (Sequence.fromIterable(childTreeNodes).first() as CloudNodeTreeNode?).getNode(), rootNode
            ))
        ) {
            val newTreeNode: CloudNodeTreeNode = CloudNodeTreeNode(branch, rootNode)
            TreeModelUtil.setChildren(dataTreeNode, ListSequence.fromListAndArray(ArrayList<TreeNode>(), newTreeNode))
        }
        Sequence.fromIterable(TreeModelUtil.getChildren(dataTreeNode)).ofType(
            CloudNodeTreeNode::class.java
        ).visitAll(object : IVisitor<CloudNodeTreeNode>() {
            public override fun visit(it: CloudNodeTreeNode) {
                it.update()
            }
        })
    }

    private object PROPS {
        /*package*/
        val `id$baYB`: SProperty = MetaAdapterFactory.getProperty(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc0L,
            0x62b7d9b07cecbcc6L,
            "id"
        )
    }

    private object LINKS {
        /*package*/
        val `branches$b5_g`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc0L,
            0x62b7d9b07cecbcc4L,
            "branches"
        )
    }
}
