package org.modelix.model.mpsplugin.history

import com.intellij.icons.AllIcons
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P0_E0
import jetbrains.mps.ide.ThreadUtils
import jetbrains.mps.ide.icons.GlobalIconManager
import jetbrains.mps.ide.ui.tree.TextTreeNode
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.model.SNode
import org.jetbrains.mps.openapi.module.SRepository
import org.modelix.model.api.IBranch
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.ITree
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.ContextArea.withAdditionalContext
import org.modelix.model.area.PArea
import org.modelix.model.mpsadapters.mps.MPSArea
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsplugin.CommandHelper
import org.modelix.model.mpsplugin.MPSNodeMapping
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.mpsplugin.SharedExecutors
import javax.swing.tree.TreeNode

/*Generated by MPS */
/**
 * This represents a single node inside the CloudView
 */
class CloudNodeTreeNode(val branch: IBranch, val node: INode) : TextTreeNode("") {
    var concept: IConcept? = null
    private var initialized: Boolean = false

    init {
        PArea(branch).executeRead({
            concept = node.concept
            val nodeId: Long = (node as PNodeAdapter).nodeId
            nodeIdentifier = nodeId.toString()
            updateText()
        })
    }

    override fun isInitialized(): Boolean {
        return initialized
    }

    override fun update() {
        doUpdate()
    }

    public override fun doUpdate() {
        TreeModelUtil.clearChildren(this)
        initialized = false
    }

    override fun isLeaf(): Boolean {
        if (!(initialized)) {
            return false
        }
        return super.isLeaf()
    }

    override fun doUpdatePresentation() {
        super.doUpdatePresentation()
        updateText()
    }

    override fun doInit() {
        super.doInit()
        initialized = true
        updateText()
        updateChildren()
    }

    val modelServer: ModelServerConnection?
        get() {
            return check_s6g2x7_a0a62(getAncestor(RepositoryTreeNode::class.java), this)
        }

    fun setTextAndRepaint(text: String?) {
        TreeModelUtil.setTextAndRepaint(this, text)
    }

    fun updateText() {
        ThreadUtils.runInUIThreadAndWait(object : Runnable {
            override fun run() {
                LoadingIcon.Companion.apply<CloudNodeTreeNode>(this@CloudNodeTreeNode)
            }
        })
        SharedExecutors.FIXED.execute(
            _Adapters._return_P0_E0_to_Runnable_adapter(object : _return_P0_E0<Unit> {
                override fun invoke() {
                    return PArea(branch).executeRead({
                        val newText: _T<String> = _T("")
                        var mappedMPSNodeID: String? = null
                        val nodeId: Long = (node as PNodeAdapter).nodeId
                        if (nodeId == ITree.ROOT_ID) {
                            newText.value = "ROOT #1"
                            icon = AllIcons.Nodes.Folder
                        } else {
                            val concept: IConcept? = node.concept
                            if (concept != null) {
                                mappedMPSNodeID = MPSNodeMapping.mappedMpsNodeID(node)
                                val snode: SNode = NodeToSNodeAdapter.wrap(node)
                                val mpsRepo: SRepository = CommandHelper.sRepository
                                if (mpsRepo == null) {
                                    throw IllegalStateException("repository should not be null")
                                }
                                mpsRepo.modelAccess.runReadAction(
                                    _Adapters._return_P0_E0_to_Runnable_adapter(object :
                                        _return_P0_E0<Unit> {
                                        override fun invoke() {
                                            return withAdditionalContext<Unit>(MPSArea(mpsRepo), {
                                                try {
                                                    newText.value =
                                                        snode.toString() + " [" + concept.getLongName() + "]   #" + java.lang.Long.toHexString(
                                                            nodeId,
                                                        )
                                                } catch (ex: Exception) {
                                                    if (LOG.isEnabledFor(Level.ERROR)) {
                                                        LOG.error("Failed to update the text", ex)
                                                    }
                                                    newText.value = "!!!" + ex.message
                                                }
                                                try {
                                                    icon = GlobalIconManager.getInstance().getIconFor((snode)!!)
                                                } catch (ex: Exception) {
                                                    if (LOG.isEnabledFor(Level.ERROR)) {
                                                        LOG.error("Failed to update the icon", ex)
                                                    }
                                                }
                                            })
                                        }
                                    }),
                                )
                            } else {
                                newText.value = "#" + nodeId
                            }
                        }
                        val role: String? = node.roleInParent
                        if (role != null) {
                            newText.value = role + " : " + newText.value
                        }
                        if (mappedMPSNodeID != null) {
                            newText.value = newText.value + " -> MPS(" + mappedMPSNodeID + ")"
                        }
                        ThreadUtils.runInUIThreadNoWait(object : Runnable {
                            override fun run() {
                                setTextAndRepaint(newText.value)
                            }
                        })
                    })
                }
            }),
        )
    }

    protected fun updateChildren() {
        if (!(initialized)) {
            throw RuntimeException()
        }
        val existing: Map<INode, CloudNodeTreeNode> = MapSequence.fromMap(LinkedHashMap(16, 0.75.toFloat(), false))
        ThreadUtils.runInUIThreadAndWait(object : Runnable {
            override fun run() {
                if (Sequence.fromIterable<TreeNode?>(TreeModelUtil.getChildren(this@CloudNodeTreeNode)).isEmpty) {
                    TreeModelUtil.setChildren(
                        this@CloudNodeTreeNode,
                        Sequence.singleton<TreeNode>(LoadingIcon.Companion.apply<TextTreeNode>(TextTreeNode("loading ..."))),
                    )
                }
                Sequence.fromIterable<TreeNode?>(TreeModelUtil.getChildren(this@CloudNodeTreeNode))
                    .ofType<CloudNodeTreeNode>(
                        CloudNodeTreeNode::class.java,
                    ).visitAll(object : IVisitor<CloudNodeTreeNode>() {
                        override fun visit(it: CloudNodeTreeNode) {
                            MapSequence.fromMap(existing).put(it.node, it)
                        }
                    })
            }
        })
        SharedExecutors.FIXED.execute(
            _Adapters._return_P0_E0_to_Runnable_adapter(object : _return_P0_E0<Unit> {
                override fun invoke() {
                    return PArea(branch).executeRead<Unit>({
                        val allChildren: Iterable<INode> = node.allChildren
                        val newChildren: List<CloudNodeTreeNode> = Sequence.fromIterable<INode>(allChildren)
                            .select<CloudNodeTreeNode>(object : ISelector<INode, CloudNodeTreeNode>() {
                                override fun select(it: INode): CloudNodeTreeNode? {
                                    return (
                                        if (MapSequence.fromMap<INode, CloudNodeTreeNode>(existing).containsKey(it)) {
                                            MapSequence.fromMap<INode, CloudNodeTreeNode>(existing).get(it)
                                        } else {
                                            CloudNodeTreeNode(branch, it)
                                        }
                                        )
                                }
                            }).toListSequence()
                        ThreadUtils.runInUIThreadNoWait(object : Runnable {
                            override fun run() {
                                TreeModelUtil.setChildren(
                                    this@CloudNodeTreeNode,
                                    ListSequence.fromList(newChildren).ofType(
                                        TreeNode::class.java,
                                    ),
                                )
                                ListSequence.fromList(newChildren).visitAll(object : IVisitor<CloudNodeTreeNode>() {
                                    override fun visit(it: CloudNodeTreeNode) {
                                        it.update()
                                    }
                                })
                            }
                        })
                    })
                }
            }),
        )
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(CloudNodeTreeNode::class.java)
        private fun check_s6g2x7_a0a62(
            checkedDotOperand: RepositoryTreeNode?,
            checkedDotThisExpression: CloudNodeTreeNode,
        ): ModelServerConnection? {
            if (null != checkedDotOperand) {
                return checkedDotOperand.modelServer
            }
            return null
        }
    }
}
