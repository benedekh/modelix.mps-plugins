package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SProperty
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import java.util.LinkedList
import java.util.Objects

/*Generated by MPS */
object INodeUtils {
    fun nodeIdAsLong(_this: INode?): Long {
        val cloudProjectAsPNodeAdapter: PNodeAdapter? = (_this as PNodeAdapter?)
        val nodeId: Long = cloudProjectAsPNodeAdapter!!.nodeId
        return nodeId
    }

    fun containingModule(_this: INode?): INode? {
        if (isModule(_this)) {
            return _this
        }
        val parent: INode? = _this!!.parent
        if (parent == null) {
            return null
        }
        return containingModule(parent)
    }

    fun containingModel(_this: INode?): INode? {
        if (isModel(_this)) {
            return _this
        }
        val parent: INode? = _this!!.parent
        if (parent == null) {
            return null
        }
        return containingModel(parent)
    }

    fun isModule(_this: INode?): Boolean {
        val concept: IConcept? = _this!!.concept
        if (concept == null) {
            return false
        }
        return concept.isSubConceptOf(SConceptAdapter.Companion.wrap(CONCEPTS.`Module$4i`))
    }

    fun isModel(_this: INode?): Boolean {
        val concept: IConcept? = _this!!.concept
        if (concept == null) {
            return false
        }
        return concept.isSubConceptOf(SConceptAdapter.Companion.wrap(CONCEPTS.`Model$2P`))
    }

    fun findChildByName(_this: INode, name: String?): INode? {
        for (child: INode in Sequence.fromIterable(_this.allChildren)) {
            if (Objects.equals(child.getPropertyValue("name"), name)) {
                return child
            }
        }
        return null
    }

    fun getChidlrenAsList(_this: INode?, role: String?): List<INode> {
        val nodes: List<INode> = ListSequence.fromList(LinkedList())
        for (node: INode in Sequence.fromIterable(
            _this!!.getChildren(role),
        )) {
            ListSequence.fromList(nodes).addElement(node)
        }
        return nodes
    }

    fun removeAllChildrenWithRole(_this: INode?, role: String?) {
        val nodes: List<INode> = ListSequence.fromList(LinkedList())
        for (node: INode in Sequence.fromIterable(
            _this!!.getChildren(role),
        )) {
            ListSequence.fromList(nodes).addElement(node)
        }
        for (child: INode? in ListSequence.fromList(nodes)) {
            _this.removeChild((child)!!)
        }
    }

    fun copyProperty(_this: INode?, original: INode?, propertyName: String) {
        try {
            _this!!.setPropertyValue(propertyName, original!!.getPropertyValue(propertyName))
        } catch (e: Exception) {
            throw RuntimeException("Unable to copy property " + propertyName + " from " + original + " to " + _this, e)
        }
    }

    fun copyProperty(_this: INode, original: INode, property: SProperty) {
        try {
            _this.setPropertyValue(property.name, original.getPropertyValue(property.name))
        } catch (e: Exception) {
            throw RuntimeException(
                "Unable to copy property " + property.name + " from " + original + " to " + _this,
                e,
            )
        }
    }

    fun copyPropertyIfNecessary(copiedNode: INode, originalNode: INode, property: SProperty) {
        if (Objects.equals(originalNode.getPropertyValue(property.name), copiedNode.getPropertyValue(property.name))) {
            return
        }
        copyProperty(copiedNode, originalNode, property)
    }

    fun replicateChild(copiedParent: INode, role: String, originalChild: INode): INode {
        return replicateChildren(copiedParent, role, listOf(originalChild)).single()
    }

    data class PostponedReferenceAssignments(
        val copiedNode: INode,
        val referenceRole: String,
        val originalTarget: INode,
    )

    private fun replicateChildren(copiedParent: INode, role: String, originalChildren: Iterable<INode>): List<INode> {
        val equivalenceMap = mutableMapOf<INode, INode>()
        val postponedReferencesAssignments = mutableListOf<PostponedReferenceAssignments>()
        val resultNodes = mutableListOf<INode>()
        for (originalChild in originalChildren) {
            try {
                val result = replicateChildHelper(copiedParent, role, originalChild, equivalenceMap, postponedReferencesAssignments)
                resultNodes.add(result)
            } catch (e: Exception) {
                throw RuntimeException(
                    "Unable to replicate child in role " + role + ". Original child: " + originalChild + ", Copied parent: " + copiedParent,
                    e,
                )
            }
        }
        for (postponedRefAssignment in postponedReferencesAssignments) {
            val copiedNode = postponedRefAssignment.copiedNode
            val referenceRole = postponedRefAssignment.referenceRole
            val copiedTarget = equivalenceMap[postponedRefAssignment.originalTarget]
            val targetToSet = copiedTarget ?: postponedRefAssignment.originalTarget
            copiedNode.setReferenceTarget(referenceRole, targetToSet)
        }
        return resultNodes
    }

    fun cloneChildren(copiedParent: INode, originalParent: INode, role: String) {
        removeAllChildrenWithRole(copiedParent, role)
        replicateChildren(copiedParent, role, originalParent.getChildren(role))
    }

    fun replicateChildHelper(
        copiedParent: INode,
        role: String,
        original: INode,
        equivalenceMap: MutableMap<INode, INode>,
        postponedReferencesAssignments: MutableList<PostponedReferenceAssignments>,
    ): INode {
        val concept: IConcept? = original.concept
        checkNotNull(concept)
        val copy = try {
            val addedChild = copiedParent.addNewChild(role, -1, concept)
            equivalenceMap[original] = addedChild
            addedChild
        } catch (e: Exception) {
            throw RuntimeException(
                "Unable to add child to " + copiedParent + " with role " + role + " and concept " + concept,
                e,
            )
        }
        for (property: IProperty in concept.getAllProperties()) {
            copy.setPropertyValue(property.name, original.getPropertyValue(property.name))
        }
        for (childLink: IChildLink in concept.getAllChildLinks()) {
            for (child: INode in getChidlrenAsList(original, childLink.name)) {
                replicateChildHelper(copy, childLink.name, child, equivalenceMap, postponedReferencesAssignments)
            }
        }
        for (refLink: IReferenceLink in concept.getAllReferenceLinks()) {
            val originalTarget: INode? = original.getReferenceTarget(refLink.name)
            if (originalTarget != null) {
                postponedReferencesAssignments.add(PostponedReferenceAssignments(copy, refLink.name, originalTarget))
            }
        }
        return copy
    }

    private object CONCEPTS {
        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module",
        )

        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model",
        )
    }
}
