package org.modelix.model.mpsplugin

import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SProperty
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.INode
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import java.util.LinkedList
import java.util.Objects

/*Generated by MPS */
object INodeUtils {
    fun nodeIdAsLong(_this: INode?): Long {
        val cloudProjectAsPNodeAdapter: PNodeAdapter? = (_this as PNodeAdapter?)
        val nodeId: Long = cloudProjectAsPNodeAdapter!!.nodeId
        return nodeId
    }

    fun containingModule(_this: INode?): INode? {
        if (isModule(_this)) {
            return _this
        }
        val parent: INode? = _this!!.parent
        if (parent == null) {
            return null
        }
        return containingModule(parent)
    }

    fun containingModel(_this: INode?): INode? {
        if (isModel(_this)) {
            return _this
        }
        val parent: INode? = _this!!.parent
        if (parent == null) {
            return null
        }
        return containingModel(parent)
    }

    fun isModule(_this: INode?): Boolean {
        val concept: IConcept? = _this!!.concept
        if (concept == null) {
            return false
        }
        return concept.isSubConceptOf(SConceptAdapter.Companion.wrap(CONCEPTS.`Module$4i`))
    }

    fun isModel(_this: INode?): Boolean {
        val concept: IConcept? = _this!!.concept
        if (concept == null) {
            return false
        }
        return concept.isSubConceptOf(SConceptAdapter.Companion.wrap(CONCEPTS.`Model$2P`))
    }

    fun findChildByName(_this: INode, name: String?): INode? {
        for (child: INode in Sequence.fromIterable(_this.allChildren)) {
            if (Objects.equals(child.getPropertyValue("name"), name)) {
                return child
            }
        }
        return null
    }

    fun getChidlrenAsList(_this: INode?, role: String?): List<INode> {
        val nodes: List<INode> = ListSequence.fromList(LinkedList())
        for (node: INode in Sequence.fromIterable(
            _this!!.getChildren(role),
        )) {
            ListSequence.fromList(nodes).addElement(node)
        }
        return nodes
    }

    fun removeAllChildrenWithRole(_this: INode?, role: String?) {
        val nodes: List<INode> = ListSequence.fromList(LinkedList())
        for (node: INode in Sequence.fromIterable(
            _this!!.getChildren(role),
        )) {
            ListSequence.fromList(nodes).addElement(node)
        }
        for (child: INode? in ListSequence.fromList(nodes)) {
            _this.removeChild((child)!!)
        }
    }

    fun copyProperty(_this: INode?, original: INode?, propertyName: String) {
        try {
            _this!!.setPropertyValue(propertyName, original!!.getPropertyValue(propertyName))
        } catch (e: Exception) {
            throw RuntimeException("Unable to copy property " + propertyName + " from " + original + " to " + _this, e)
        }
    }

    fun copyProperty(_this: INode, original: INode, property: SProperty) {
        try {
            _this.setPropertyValue(property.getName(), original.getPropertyValue(property.getName()))
        } catch (e: Exception) {
            throw RuntimeException(
                "Unable to copy property " + property.getName() + " from " + original + " to " + _this,
                e,
            )
        }
    }

    fun copyPropertyIfNecessary(_this: INode, original: INode, property: SProperty) {
        if (Objects.equals(original.getPropertyValue(property.getName()), _this.getPropertyValue(property.getName()))) {
            return
        }
        copyProperty(_this, original, property)
    }

    fun replicateChild(_this: INode?, role: String, original: INode?): INode {
        try {
            val equivalenceMap: Map<INode?, INode> = MapSequence.fromMap(HashMap())
            val postponedReferencesAssignments: List<Tuples._3<INode, String, INode>> =
                ListSequence.fromList(LinkedList())
            val result: INode =
                replicateChildHelper(_this, role, original, equivalenceMap, postponedReferencesAssignments)
            for (postponedRefAssignment: Tuples._3<INode, String, INode> in ListSequence.fromList(
                postponedReferencesAssignments,
            )) {
                var target: INode? = postponedRefAssignment._2()
                if (MapSequence.fromMap(equivalenceMap).containsKey(target)) {
                    target = MapSequence.fromMap(equivalenceMap).get(target)
                }
                postponedRefAssignment._0().setReferenceTarget(postponedRefAssignment._1(), target)
            }
            return result
        } catch (e: Exception) {
            throw RuntimeException(
                "Unable to replicate child in role " + role + ". Original: " + original + ", This: " + _this,
                e,
            )
        }
    }

    fun cloneChildren(_this: INode?, original: INode?, role: String) {
        removeAllChildrenWithRole(_this, role)
        for (originalChild: INode? in Sequence.fromIterable(
            original!!.getChildren(role),
        )) {
            replicateChild(_this, role, originalChild)
        }
    }

    fun replicateChildHelper(
        _this: INode?,
        role: String,
        original: INode?,
        equivalenceMap: Map<INode?, INode>?,
        postponedReferencesAssignments: List<Tuples._3<INode, String, INode>>?,
    ): INode {
        val concept: IConcept? = original!!.concept
        var copy: INode? = null
        try {
            copy = _this!!.addNewChild(role, -1, concept)
        } catch (e: Exception) {
            throw RuntimeException(
                "Unable to add child to " + _this + " with role " + role + " and concept " + concept,
                e,
            )
        }
        for (property: IProperty in ListSequence.fromList<IProperty>(concept!!.getAllProperties())) {
            copy.setPropertyValue(property.name, original.getPropertyValue(property.name))
        }
        for (childLink: IChildLink in ListSequence.fromList<IChildLink>(concept.getAllChildLinks())) {
            for (child: INode? in ListSequence.fromList<INode>(getChidlrenAsList(original, childLink.name))) {
                replicateChildHelper(copy, childLink.name, child, equivalenceMap, postponedReferencesAssignments)
            }
        }
        for (refLink: IReferenceLink in ListSequence.fromList<IReferenceLink>(concept.getAllReferenceLinks())) {
            val target: INode? = original.getReferenceTarget(refLink.name)
            if (target != null) {
                ListSequence.fromList(postponedReferencesAssignments)
                    .addElement(MultiTuple.from(copy, refLink.name, target))
            }
        }
        return copy
    }

    private object CONCEPTS {
        /*package*/
        val `Module$4i`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module",
        )

        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model",
        )
    }
}
