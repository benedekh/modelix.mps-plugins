package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.model.ModelDeleteHelper
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.smodel.ModuleDependencyVersions
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.smodel.language.LanguageRegistry
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelId
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.persistence.PersistenceFacade
import org.modelix.model.api.IProperty
import org.modelix.model.api.ITree
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SModelAsNode
import java.util.Objects

/*Generated by MPS */
open class ModelsSynchronizer(cloudParentId: Long, open val module: SModule) :
    Synchronizer<SModel>(cloudParentId, LINKS.`models$h3QT`.name) {

    override val mPSChildren: Iterable<SModel>
        get() {
            return ListSequence.fromList(
                SModuleUtils.getModelsWithoutDescriptor(
                    module,
                ),
            ).where(object : IWhereFilter<SModel>() {
                override fun accept(it: SModel): Boolean {
                    return !(it.isReadOnly)
                }
            })
        }

    override fun createMPSChild(tree: ITree, cloudChildId: Long): SModel {
        var id: SModelId? = getModelId(tree, cloudChildId)
        if (id == null) {
            id = jetbrains.mps.smodel.SModelId.foreign("cloud-" + cloudChildId)
        }
        val name: String? = tree.getProperty(cloudChildId, PROPS.`name$MnvL`.name)
        return createModel(name, id, cloudChildId)
    }

    protected open fun createModel(name: String?, id: SModelId?, modelNodeId: Long): SModel {
        return SModuleUtils.createModel(module, name, id)
    }

    override fun removeMPSChild(mpsChild: SModel) {
        ModelDeleteHelper((mpsChild)).delete()
    }

    override fun associate(
        tree: ITree,
        cloudChildren: List<Long>,
        mpsChildren: List<SModel>,
        direction: SyncDirection?,
    ): Map<Long, SModel> {
        val result: Map<Long, SModel> = MapSequence.fromMap(HashMap())
        val availableModels: List<SModel?> = ListSequence.fromListWithValues(ArrayList(), mpsChildren)
        for (cloudModelId: Long in cloudChildren) {
            val id: SModelId? = getModelId(tree, cloudModelId)
            val name: String? = tree.getProperty(cloudModelId, PROPS.`name$MnvL`.name)

            // There can be models with duplicate names. That's why we can't just search in a map.
            val itr: MutableIterator<SModel?> = ListSequence.fromList(availableModels).iterator()
            while (itr.hasNext()) {
                val it: SModel? = itr.next()
                if (id != null && Objects.equals(it!!.modelId, id) || Objects.equals(
                        it!!.name.value,
                        name,
                    )
                ) {
                    MapSequence.fromMap(result).put(cloudModelId, it)
                    itr.remove()
                    break
                }
            }
        }
        return result
    }

    protected fun getModelId(tree: ITree, cloudModelId: Long): SModelId? {
        val serializedId: String? = tree.getProperty(cloudModelId, PROPS.`id$lDUo`.name)
        if ((serializedId == null || serializedId.length == 0)) {
            return null
        }
        return PersistenceFacade.getInstance().createModelId(serializedId)
    }

    override fun createCloudChild(t: IWriteTransaction, mpsChild: SModel): Long {
        val modelNodeId: Long = t.addNewChild(
            cloudParentId,
            LINKS.`models$h3QT`.name,
            -1,
            SConceptAdapter.Companion.wrap(
                CONCEPTS.`Model$2P`,
            ),
        )
        val modelAsNode: SModelAsNode = SModelAsNode((mpsChild))
        for (property: IProperty in modelAsNode.concept.getAllProperties()) {
            t.setProperty(modelNodeId, property.name, modelAsNode.getPropertyValue(property.name))
        }
        t.setProperty(modelNodeId, PROPS.`id$lDUo`.name, mpsChild.modelId.toString())
        t.setProperty(modelNodeId, "\$originalId", SModelAsNode((mpsChild)).reference.serialize())
        t.setProperty(modelNodeId, PROPS.`name$MnvL`.name, mpsChild.name.value)
        return modelNodeId
    }

    override fun syncToMPS(tree: ITree): Map<Long, SModel> {
        val result = super.syncToMPS(tree)
        val projects: List<Project> = ProjectManager.getInstance().openedProjects
        if (ListSequence.fromList(projects).isNotEmpty) {
            val project: Project = ListSequence.fromList(projects).first()
            ModuleDependencyVersions(
                LanguageRegistry.getInstance(project.repository),
                project.repository,
            ).update(
                (module),
            )
        }
        return result
    }

    private object LINKS {
        /*package*/
        val `models$h3QT`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x69652614fd1c512L,
            "models",
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name",
        )

        /*package*/
        val `id$lDUo`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x244b85440ee67212L,
            "id",
        )
    }

    private object CONCEPTS {
        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model",
        )
    }
}
