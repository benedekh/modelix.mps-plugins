package org.modelix.model.mpsplugin

import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.MapSequence
import jetbrains.mps.model.ModelDeleteHelper
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.smodel.ModuleDependencyVersions
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import jetbrains.mps.smodel.language.LanguageRegistry
import org.jetbrains.mps.openapi.language.SConcept
import org.jetbrains.mps.openapi.language.SContainmentLink
import org.jetbrains.mps.openapi.language.SProperty
import org.jetbrains.mps.openapi.model.SModel
import org.jetbrains.mps.openapi.model.SModelId
import org.jetbrains.mps.openapi.module.SModule
import org.jetbrains.mps.openapi.persistence.PersistenceFacade
import org.modelix.model.api.IConcept.getAllProperties
import org.modelix.model.api.IProperty
import org.modelix.model.api.ITransaction.getConcept
import org.modelix.model.api.ITree
import org.modelix.model.api.ITree.getConcept
import org.modelix.model.api.IWriteTransaction
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.mpsadapters.mps.SConceptAdapter
import org.modelix.model.mpsadapters.mps.SModelAsNode
import java.util.Objects
import kotlin.jvm.functions.Function0.invoke
import kotlin.jvm.functions.Function1.invoke

/*Generated by MPS */
open class ModelsSynchronizer(cloudParentId: Long, val module: SModule?) :
    Synchronizer<SModel?>(cloudParentId, LINKS.`models$h3QT`.getName()) {

    protected override val mPSChildren: Iterable<MPSChildT>?
        protected get() {
            return ListSequence.fromList(
                SModuleUtils.getModelsWithoutDescriptor(
                    module
                )
            ).where(object : IWhereFilter<SModel>() {
                public override fun accept(it: SModel): Boolean {
                    return !(it.isReadOnly())
                }
            })
        }

    override fun createMPSChild(tree: ITree, cloudChildId: Long): SModel? {
        var id: SModelId? = getModelId(tree, cloudChildId)
        if (id == null) {
            id = jetbrains.mps.smodel.SModelId.foreign("cloud-" + cloudChildId)
        }
        val name: String? = tree.getProperty(cloudChildId, PROPS.`name$MnvL`.getName())
        return createModel(name, id, cloudChildId)
    }

    protected open fun createModel(name: String?, id: SModelId?, modelNodeId: Long): SModel? {
        return SModuleUtils.createModel(module, name, id)
    }

    public override fun removeMPSChild(mpsChild: SModel?) {
        ModelDeleteHelper((mpsChild)!!).delete()
    }

    public override fun associate(
        tree: ITree,
        cloudChildren: List<Long>,
        mpsChildren: List<SModel?>?,
        direction: SyncDirection?
    ): Map<Long?, SModel?> {
        val result: Map<Long?, SModel?> = MapSequence.fromMap(HashMap())
        val availableModels: List<SModel?> = ListSequence.fromListWithValues(ArrayList(), mpsChildren)
        for (cloudModelId: Long in cloudChildren) {
            val id: SModelId? = getModelId(tree, cloudModelId)
            val name: String? = tree.getProperty(cloudModelId, PROPS.`name$MnvL`.getName())

            // There can be models with duplicate names. That's why we can't just search in a map.
            val itr: MutableIterator<SModel?> = ListSequence.fromList(availableModels).iterator()
            while (itr.hasNext()) {
                val it: SModel? = itr.next()
                if (id != null && Objects.equals(it!!.getModelId(), id) || Objects.equals(
                        it!!.getName().getValue(),
                        name
                    )
                ) {
                    MapSequence.fromMap(result).put(cloudModelId, it)
                    itr.remove()
                    break
                }
            }
        }
        return result
    }

    protected fun getModelId(tree: ITree, cloudModelId: Long): SModelId? {
        val serializedId: String? = tree.getProperty(cloudModelId, PROPS.`id$lDUo`.getName())
        if ((serializedId == null || serializedId.length == 0)) {
            return null
        }
        return PersistenceFacade.getInstance().createModelId(serializedId)
    }

    public override fun createCloudChild(t: IWriteTransaction, mpsChild: SModel?): Long {
        val modelNodeId: Long = t.addNewChild(
            getCloudParentId(), LINKS.`models$h3QT`.getName(), -1, SConceptAdapter.Companion.wrap(
                CONCEPTS.`Model$2P`
            )
        )
        val modelAsNode: SModelAsNode = SModelAsNode((mpsChild)!!)
        for (property: IProperty in modelAsNode.getConcept().getAllProperties()) {
            t.setProperty(modelNodeId, property.name, modelAsNode.getPropertyValue(property.name))
        }
        t.setProperty(modelNodeId, PROPS.`id$lDUo`.getName(), mpsChild!!.getModelId().toString())
        t.setProperty(modelNodeId, "\$originalId", SModelAsNode((mpsChild)).reference.serialize())
        t.setProperty(modelNodeId, PROPS.`name$MnvL`.getName(), mpsChild.getName().getValue())
        return modelNodeId
    }

    public override fun syncToMPS(tree: ITree): Map<Long?, SModel?>? {
        val result: Map<Long?, SModel?>? = super.syncToMPS(tree)
        val projects: List<Project> = ProjectManager.getInstance().getOpenedProjects()
        if (ListSequence.fromList(projects).isNotEmpty()) {
            val project: Project = ListSequence.fromList(projects).first()
            ModuleDependencyVersions(
                LanguageRegistry.getInstance(project.getRepository()),
                project.getRepository()
            ).update(
                (module)!!
            )
        }
        return result
    }

    private object LINKS {
        /*package*/
        val `models$h3QT`: SContainmentLink = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            0x69652614fd1c512L,
            "models"
        )
    }

    private object PROPS {
        /*package*/
        val `name$MnvL`: SProperty = MetaAdapterFactory.getProperty(
            -0x3154ae6ada15b0deL,
            -0x646defc46a3573f4L,
            0x110396eaaa4L,
            0x110396ec041L,
            "name"
        )

        /*package*/
        val `id$lDUo`: SProperty = MetaAdapterFactory.getProperty(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            0x244b85440ee67212L,
            "id"
        )
    }

    private object CONCEPTS {
        /*package*/
        val `Model$2P`: SConcept = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50cL,
            "org.modelix.model.repositoryconcepts.structure.Model"
        )
    }
}
