package org.modelix.model.mpsplugin

import com.intellij.openapi.application.ApplicationManager
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers._T
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._return_P1_E0
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples
import jetbrains.mps.ide.ThreadUtils
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.smodel.MPSModuleRepository
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.jetbrains.mps.openapi.module.ModelAccess
import org.jetbrains.mps.openapi.module.SRepository
import java.awt.event.ActionEvent
import java.awt.event.ActionListener
import javax.swing.Timer

/*Generated by MPS */
object CommandHelper {
    private val LOG: Logger = LogManager.getLogger(CommandHelper::class.java)
    private lateinit var timer: Timer
    init {
        timer = Timer(
            10,
            object : ActionListener {
                public override fun actionPerformed(e: ActionEvent) {
                    val project: Project? = project
                    if (project == null) {
                        return
                    }
                    timer.stop()
                    val queueCopy: List<Tuples._2<Runnable, Boolean>> = ListSequence.fromListWithValues(ArrayList(), queue)
                    ListSequence.fromList(queue).clear()
                    for (entry: Tuples._2<Runnable, Boolean> in ListSequence.fromList(queueCopy)) {
                        try {
                            executeCommand(project.getRepository(), entry._1() as Boolean, entry._0())
                        } catch (ex: Exception) {
                            if (LOG.isEnabledFor(Level.ERROR)) {
                                LOG.error("", ex)
                            }
                        }
                    }
                }
            },
        )
    }
    private val queue: List<Tuples._2<Runnable, Boolean>> = ListSequence.fromList(ArrayList())
    fun runInUndoTransparentCommand(runnable: Runnable) {
        runInCommand(runnable, true)
    }

    @JvmOverloads
    fun runInCommand(runnable: Runnable, undoTransparent: Boolean = false) {
        val project: Project? = project
        if (project == null) {
            ListSequence.fromList(queue).addElement(MultiTuple.from(runnable, undoTransparent))
            if (!(timer.isRunning())) {
                timer.start()
            }
        } else {
            val ex: _T<Throwable?> = _T(null)
            val runnableWithExceptionHandling: Runnable = object : Runnable {
                public override fun run() {
                    try {
                        runnable.run()
                    } catch (t: Throwable) {
                        ex.value = t
                    }
                }
            }
            if (ThreadUtils.isInEDT()) {
                executeCommand(project.getRepository(), undoTransparent, runnableWithExceptionHandling)
            } else {
                ApplicationManager.getApplication().invokeAndWait(object : Runnable {
                    public override fun run() {
                        executeCommand(project.getRepository(), undoTransparent, runnableWithExceptionHandling)
                    }
                })
            }
            if (ex.value != null) {
                throw RuntimeException("Exception in command", ex.value)
            }
        }
    }

    fun executeCommand(repository: SRepository, undoTransparent: Boolean, runnable: Runnable) {
        ThreadUtils.assertEDT()
        val modelAccess: ModelAccess = repository.getModelAccess()
        if (modelAccess.canWrite()) {
            runnable.run()
        } else {
            if (undoTransparent) {
                modelAccess.executeUndoTransparentCommand(runnable)
            } else {
                modelAccess.executeCommand(runnable)
            }
        }
    }

    internal val project: Project
        internal get() {
            val projects: List<Project> = ProjectManager.getInstance().getOpenedProjects()
            return ListSequence.fromList(projects).first()
        }
    val sRepository: SRepository
        get() {
            val openedProjects: List<Project> = ProjectManager.getInstance().getOpenedProjects()
            val projectRepo: SRepository? =
                ListSequence.fromList(openedProjects).select(object : ISelector<Project, SRepository>() {
                    public override fun select(it: Project): SRepository {
                        return it.getRepository()
                    }
                }).where(NotNullWhereFilter<Any?>() as _return_P1_E0<Boolean?, SRepository>?).first()
            return (if (projectRepo != null) projectRepo else MPSModuleRepository.getInstance())
        }
}
