package org.modelix.model.mpsplugin.plugin

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes._void_P0_E0
import jetbrains.mps.internal.collections.runtime.IListSequence
import jetbrains.mps.internal.collections.runtime.ISelector
import jetbrains.mps.internal.collections.runtime.IVisitor
import jetbrains.mps.internal.collections.runtime.IWhereFilter
import jetbrains.mps.internal.collections.runtime.ListSequence
import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.internal.collections.runtime.SetSequence
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations
import jetbrains.mps.project.MPSProject
import jetbrains.mps.project.Project
import jetbrains.mps.project.ProjectManager
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory
import org.apache.log4j.LogManager
import org.jetbrains.mps.openapi.model.SNode
import org.modelix.model.api.IBranchListener
import org.modelix.model.api.ITree
import org.modelix.model.api.PNodeAdapter
import org.modelix.model.api.PNodeAdapter.Companion.wrap
import org.modelix.model.area.PArea
import org.modelix.model.client.ActiveBranch
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter
import org.modelix.model.mpsadapters.mps.SNodeAPI
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter
import org.modelix.model.mpsplugin.ModelServerConnection
import org.modelix.model.mpsplugin.ModelServerConnections
import org.modelix.model.mpsplugin.ProjectBinding
import org.modelix.model.mpsplugin.SharedExecutors
import org.modelix.model.mpsplugin.TransientModuleBinding
import org.modelix.model.mpsplugin.plugin.AutoBindings
import java.util.concurrent.ScheduledFuture

/*Generated by MPS */
class AutoBindings @JvmOverloads constructor(
    repositories: ModelServerConnections,
    fixedRepositoryIds: Iterable<RepositoryId>? = null,
    bindProjects: Boolean = false
) : ModelServerConnections.IListener, ModelServerConnection.IListener, IBranchListener {
    private val repositories: ModelServerConnections
    private val subscribedModelServers: Set<ModelServerConnection> = SetSequence.fromSet(HashSet())
    private val subscribedInfoBranches: Set<ModelServerConnection> = SetSequence.fromSet(HashSet())
    private val subscribedActiveBranches: Set<ActiveBranch> = SetSequence.fromSet(HashSet())

    @Volatile
    private var requiresUpdate = false
    private val fixedRepositories: List<RepositoryId>?
    private val bindProjects: Boolean
    private val updateJob: ScheduledFuture<*>?

    init {
        if (LOG.isDebugEnabled) {
            LOG.debug("AutoBindings.init")
        }
        this.repositories = repositories
        fixedRepositories =
            if (fixedRepositoryIds == null) null else Sequence.fromIterable(fixedRepositoryIds).toListSequence()
        this.bindProjects = bindProjects
        repositories.addListener(this)
        subscribeToServers()
        if (fixedRepositories == null) {
            subscribeToInfoBranches()
        }
        updateBindingsLater()
        updateJob = SharedExecutors.fixDelay(500) {
            if (requiresUpdate) {
                requiresUpdate = false
                updateBindings()
            }
        }
    }

    override fun repositoriesChanged() {
        if (LOG.isDebugEnabled) {
            LOG.debug("AutoBindings.repositoriesChanged")
        }
        subscribeToServers()
        subscribeToInfoBranches()
        updateBindingsLater()
    }

    protected fun subscribeToServers() {
        for (server in repositories.modelServers.minus(subscribedModelServers)) {
            server.addListener(this)
            SetSequence.fromSet(subscribedModelServers).addElement(server)
        }
    }

    override fun connectionStatusChanged(connected: Boolean) {
        if (LOG.isDebugEnabled) {
            LOG.debug("AutoBindings.connectionStatusChanged, $connected")
        }
        subscribeToInfoBranches()
        updateBindingsLater()
    }

    protected fun subscribeToInfoBranches() {
        for (repo in SetSequence.fromSet(subscribedModelServers).subtract(SetSequence.fromSet(subscribedInfoBranches))
            .where(object : IWhereFilter<ModelServerConnection>() {
                override fun accept(it: ModelServerConnection): Boolean {
                    return it.isConnected
                }
            })) {
            val infoBranch = repo.infoBranch
            if (infoBranch != null) {
                infoBranch.addListener(this)
                SetSequence.fromSet(subscribedInfoBranches).addElement(repo)
            }
        }
    }

    override fun treeChanged(oldTree: ITree?, newTree: ITree) {
        updateBindingsLater()
    }

    fun updateBindingsLater() {
        requiresUpdate = true
    }

    @Synchronized
    protected fun updateBindings() {
        if (LOG.isDebugEnabled) {
            LOG.debug("AutoBindings.updateBindings")
        }
        val allActiveBranches: List<ActiveBranch?> = ListSequence.fromList(ArrayList())
        for (connection in Sequence.fromIterable<ModelServerConnection?>(repositories.modelServers)
            .where(object : IWhereFilter<ModelServerConnection>() {
                override fun accept(it: ModelServerConnection): Boolean {
                    return it.isConnected
                }
            })) {
            if (LOG.isDebugEnabled) {
                LOG.debug("update bindings for " + connection.baseUrl)
            }
            var repositories: List<RepositoryId>
            repositories = if (fixedRepositories == null) {
                val info = connection.info
                PArea(connection.infoBranch!!).executeRead<IListSequence<RepositoryId>> {
                    ListSequence.fromList(SLinkOperations.getChildren(info, LINKS.`repositories$b56J`))
                        .select(object : ISelector<SNode?, RepositoryId>() {
                            override fun select(it: SNode?): RepositoryId {
                                return RepositoryId(SPropertyOperations.getString(it, PROPS.`id$baYB`))
                            }
                        }).toListSequence()
                }
            } else {
                fixedRepositories
            }
            if (LOG.isDebugEnabled) {
                LOG.debug(
                    "using repositories: " + ListSequence.fromList(repositories)
                        .select(object : ISelector<RepositoryId, String>() {
                            override fun select(it: RepositoryId): String {
                                return it.id
                            }
                        })
                )
            }
            for (repositoryId in ListSequence.fromList<RepositoryId>(repositories)) {
                val activeBranch = connection!!.getActiveBranch(repositoryId)
                if (LOG.isDebugEnabled) {
                    LOG.debug("using branch: " + activeBranch!!.branchName)
                }
                ListSequence.fromList(allActiveBranches).addElement(activeBranch)
                val outsideRead: List<_void_P0_E0> = ListSequence.fromList(ArrayList())
                PArea(activeBranch!!.branch).executeRead<Unit> {
                    val t = activeBranch.branch.transaction
                    val allChildren_ = t.getAllChildren(ITree.ROOT_ID)
                    val allChildren: Iterable<SNode> =
                        Sequence.fromIterable<Long>(allChildren_).select<SNode>(object : ISelector<Long, SNode>() {
                            override fun select(it: Long): SNode? {
                                return NodeToSNodeAdapter.wrap(
                                    PNodeAdapter.wrap(
                                        it, activeBranch.branch
                                    )
                                )!!
                            }
                        })
                    val allProjects = SNodeOperations.ofConcept(allChildren, CONCEPTS.`Project$An`)
                    var remainingProjects = allProjects
                    if (bindProjects) {
                        val firstProject = Sequence.fromIterable(allProjects).first()
                        if (LOG.isDebugEnabled) {
                            LOG.debug("trying to bind project: $firstProject")
                        }
                        remainingProjects = Sequence.fromIterable(allProjects).skip(1)
                        val projectNodeId =
                            if (firstProject == null) 0L else (SNodeToNodeAdapter.Companion.wrap(firstProject) as PNodeAdapter).nodeId
                        val mpsProjects = ProjectManager.getInstance().openedProjects
                        if (ListSequence.fromList<Project>(mpsProjects).isNotEmpty) {
                            if (LOG.isDebugEnabled) {
                                LOG.debug(
                                    "mps projects found: " + ListSequence.fromList<Project>(mpsProjects)
                                        .select<String>(object : ISelector<Project, String>() {
                                            override fun select(it: Project): String {
                                                return it.name
                                            }
                                        })
                                )
                            }
                            if (!connection.hasProjectBinding(repositoryId, projectNodeId)) {
                                if (LOG.isDebugEnabled) {
                                    LOG.debug("adding project binding")
                                }
                                if (projectNodeId != 0L && ListSequence.fromList(
                                        SLinkOperations.getChildren(
                                            firstProject,
                                            LINKS.`modules$Bi3g`
                                        )
                                    ).isEmpty()
                                ) {
                                    if (LOG.isDebugEnabled) {
                                        LOG.debug("Server side project doesn't contain any modules")
                                    }
                                }
                                ListSequence.fromList(outsideRead).addElement(_void_P0_E0 {
                                    connection.addBinding(
                                        repositoryId,
                                        ProjectBinding(
                                            ListSequence.fromList(mpsProjects).first() as MPSProject,
                                            projectNodeId,
                                            null
                                        )
                                    )
                                })
                            }
                        } else {
                            if (LOG.isDebugEnabled) {
                                LOG.debug("no mps project found yet")
                            }
                            updateBindingsLater()
                        }
                    }
                    val modules: Iterable<SNode> =
                        Sequence.fromIterable(SNodeOperations.ofConcept(allChildren, CONCEPTS.`Module$4i`)).concat(
                            Sequence.fromIterable(SLinkOperations.collectMany(remainingProjects, LINKS.`modules$Bi3g`))
                        )
                    for (module in Sequence.fromIterable<SNode>(modules)) {
                        val moduleNodeId = (SNodeToNodeAdapter.Companion.wrap(module) as PNodeAdapter).nodeId
                        if (connection.hasModuleBinding(repositoryId, moduleNodeId)) {
                            continue
                        }
                        ListSequence.fromList(outsideRead).addElement(_void_P0_E0 {
                            connection.addBinding(
                                repositoryId,
                                TransientModuleBinding(moduleNodeId)
                            )
                        })
                    }
                    Unit
                }
                ListSequence.fromList(outsideRead).visitAll(object : IVisitor<_void_P0_E0>() {
                    override fun visit(it: _void_P0_E0) {
                        it.invoke()
                    }
                })
            }
        }
        for (newBranch in ListSequence.fromList(allActiveBranches)
            .subtract(SetSequence.fromSet(subscribedActiveBranches)).toListSequence()) {
            newBranch!!.addListener(this)
        }
        for (removedBranch in SetSequence.fromSet(subscribedActiveBranches)
            .subtract(ListSequence.fromList(allActiveBranches)).toListSequence()) {
            removedBranch.removeListener(this)
            SetSequence.fromSet(subscribedActiveBranches).removeElement(removedBranch)
        }
    }

    fun dispose() {
        check_7p0tz2_a0a82(updateJob)
        for (repo in SetSequence.fromSet(subscribedInfoBranches)) {
            repo.infoBranch!!.removeListener(this)
        }
        for (repo in SetSequence.fromSet(subscribedModelServers)) {
            repo!!.removeListener(this)
        }
        repositories.removeListener(this)
    }

    private object LINKS {
        /*package*/
        val `repositories$b56J` = MetaAdapterFactory.getContainmentLink(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcbfL,
            0x62b7d9b07cecbcc2L,
            "repositories"
        )

        /*package*/
        val `modules$Bi3g` = MetaAdapterFactory.getContainmentLink(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            0x37a0917d689de9e2L,
            "modules"
        )
    }

    private object PROPS {
        /*package*/
        val `id$baYB` = MetaAdapterFactory.getProperty(
            -0x4967f1420fe2ba63L,
            -0x56adc78bf09cec4cL,
            0x62b7d9b07cecbcc0L,
            0x62b7d9b07cecbcc6L,
            "id"
        )
    }

    private object CONCEPTS {
        /*package*/
        val `Project$An` = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x37a0917d689de959L,
            "org.modelix.model.repositoryconcepts.structure.Project"
        )

        /*package*/
        val `Module$4i` = MetaAdapterFactory.getConcept(
            0xa7577d1d4e5431dL,
            -0x674e051c70651180L,
            0x69652614fd1c50fL,
            "org.modelix.model.repositoryconcepts.structure.Module"
        )
    }

    companion object {
        private val LOG = LogManager.getLogger(AutoBindings::class.java)
        private fun check_7p0tz2_a0a82(checkedDotOperand: ScheduledFuture<*>?): Boolean {
            return checkedDotOperand?.cancel(false) ?: false
        }
    }
}
