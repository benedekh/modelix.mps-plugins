package org.modelix.model.mpsplugin.plugin

import jetbrains.mps.internal.collections.runtime.Sequence
import jetbrains.mps.plugins.part.ApplicationPluginPart
import org.apache.log4j.Level
import org.apache.log4j.LogManager
import org.apache.log4j.Logger
import org.modelix.common.PropertyOrEnv
import org.modelix.model.lazy.RepositoryId
import org.modelix.model.mpsplugin.CloudTransientModules
import org.modelix.model.mpsplugin.ModelServerConnections
import org.modelix.model.mpsplugin.MpsReplicatedRepository
import org.modelix.model.mpsplugin.SharedExecutors

/*Generated by MPS */
class ApplicationPluginAppPluginPart : ApplicationPluginPart() {
    private var autoBindings: AutoBindings? = null
    override fun init() {
        println("Modelix Application Plugin - Started")
        System.out.flush()
        MetaMetaModelMappings.register()
        try {
            val executionMode: EModelixExecutionMode = ModelixConfigurationSystemProperties.executionMode
            println("Modelix Application Plugin - execution mode: " + executionMode)
            if (executionMode == EModelixExecutionMode.CLUSTER || executionMode == EModelixExecutionMode.PROJECTOR) {
                val modelUri: String? = PropertyOrEnv.get("MODEL_URI")
                if ((modelUri != null && modelUri.length > 0)) {
                    ModelServerConnections.instance.addModelServer(modelUri)
                }
                val repositoryId: String? = PropertyOrEnv.get("REPOSITORY_ID")
                var fixedRepositoryIds: Iterable<RepositoryId>? = null
                val bindProjects: Boolean = executionMode == EModelixExecutionMode.PROJECTOR
                if ((repositoryId != null && repositoryId.length > 0)) {
                    fixedRepositoryIds = Sequence.singleton(RepositoryId(repositoryId))
                }
                autoBindings =
                    AutoBindings(ModelServerConnections.instance, fixedRepositoryIds, bindProjects)
            }
            when (executionMode) {
                EModelixExecutionMode.CLUSTER -> {}
                EModelixExecutionMode.PROJECTOR -> {}
                EModelixExecutionMode.INTEGRATION_TESTS -> {}
                EModelixExecutionMode.MODEL_EXPORT -> ModelImportExport().cloud2mps()
                EModelixExecutionMode.MODEL_IMPORT -> ModelImportExport().mps2cloud()
                EModelixExecutionMode.DEFAULT -> {
                    val cloudReposSpecified: String? =
                        PropertyOrEnv.get(ModelixConfigurationSystemProperties.CLOUD_REPOS_SYSPROP)
                    if (cloudReposSpecified != null && (cloudReposSpecified != null && cloudReposSpecified.length > 0)) {
                        val repos: Array<String> =
                            cloudReposSpecified.split(",".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
                        for (repo: String? in repos) {
                            ModelServerConnections.instance.addModelServer(repo)
                        }
                    }
                }

                else -> if (LOG.isEnabledFor(Level.ERROR)) {
                    LOG.error("Unknown execution mode: " + executionMode)
                }
            }
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
    }

    override fun dispose() {
        MetaMetaModelMappings.unregister()
        try {
            MpsReplicatedRepository.Companion.disposeAll()
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        try {
            if (autoBindings != null) {
                autoBindings!!.dispose()
            }
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        try {
            ModelServerConnections.instance.dispose()
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        try {
            CloudTransientModules.instance.dispose()
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
        try {
            SharedExecutors.shutdownAll()
        } catch (ex: Exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex)
            }
        }
    }

    companion object {
        private val LOG: Logger = LogManager.getLogger(ApplicationPluginAppPluginPart::class.java)
    }
}
